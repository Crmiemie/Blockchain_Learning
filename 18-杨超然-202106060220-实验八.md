 <img src="/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-08-31 09.48.04.png" alt="截屏2023-08-31 09.48.04" style="zoom:60%;" />

| **报告名称**：   | 实验八：Gateway Asset-transfer-basic编写与运行实践 |
| ---------------- | -------------------------------------------------- |
| **学生姓名：**   | 杨超然                                             |
| **学生学号：**   | 202106060220                                       |
| **专业班级：**   | 信管2101班                                         |
| **学**  **院：** | 工商管理学院                                       |
| **指导老师：**   | 周中定                                             |
| **日  期：**     | 2023.11.7                                          |

------

[TOC]

------

# 一、实验说明

## （一）实验信息

**·实验路径：**.../go/src/github.com/hyperledger/fabric-samples/asset-transfer-basic/

**·实验内容：**本实验将从Fabric-samples中Asset-transfer-basic，探究其中application-gateway-go、chain code.go、application-go的生成和代码逻辑。并试着运行该案例。

## （二）实验前基本操作

### 1.下载*fabric-sample*

```shell
$ cd ~/go/src/github.com/hyperledger
$ git clone https://github.com/hyperledger/fabric-samples.git
$ cd fabric-samples
$ git checkout -b v2.5.3
```

![截屏2023-10-09 20.46.42](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-09 20.46.42.png)

![截屏2023-10-09 20.48.11](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-09 20.48.11.png)

### 2.移动*config*文件夹（移动配置文件）

（1）进入*fabric*文件夹，会发现*sampleconfig*，其实就是*fabric-samples*的*config*文件夹

（2）将*sampleconfig*文件夹移动到*fabric-samples*中，并且重命名为*config*

```shell
$ cd ~/go/src/github.com/hyperledger/fabric
$ cp -r sampleconfig ~/go/src/github.com/hyperledger/fabric-samples
$ cd ~/go/src/github.com/hyperledger/fabric-samples
$ mv sampleconfig config
```

![截屏2023-10-09 20.51.20](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-09 20.51.20.png)

### 3.创建并初始化*Fabric*网络

```bash
$ cd test-network
$ ./network.sh up -ca
$ ./network.sh createChannel
$ ./network.sh deployCC -ccn basic -ccp ../asset-transfer-basic/chaincode-go -ccl go
```

# 二、*Hyperledger Fabric Gateway*（网关）

## （一）官方文档与参考链接

[Hyperledger Fabric-gateway](https://hyperledger.github.io/fabric-gateway/)

[GitHub Link](https://github.com/hyperledger/fabric-gateway/)

![截屏2023-11-03 19.45.03](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-03 19.45.03.png)

*Fabric gateway*是 Hyperledger Fabric 区块链网络的核心组件，负责协调代表客户端应用程序提交交易和查询账本状态所需的操作。通过使用网关，客户端应用程序只需连接到结构网络中的单个终结点。

## （二）网关概述

[fabric-samples](https://github.com/hyperledger/fabric-samples) 存储库中有 *Go*、*Node* 和 *Java* 的示例，如果您想尝试新的 *Fabric Gateway*，这是一个很好的起点！

- [结构样本/资产转移基础](https://github.com/hyperledger/fabric-samples/tree/main/asset-transfer-basic)，用于交易提交和评估的示例。
- [结构样本/资产转移](https://github.com/hyperledger/fabric-samples/tree/main/asset-transfer-events)事件，以获取链码事件的示例。
- [结构样本/off_chain_data](https://github.com/hyperledger/fabric-samples/tree/main/off_chain_data)块事件的示例。

如果从其中一个旧版 Fabric 客户端 SDK 迁移现有应用程序，请参阅[迁移指南](https://hyperledger.github.io/fabric-gateway/migration)。

## （三）客户端接口

结构网关客户端 API 可用于多种编程语言，以支持开发使用网关与结构网络交互的客户端应用程序。

### 1.Go

- [快速入门指南](https://github.com/hyperledger/fabric-gateway/blob/main/pkg/client/README.md)
- [接口文档](https://pkg.go.dev/github.com/hyperledger/fabric-gateway/pkg/client)

### 2.Node

- [快速入门指南](https://github.com/hyperledger/fabric-gateway/blob/main/node/README.md)
- [接口文档](https://hyperledger.github.io/fabric-gateway/main/api/node/)

### 3.Java

- [快速入门指南](https://github.com/hyperledger/fabric-gateway/blob/main/java/README.md)
- [接口文档](https://hyperledger.github.io/fabric-gateway/main/api/java/)

## （四）兼容性

*Fabric*网关客户端 *API* 的每个次要版本都面向当前支持的 *Go* 版本，以及当前长期支持 （LTS） 版本的 Node 和 Java。网关对等方的特定最低版本的*Hyperledger Fabric*也需要完整的功能。

下表显示了 *Fabric* 版本、编程语言运行时以及经过显式测试并支持与 *Fabric* 网关客户端 API 一起使用的其他依赖项。

| ****       | **测试**         | **支持**         |
| ---------- | ---------------- | ---------------- |
| **Fabric** | **2.5**          | **2.4.4+**       |
| **go**     | 1.18, 1.19, 1.20 | 1.18, 1.19, 1.20 |
| **Node**   | 14, 16, 18       | 14, 16, 18       |
| **Java**   | 8, 11, 17        | 8, 11, 17        |
| **Linux**  | Ubuntu 22.04     |                  |

# 三、Asset-transfer-basic案例实践

## （一）关于案例

**fabric-samples/asset-transfer-basic**

[fabric-samples/asset-transfer-basic at main · hyperledger/fabric-samples · GitHub](https://github.com/hyperledger/fabric-samples/tree/main/asset-transfer-basic)

资产转移基本示例演示：

- 将客户端应用程序连接到 *Fabric* 区块链网络。
- 提交智能合约交易以更新账本状态。
- 评估智能合约交易以查询账本状态。
- 处理事务调用中的错误。

此示例包括多种语言的智能合约和应用程序代码。此示例演示资产的创建、读取、更新、传输和删除。

有关应用程序代码和客户端 API 用法的更详细演练，请参阅主 Hyperledger Fabric 文档中的[运行 Fabric 应用程序教程](https://hyperledger-fabric.readthedocs.io/en/latest/write_first_app.html)。

### 1.应用

遵循客户端应用程序代码中的执行流，并在运行应用程序时遵循相应的输出。注意以下顺序：

- 事务调用（控制台输出，如“**-->提交事务**”和“**-->评估事务**”）。
- 事务返回的结果（控制台输出，如“***\** 结果**”）。

### 2.智能合约

智能合约（在文件夹中）实现以下功能来支持应用程序：`chaincode-xyz`

- 创建资产
- 读取资产
- 更新资产
- 删除资源
- 转移资产

请注意，智能合约实现的资产转移是一个简化的场景，没有所有权验证，仅用于演示如何调用交易。

## （二）文件说明

本实例中主要的文件如下，请确保已经正确部署了application-gateway-go、application-go和chaincode-go

![截屏2023-11-05 10.45.40](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-05 10.45.40.png)

### 1.application-gateway-go

application-gateway-go 文件是一个用于实现应用网关功能的 Go 语言源代码文件。

应用网关（Application Gateway）是一种部署在网络边缘的代理服务器，用于对进出的网络流量进行管理和控制。它可以实现多种功能，例如安全防护、流量整形、负载均衡等。

在 Asset-transfer-basic 实验中，application-gateway-go 文件包含了实现应用网关功能的 Go 语言代码。通过编写和配置该文件，您可以定义网络流量的处理规则和行为，以确保资产转移过程的正确性和安全性。

具体来说，application-gateway-go 文件可以实现以下功能：

1. 接收客户端的请求，并根据规则对请求进行验证和处理。
2. 根据验证结果，将请求转发到相应的后端服务器或返回错误响应给客户端。
3. 对请求和响应数据进行记录和监控，以便进行审计和故障排除。
4. 提供安全防护功能，例如防止恶意请求、防止 DDoS 攻击等。
5. 对网络流量进行整形和控制，以确保后端服务器的性能和稳定性。

由此可见，application-gateway-go 文件是 Asset-transfer-basic 实验中实现应用网关功能的核心文件之一，用于管理和控制网络流量的进出，确保资产转移过程的正确性和安全性。

![截屏2023-11-07 20.00.54](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-07 20.00.54.png)

```go
/*
Copyright 2021 IBM All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package main

import (
	"bytes"
	"context"
	"crypto/x509"
	"encoding/json"
	"errors"
	"fmt"
	"os"
	"path"
	"time"

	"github.com/hyperledger/fabric-gateway/pkg/client"
	"github.com/hyperledger/fabric-gateway/pkg/identity"
	"github.com/hyperledger/fabric-protos-go-apiv2/gateway"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/status"
)

const (
	mspID        = "Org1MSP"
	cryptoPath   = "../../test-network/organizations/peerOrganizations/org1.example.com"
	certPath     = cryptoPath + "/users/User1@org1.example.com/msp/signcerts/cert.pem"
	keyPath      = cryptoPath + "/users/User1@org1.example.com/msp/keystore/"
	tlsCertPath  = cryptoPath + "/peers/peer0.org1.example.com/tls/ca.crt"
	peerEndpoint = "localhost:7051"
	gatewayPeer  = "peer0.org1.example.com"
)

var now = time.Now()
var assetId = fmt.Sprintf("asset%d", now.Unix()*1e3+int64(now.Nanosecond())/1e6)

func main() {
	// The gRPC client connection should be shared by all Gateway connections to this endpoint
	clientConnection := newGrpcConnection()
	defer clientConnection.Close()

	id := newIdentity()
	sign := newSign()

	// Create a Gateway connection for a specific client identity
	gw, err := client.Connect(
		id,
		client.WithSign(sign),
		client.WithClientConnection(clientConnection),
		// Default timeouts for different gRPC calls
		client.WithEvaluateTimeout(5*time.Second),
		client.WithEndorseTimeout(15*time.Second),
		client.WithSubmitTimeout(5*time.Second),
		client.WithCommitStatusTimeout(1*time.Minute),
	)
	if err != nil {
		panic(err)
	}
	defer gw.Close()

	// Override default values for chaincode and channel name as they may differ in testing contexts.
	chaincodeName := "basic"
	if ccname := os.Getenv("CHAINCODE_NAME"); ccname != "" {
		chaincodeName = ccname
	}

	channelName := "mychannel"
	if cname := os.Getenv("CHANNEL_NAME"); cname != "" {
		channelName = cname
	}

	network := gw.GetNetwork(channelName)
	contract := network.GetContract(chaincodeName)

	initLedger(contract)
	getAllAssets(contract)
	createAsset(contract)
	readAssetByID(contract)
	transferAssetAsync(contract)
	exampleErrorHandling(contract)
}

// newGrpcConnection creates a gRPC connection to the Gateway server.
func newGrpcConnection() *grpc.ClientConn {
	certificate, err := loadCertificate(tlsCertPath)
	if err != nil {
		panic(err)
	}

	certPool := x509.NewCertPool()
	certPool.AddCert(certificate)
	transportCredentials := credentials.NewClientTLSFromCert(certPool, gatewayPeer)

	connection, err := grpc.Dial(peerEndpoint, grpc.WithTransportCredentials(transportCredentials))
	if err != nil {
		panic(fmt.Errorf("failed to create gRPC connection: %w", err))
	}

	return connection
}

// newIdentity creates a client identity for this Gateway connection using an X.509 certificate.
func newIdentity() *identity.X509Identity {
	certificate, err := loadCertificate(certPath)
	if err != nil {
		panic(err)
	}

	id, err := identity.NewX509Identity(mspID, certificate)
	if err != nil {
		panic(err)
	}

	return id
}

func loadCertificate(filename string) (*x509.Certificate, error) {
	certificatePEM, err := os.ReadFile(filename)
	if err != nil {
		return nil, fmt.Errorf("failed to read certificate file: %w", err)
	}
	return identity.CertificateFromPEM(certificatePEM)
}

// newSign creates a function that generates a digital signature from a message digest using a private key.
func newSign() identity.Sign {
	files, err := os.ReadDir(keyPath)
	if err != nil {
		panic(fmt.Errorf("failed to read private key directory: %w", err))
	}
	privateKeyPEM, err := os.ReadFile(path.Join(keyPath, files[0].Name()))

	if err != nil {
		panic(fmt.Errorf("failed to read private key file: %w", err))
	}

	privateKey, err := identity.PrivateKeyFromPEM(privateKeyPEM)
	if err != nil {
		panic(err)
	}

	sign, err := identity.NewPrivateKeySign(privateKey)
	if err != nil {
		panic(err)
	}

	return sign
}

// This type of transaction would typically only be run once by an application the first time it was started after its
// initial deployment. A new version of the chaincode deployed later would likely not need to run an "init" function.
func initLedger(contract *client.Contract) {
	fmt.Printf("\n--> Submit Transaction: InitLedger, function creates the initial set of assets on the ledger \n")

	_, err := contract.SubmitTransaction("InitLedger")
	if err != nil {
		panic(fmt.Errorf("failed to submit transaction: %w", err))
	}

	fmt.Printf("*** Transaction committed successfully\n")
}

// Evaluate a transaction to query ledger state.
func getAllAssets(contract *client.Contract) {
	fmt.Println("\n--> Evaluate Transaction: GetAllAssets, function returns all the current assets on the ledger")

	evaluateResult, err := contract.EvaluateTransaction("GetAllAssets")
	if err != nil {
		panic(fmt.Errorf("failed to evaluate transaction: %w", err))
	}
	result := formatJSON(evaluateResult)

	fmt.Printf("*** Result:%s\n", result)
}

// Submit a transaction synchronously, blocking until it has been committed to the ledger.
func createAsset(contract *client.Contract) {
	fmt.Printf("\n--> Submit Transaction: CreateAsset, creates new asset with ID, Color, Size, Owner and AppraisedValue arguments \n")

	_, err := contract.SubmitTransaction("CreateAsset", assetId, "yellow", "5", "Tom", "1300")
	if err != nil {
		panic(fmt.Errorf("failed to submit transaction: %w", err))
	}

	fmt.Printf("*** Transaction committed successfully\n")
}

// Evaluate a transaction by assetID to query ledger state.
func readAssetByID(contract *client.Contract) {
	fmt.Printf("\n--> Evaluate Transaction: ReadAsset, function returns asset attributes\n")

	evaluateResult, err := contract.EvaluateTransaction("ReadAsset", assetId)
	if err != nil {
		panic(fmt.Errorf("failed to evaluate transaction: %w", err))
	}
	result := formatJSON(evaluateResult)

	fmt.Printf("*** Result:%s\n", result)
}

// Submit transaction asynchronously, blocking until the transaction has been sent to the orderer, and allowing
// this thread to process the chaincode response (e.g. update a UI) without waiting for the commit notification
func transferAssetAsync(contract *client.Contract) {
	fmt.Printf("\n--> Async Submit Transaction: TransferAsset, updates existing asset owner")

	submitResult, commit, err := contract.SubmitAsync("TransferAsset", client.WithArguments(assetId, "Mark"))
	if err != nil {
		panic(fmt.Errorf("failed to submit transaction asynchronously: %w", err))
	}

	fmt.Printf("\n*** Successfully submitted transaction to transfer ownership from %s to Mark. \n", string(submitResult))
	fmt.Println("*** Waiting for transaction commit.")

	if commitStatus, err := commit.Status(); err != nil {
		panic(fmt.Errorf("failed to get commit status: %w", err))
	} else if !commitStatus.Successful {
		panic(fmt.Errorf("transaction %s failed to commit with status: %d", commitStatus.TransactionID, int32(commitStatus.Code)))
	}

	fmt.Printf("*** Transaction committed successfully\n")
}

// Submit transaction, passing in the wrong number of arguments ,expected to throw an error containing details of any error responses from the smart contract.
func exampleErrorHandling(contract *client.Contract) {
	fmt.Println("\n--> Submit Transaction: UpdateAsset asset70, asset70 does not exist and should return an error")

	_, err := contract.SubmitTransaction("UpdateAsset", "asset70", "blue", "5", "Tomoko", "300")
	if err == nil {
		panic("******** FAILED to return an error")
	}

	fmt.Println("*** Successfully caught the error:")

	switch err := err.(type) {
	case *client.EndorseError:
		fmt.Printf("Endorse error for transaction %s with gRPC status %v: %s\n", err.TransactionID, status.Code(err), err)
	case *client.SubmitError:
		fmt.Printf("Submit error for transaction %s with gRPC status %v: %s\n", err.TransactionID, status.Code(err), err)
	case *client.CommitStatusError:
		if errors.Is(err, context.DeadlineExceeded) {
			fmt.Printf("Timeout waiting for transaction %s commit status: %s", err.TransactionID, err)
		} else {
			fmt.Printf("Error obtaining commit status for transaction %s with gRPC status %v: %s\n", err.TransactionID, status.Code(err), err)
		}
	case *client.CommitError:
		fmt.Printf("Transaction %s failed to commit with status %d: %s\n", err.TransactionID, int32(err.Code), err)
	default:
		panic(fmt.Errorf("unexpected error type %T: %w", err, err))
	}

	// Any error that originates from a peer or orderer node external to the gateway will have its details
	// embedded within the gRPC status error. The following code shows how to extract that.
	statusErr := status.Convert(err)

	details := statusErr.Details()
	if len(details) > 0 {
		fmt.Println("Error Details:")

		for _, detail := range details {
			switch detail := detail.(type) {
			case *gateway.ErrorDetail:
				fmt.Printf("- address: %s, mspId: %s, message: %s\n", detail.Address, detail.MspId, detail.Message)
			}
		}
	}
}

// Format JSON data
func formatJSON(data []byte) string {
	var prettyJSON bytes.Buffer
	if err := json.Indent(&prettyJSON, data, "", "  "); err != nil {
		panic(fmt.Errorf("failed to parse JSON: %w", err))
	}
	return prettyJSON.String()
}
```

![截屏2023-11-07 20.04.37](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-07 20.04.37.png)

### 2.application-go

application-go 文件是一个用于实现资产转移应用程序的 Go 语言源代码文件。

该文件包含了实现资产转移功能的 Go 语言代码。通过编写和配置该文件，您可以定义资产转移的规则和行为，包括创建资产、转移资产、确认转移等操作。

具体来说，application-go 文件可以实现以下功能：

1. 创建资产：定义资产的属性和状态，并将其存储在数据库或内存中。
2. 转移资产：根据转移请求，将资产从一个账户转移到另一个账户。这涉及到更新资产的状态和记录转移操作的历史记录。
3. 确认转移：在资产转移完成后，向参与转移的各方发送确认消息。这可以是通过电子邮件、短信或其他通信方式实现的。
4. 记录日志：对资产转移过程中的重要事件和操作进行记录，以便进行审计和故障排除。
5. 提供接口：提供RESTful API或其他形式的接口，以便客户端应用程序能够与资产转移应用程序进行交互。

总之，application-go 文件是 Asset-transfer-basic 实验中实现资产转移应用程序的核心文件之一，用于处理资产转移的规则和行为，并与其他组件（如应用网关）进行交互。

```go
/*
Copyright 2020 IBM All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package main

import (
	"fmt"
	"log"
	"os"
	"path/filepath"

	"github.com/hyperledger/fabric-sdk-go/pkg/core/config"
	"github.com/hyperledger/fabric-sdk-go/pkg/gateway"
)

func main() {
	log.Println("============ application-golang starts ============")

	err := os.Setenv("DISCOVERY_AS_LOCALHOST", "true")
	if err != nil {
		log.Fatalf("Error setting DISCOVERY_AS_LOCALHOST environment variable: %v", err)
	}

	walletPath := "wallet"
	// remove any existing wallet from prior runs
	os.RemoveAll(walletPath)
	wallet, err := gateway.NewFileSystemWallet(walletPath)
	if err != nil {
		log.Fatalf("Failed to create wallet: %v", err)
	}

	if !wallet.Exists("appUser") {
		err = populateWallet(wallet)
		if err != nil {
			log.Fatalf("Failed to populate wallet contents: %v", err)
		}
	}

	ccpPath := filepath.Join(
		"..",
		"..",
		"test-network",
		"organizations",
		"peerOrganizations",
		"org1.example.com",
		"connection-org1.yaml",
	)

	gw, err := gateway.Connect(
		gateway.WithConfig(config.FromFile(filepath.Clean(ccpPath))),
		gateway.WithIdentity(wallet, "appUser"),
	)
	if err != nil {
		log.Fatalf("Failed to connect to gateway: %v", err)
	}
	defer gw.Close()

	channelName := "mychannel"
	if cname := os.Getenv("CHANNEL_NAME"); cname != "" {
		channelName = cname
	}

	log.Println("--> Connecting to channel", channelName)
	network, err := gw.GetNetwork(channelName)
	if err != nil {
		log.Fatalf("Failed to get network: %v", err)
	}

	chaincodeName := "basic"
	if ccname := os.Getenv("CHAINCODE_NAME"); ccname != "" {
		chaincodeName = ccname
	}

	log.Println("--> Using chaincode", chaincodeName)
	contract := network.GetContract(chaincodeName)

	log.Println("--> Submit Transaction: InitLedger, function creates the initial set of assets on the ledger")
	result, err := contract.SubmitTransaction("InitLedger")
	if err != nil {
		log.Fatalf("Failed to Submit transaction: %v", err)
	}
	log.Println(string(result))

	log.Println("--> Evaluate Transaction: GetAllAssets, function returns all the current assets on the ledger")
	result, err = contract.EvaluateTransaction("GetAllAssets")
	if err != nil {
		log.Fatalf("Failed to evaluate transaction: %v", err)
	}
	log.Println(string(result))

	log.Println("--> Submit Transaction: CreateAsset, creates new asset with ID, color, owner, size, and appraisedValue arguments")
	result, err = contract.SubmitTransaction("CreateAsset", "asset113", "yellow", "5", "Tom", "1300")
	if err != nil {
		log.Fatalf("Failed to Submit transaction: %v", err)
	}
	log.Println(string(result))

	log.Println("--> Evaluate Transaction: ReadAsset, function returns an asset with a given assetID")
	result, err = contract.EvaluateTransaction("ReadAsset", "asset113")
	if err != nil {
		log.Fatalf("Failed to evaluate transaction: %v\n", err)
	}
	log.Println(string(result))

	log.Println("--> Evaluate Transaction: AssetExists, function returns 'true' if an asset with given assetID exist")
	result, err = contract.EvaluateTransaction("AssetExists", "asset1")
	if err != nil {
		log.Fatalf("Failed to evaluate transaction: %v\n", err)
	}
	log.Println(string(result))

	log.Println("--> Submit Transaction: TransferAsset asset1, transfer to new owner of Tom")
	_, err = contract.SubmitTransaction("TransferAsset", "asset1", "Tom")
	if err != nil {
		log.Fatalf("Failed to Submit transaction: %v", err)
	}

	log.Println("--> Evaluate Transaction: ReadAsset, function returns 'asset1' attributes")
	result, err = contract.EvaluateTransaction("ReadAsset", "asset1")
	if err != nil {
		log.Fatalf("Failed to evaluate transaction: %v", err)
	}
	log.Println(string(result))
	log.Println("============ application-golang ends ============")
}

func populateWallet(wallet *gateway.Wallet) error {
	log.Println("============ Populating wallet ============")
	credPath := filepath.Join(
		"..",
		"..",
		"test-network",
		"organizations",
		"peerOrganizations",
		"org1.example.com",
		"users",
		"User1@org1.example.com",
		"msp",
	)

	certPath := filepath.Join(credPath, "signcerts", "cert.pem")
	// read the certificate pem
	cert, err := os.ReadFile(filepath.Clean(certPath))
	if err != nil {
		return err
	}

	keyDir := filepath.Join(credPath, "keystore")
	// there's a single file in this dir containing the private key
	files, err := os.ReadDir(keyDir)
	if err != nil {
		return err
	}
	if len(files) != 1 {
		return fmt.Errorf("keystore folder should have contain one file")
	}
	keyPath := filepath.Join(keyDir, files[0].Name())
	key, err := os.ReadFile(filepath.Clean(keyPath))
	if err != nil {
		return err
	}

	identity := gateway.NewX509Identity("Org1MSP", string(cert), string(key))

	return wallet.Put("appUser", identity)
}
```

![截屏2023-11-07 20.06.34](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-07 20.06.34.png)

### 3.chaincode-go

chaincode-go 文件是智能合约的 Go 语言实现，用于实现资产转移的功能。

智能合约是一种自动执行合同条款的计算机程序，它运行在区块链网络上，用于管理资产和交易。chaincode-go 文件就是这样一个智能合约的示例，它实现了资产转移的功能。

在 chaincode-go 文件中，您可以编写 Go 语言代码来实现以下功能：

1. 定义资产：定义资产的属性和状态，例如名称、类型、数量等。
2. 转移资产：根据转移请求，将资产从一个账户转移到另一个账户。这涉及到更新资产的状态和记录转移操作的历史记录。
3. 确认转移：在资产转移完成后，向参与转移的各方发送确认消息。这可以通过链码调用时的输入参数来实现。
4. 记录日志：对资产转移过程中的重要事件和操作进行记录，以便进行审计和故障排除。
5. 提供接口：提供 RESTful API 或其他形式的接口，以便客户端应用程序能够与智能合约进行交互。

当编写完 chaincode-go 文件后，可以将其部署到 Hyperledger Fabric 区块链网络中，并在链码容器中运行。这样，您就可以通过链码调用实现资产转移的功能了。

```go
/*
SPDX-License-Identifier: Apache-2.0
*/

package main

import (
	"log"

	"github.com/hyperledger/fabric-contract-api-go/contractapi"
	"github.com/hyperledger/fabric-samples/asset-transfer-basic/chaincode-go/chaincode"
)

func main() {
	assetChaincode, err := contractapi.NewChaincode(&chaincode.SmartContract{})
	if err != nil {
		log.Panicf("Error creating asset-transfer-basic chaincode: %v", err)
	}

	if err := assetChaincode.Start(); err != nil {
		log.Panicf("Error starting asset-transfer-basic chaincode: %v", err)
	}
}
```

![截屏2023-11-07 20.08.04](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-07 20.08.04.png)

![截屏2023-11-07 20.08.16](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-07 20.08.16.png)

## （三）运行演示

### 1.创建测试网络和通道

```bash
$ cd ~/go/src/github.com/hyperledger/fabric-samples/test-network
$ ./network.sh up
$ ./network.sh up createChannel -c mychannel -ca
```

![截屏2023-11-05 09.34.48](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-05 09.34.48.png)

![截屏2023-11-05 09.36.00](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-05 09.36.00.png)

![截屏2023-11-05 09.36.16](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-05 09.36.16.png)

![截屏2023-11-05 09.36.28](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-05 09.36.28.png)

详细信息如下：

```bash
Using docker and docker-compose
Creating channel 'mychannel'.
If network is not up, starting nodes with CLI timeout of '5' tries and CLI delay of '3' seconds and using database 'leveldb 
Network Running Already
Using docker and docker-compose
Generating channel genesis block 'mychannel.block'
Using organization 1
/home/hadoop/go/bin/configtxgen
+ '[' 0 -eq 1 ']'
+ configtxgen -profile ChannelUsingRaft -outputBlock ./channel-artifacts/mychannel.block -channelID mychannel
2023-11-05 09:35:26.367 CST 0001 INFO [common.tools.configtxgen] main -> Loading configuration
2023-11-05 09:35:26.371 CST 0002 INFO [common.tools.configtxgen.localconfig] completeInitialization -> orderer type: etcdraft
2023-11-05 09:35:26.372 CST 0003 INFO [common.tools.configtxgen.localconfig] completeInitialization -> Orderer.EtcdRaft.Options unset, setting to tick_interval:"500ms" election_tick:10 heartbeat_tick:1 max_inflight_blocks:5 snapshot_interval_size:16777216 
2023-11-05 09:35:26.372 CST 0004 INFO [common.tools.configtxgen.localconfig] Load -> Loaded configuration: /home/hadoop/go/src/github.com/hyperledger/fabric-samples/test-network/configtx/configtx.yaml
2023-11-05 09:35:26.374 CST 0005 INFO [common.tools.configtxgen] doOutputBlock -> Generating genesis block
2023-11-05 09:35:26.374 CST 0006 INFO [common.tools.configtxgen] doOutputBlock -> Creating application channel genesis block
2023-11-05 09:35:26.374 CST 0007 INFO [common.tools.configtxgen] doOutputBlock -> Writing genesis block
+ res=0
Creating channel mychannel
Adding orderers
+ . scripts/orderer.sh mychannel
+ '[' 0 -eq 1 ']'
+ res=0
Status: 201
{
	"name": "mychannel",
	"url": "/participation/v1/channels/mychannel",
	"consensusRelation": "consenter",
	"status": "active",
	"height": 1
}

Channel 'mychannel' created
Joining org1 peer to the channel...
Using organization 1
+ peer channel join -b ./channel-artifacts/mychannel.block
+ res=0
2023-11-05 09:35:32.517 CST 0001 INFO [grpc] AddTraceEvent -> [core] [Channel #1] Channel created
2023-11-05 09:35:32.517 CST 0002 INFO [grpc] AddTraceEvent -> [core] [Channel #1] original dial target is: "localhost:7051"
2023-11-05 09:35:32.517 CST 0003 INFO [grpc] AddTraceEvent -> [core] [Channel #1] parsed dial target is: {Scheme:localhost Authority: URL:{Scheme:localhost Opaque:7051 User: Host: Path: RawPath: OmitHost:false ForceQuery:false RawQuery: Fragment: RawFragment:}}
2023-11-05 09:35:32.517 CST 0004 INFO [grpc] AddTraceEvent -> [core] [Channel #1] fallback to scheme "passthrough"
2023-11-05 09:35:32.517 CST 0005 INFO [grpc] AddTraceEvent -> [core] [Channel #1] parsed dial target is: {Scheme:passthrough Authority: URL:{Scheme:passthrough Opaque: User: Host: Path:/localhost:7051 RawPath: OmitHost:false ForceQuery:false RawQuery: Fragment: RawFragment:}}
2023-11-05 09:35:32.517 CST 0006 INFO [grpc] AddTraceEvent -> [core] [Channel #1] Channel authority set to "localhost:7051"
2023-11-05 09:35:32.518 CST 0007 INFO [grpc] AddTraceEvent -> [core] [Channel #1] Resolver state updated: {
  "Addresses": [
    {
      "Addr": "localhost:7051",
      "ServerName": "",
      "Attributes": null,
      "BalancerAttributes": null,
      "Type": 0,
      "Metadata": null
    }
  ],
  "ServiceConfig": null,
  "Attributes": null
} (resolver returned new addresses)
2023-11-05 09:35:32.518 CST 0008 INFO [grpc] AddTraceEvent -> [core] [Channel #1] Channel switches to new LB policy "pick_first"
2023-11-05 09:35:32.518 CST 0009 INFO [grpc] AddTraceEvent -> [core] [Channel #1 SubChannel #2] Subchannel created
2023-11-05 09:35:32.518 CST 000a INFO [grpc] AddTraceEvent -> [core] [Channel #1] Channel Connectivity change to CONNECTING
2023-11-05 09:35:32.518 CST 000b INFO [grpc] AddTraceEvent -> [core] [Channel #1 SubChannel #2] Subchannel Connectivity change to CONNECTING
2023-11-05 09:35:32.518 CST 000c INFO [grpc] AddTraceEvent -> [core] [Channel #1 SubChannel #2] Subchannel picks a new address "localhost:7051" to connect
2023-11-05 09:35:32.519 CST 000d INFO [grpc] Infof -> [core] pickfirstBalancer: UpdateSubConnState: 0x40003dfe48, {CONNECTING <nil>}
2023-11-05 09:35:32.524 CST 000e INFO [grpc] AddTraceEvent -> [core] [Channel #1 SubChannel #2] Subchannel Connectivity change to READY
2023-11-05 09:35:32.524 CST 000f INFO [grpc] Infof -> [core] pickfirstBalancer: UpdateSubConnState: 0x40003dfe48, {READY <nil>}
2023-11-05 09:35:32.524 CST 0010 INFO [grpc] AddTraceEvent -> [core] [Channel #1] Channel Connectivity change to READY
2023-11-05 09:35:32.524 CST 0011 INFO [channelCmd] InitCmdFactory -> Endorser and orderer connections initialized
2023-11-05 09:35:32.543 CST 0012 INFO [channelCmd] executeJoin -> Successfully submitted proposal to join channel
Joining org2 peer to the channel...
Using organization 2
+ peer channel join -b ./channel-artifacts/mychannel.block
+ res=0
2023-11-05 09:35:35.607 CST 0001 INFO [grpc] AddTraceEvent -> [core] [Channel #1] Channel created
2023-11-05 09:35:35.607 CST 0002 INFO [grpc] AddTraceEvent -> [core] [Channel #1] original dial target is: "localhost:9051"
2023-11-05 09:35:35.608 CST 0003 INFO [grpc] AddTraceEvent -> [core] [Channel #1] parsed dial target is: {Scheme:localhost Authority: URL:{Scheme:localhost Opaque:9051 User: Host: Path: RawPath: OmitHost:false ForceQuery:false RawQuery: Fragment: RawFragment:}}
2023-11-05 09:35:35.608 CST 0004 INFO [grpc] AddTraceEvent -> [core] [Channel #1] fallback to scheme "passthrough"
2023-11-05 09:35:35.608 CST 0005 INFO [grpc] AddTraceEvent -> [core] [Channel #1] parsed dial target is: {Scheme:passthrough Authority: URL:{Scheme:passthrough Opaque: User: Host: Path:/localhost:9051 RawPath: OmitHost:false ForceQuery:false RawQuery: Fragment: RawFragment:}}
2023-11-05 09:35:35.608 CST 0006 INFO [grpc] AddTraceEvent -> [core] [Channel #1] Channel authority set to "localhost:9051"
2023-11-05 09:35:35.608 CST 0007 INFO [grpc] AddTraceEvent -> [core] [Channel #1] Resolver state updated: {
  "Addresses": [
    {
      "Addr": "localhost:9051",
      "ServerName": "",
      "Attributes": null,
      "BalancerAttributes": null,
      "Type": 0,
      "Metadata": null
    }
  ],
  "ServiceConfig": null,
  "Attributes": null
} (resolver returned new addresses)
2023-11-05 09:35:35.608 CST 0008 INFO [grpc] AddTraceEvent -> [core] [Channel #1] Channel switches to new LB policy "pick_first"
2023-11-05 09:35:35.608 CST 0009 INFO [grpc] AddTraceEvent -> [core] [Channel #1 SubChannel #2] Subchannel created
2023-11-05 09:35:35.608 CST 000a INFO [grpc] AddTraceEvent -> [core] [Channel #1] Channel Connectivity change to CONNECTING
2023-11-05 09:35:35.608 CST 000b INFO [grpc] AddTraceEvent -> [core] [Channel #1 SubChannel #2] Subchannel Connectivity change to CONNECTING
2023-11-05 09:35:35.608 CST 000c INFO [grpc] AddTraceEvent -> [core] [Channel #1 SubChannel #2] Subchannel picks a new address "localhost:9051" to connect
2023-11-05 09:35:35.608 CST 000d INFO [grpc] Infof -> [core] pickfirstBalancer: UpdateSubConnState: 0x4000036768, {CONNECTING <nil>}
2023-11-05 09:35:35.610 CST 000e INFO [grpc] AddTraceEvent -> [core] [Channel #1 SubChannel #2] Subchannel Connectivity change to READY
2023-11-05 09:35:35.610 CST 000f INFO [grpc] Infof -> [core] pickfirstBalancer: UpdateSubConnState: 0x4000036768, {READY <nil>}
2023-11-05 09:35:35.610 CST 0010 INFO [grpc] AddTraceEvent -> [core] [Channel #1] Channel Connectivity change to READY
2023-11-05 09:35:35.610 CST 0011 INFO [channelCmd] InitCmdFactory -> Endorser and orderer connections initialized
2023-11-05 09:35:35.625 CST 0012 INFO [channelCmd] executeJoin -> Successfully submitted proposal to join channel
Setting anchor peer for org1...
Using organization 1
Fetching channel config for channel mychannel
Using organization 1
Fetching the most recent configuration block for the channel
+ peer channel fetch config config_block.pb -o orderer.example.com:7050 --ordererTLSHostnameOverride orderer.example.com -c mychannel --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/organizations/ordererOrganizations/example.com/tlsca/tlsca.example.com-cert.pem
2023-11-05 01:35:35.744 UTC 0001 INFO [channelCmd] InitCmdFactory -> Endorser and orderer connections initialized
2023-11-05 01:35:35.746 UTC 0002 INFO [cli.common] readBlock -> Received block: 0
2023-11-05 01:35:35.746 UTC 0003 INFO [channelCmd] fetch -> Retrieving last config block: 0
2023-11-05 01:35:35.746 UTC 0004 INFO [cli.common] readBlock -> Received block: 0
Decoding config block to JSON and isolating config to Org1MSPconfig.json
+ configtxlator proto_decode --input config_block.pb --type common.Block --output config_block.json
+ jq '.data.data[0].payload.data.config' config_block.json
Generating anchor peer update transaction for Org1 on channel mychannel
+ jq '.channel_group.groups.Application.groups.Org1MSP.values += {"AnchorPeers":{"mod_policy": "Admins","value":{"anchor_peers": [{"host": "peer0.org1.example.com","port": 7051}]},"version": "0"}}' Org1MSPconfig.json
+ configtxlator proto_encode --input Org1MSPconfig.json --type common.Config --output original_config.pb
+ configtxlator proto_encode --input Org1MSPmodified_config.json --type common.Config --output modified_config.pb
+ configtxlator compute_update --channel_id mychannel --original original_config.pb --updated modified_config.pb --output config_update.pb
+ configtxlator proto_decode --input config_update.pb --type common.ConfigUpdate --output config_update.json
+ jq .
++ cat config_update.json
+ echo '{"payload":{"header":{"channel_header":{"channel_id":"mychannel", "type":2}},"data":{"config_update":{' '"channel_id":' '"mychannel",' '"isolated_data":' '{},' '"read_set":' '{' '"groups":' '{' '"Application":' '{' '"groups":' '{' '"Org1MSP":' '{' '"groups":' '{},' '"mod_policy":' '"",' '"policies":' '{' '"Admins":' '{' '"mod_policy":' '"",' '"policy":' null, '"version":' '"0"' '},' '"Endorsement":' '{' '"mod_policy":' '"",' '"policy":' null, '"version":' '"0"' '},' '"Readers":' '{' '"mod_policy":' '"",' '"policy":' null, '"version":' '"0"' '},' '"Writers":' '{' '"mod_policy":' '"",' '"policy":' null, '"version":' '"0"' '}' '},' '"values":' '{' '"MSP":' '{' '"mod_policy":' '"",' '"value":' null, '"version":' '"0"' '}' '},' '"version":' '"0"' '}' '},' '"mod_policy":' '"",' '"policies":' '{},' '"values":' '{},' '"version":' '"0"' '}' '},' '"mod_policy":' '"",' '"policies":' '{},' '"values":' '{},' '"version":' '"0"' '},' '"write_set":' '{' '"groups":' '{' '"Application":' '{' '"groups":' '{' '"Org1MSP":' '{' '"groups":' '{},' '"mod_policy":' '"Admins",' '"policies":' '{' '"Admins":' '{' '"mod_policy":' '"",' '"policy":' null, '"version":' '"0"' '},' '"Endorsement":' '{' '"mod_policy":' '"",' '"policy":' null, '"version":' '"0"' '},' '"Readers":' '{' '"mod_policy":' '"",' '"policy":' null, '"version":' '"0"' '},' '"Writers":' '{' '"mod_policy":' '"",' '"policy":' null, '"version":' '"0"' '}' '},' '"values":' '{' '"AnchorPeers":' '{' '"mod_policy":' '"Admins",' '"value":' '{' '"anchor_peers":' '[' '{' '"host":' '"peer0.org1.example.com",' '"port":' 7051 '}' ']' '},' '"version":' '"0"' '},' '"MSP":' '{' '"mod_policy":' '"",' '"value":' null, '"version":' '"0"' '}' '},' '"version":' '"1"' '}' '},' '"mod_policy":' '"",' '"policies":' '{},' '"values":' '{},' '"version":' '"0"' '}' '},' '"mod_policy":' '"",' '"policies":' '{},' '"values":' '{},' '"version":' '"0"' '}' '}}}}'
+ configtxlator proto_encode --input config_update_in_envelope.json --type common.Envelope --output Org1MSPanchors.tx
2023-11-05 01:35:36.008 UTC 0001 INFO [channelCmd] InitCmdFactory -> Endorser and orderer connections initialized
2023-11-05 01:35:36.023 UTC 0002 INFO [channelCmd] update -> Successfully submitted channel update
Anchor peer set for org 'Org1MSP' on channel 'mychannel'
Setting anchor peer for org2...
Using organization 2
Fetching channel config for channel mychannel
Using organization 2
Fetching the most recent configuration block for the channel
+ peer channel fetch config config_block.pb -o orderer.example.com:7050 --ordererTLSHostnameOverride orderer.example.com -c mychannel --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/organizations/ordererOrganizations/example.com/tlsca/tlsca.example.com-cert.pem
2023-11-05 01:35:36.162 UTC 0001 INFO [channelCmd] InitCmdFactory -> Endorser and orderer connections initialized
2023-11-05 01:35:36.167 UTC 0002 INFO [cli.common] readBlock -> Received block: 1
2023-11-05 01:35:36.167 UTC 0003 INFO [channelCmd] fetch -> Retrieving last config block: 1
2023-11-05 01:35:36.168 UTC 0004 INFO [cli.common] readBlock -> Received block: 1
+ configtxlator proto_decode --input config_block.pb --type common.Block --output config_block.json
Decoding config block to JSON and isolating config to Org2MSPconfig.json
+ jq '.data.data[0].payload.data.config' config_block.json
Generating anchor peer update transaction for Org2 on channel mychannel
+ jq '.channel_group.groups.Application.groups.Org2MSP.values += {"AnchorPeers":{"mod_policy": "Admins","value":{"anchor_peers": [{"host": "peer0.org2.example.com","port": 9051}]},"version": "0"}}' Org2MSPconfig.json
+ configtxlator proto_encode --input Org2MSPconfig.json --type common.Config --output original_config.pb
+ configtxlator proto_encode --input Org2MSPmodified_config.json --type common.Config --output modified_config.pb
+ configtxlator compute_update --channel_id mychannel --original original_config.pb --updated modified_config.pb --output config_update.pb
+ configtxlator proto_decode --input config_update.pb --type common.ConfigUpdate --output config_update.json
+ jq .
++ cat config_update.json
+ echo '{"payload":{"header":{"channel_header":{"channel_id":"mychannel", "type":2}},"data":{"config_update":{' '"channel_id":' '"mychannel",' '"isolated_data":' '{},' '"read_set":' '{' '"groups":' '{' '"Application":' '{' '"groups":' '{' '"Org2MSP":' '{' '"groups":' '{},' '"mod_policy":' '"",' '"policies":' '{' '"Admins":' '{' '"mod_policy":' '"",' '"policy":' null, '"version":' '"0"' '},' '"Endorsement":' '{' '"mod_policy":' '"",' '"policy":' null, '"version":' '"0"' '},' '"Readers":' '{' '"mod_policy":' '"",' '"policy":' null, '"version":' '"0"' '},' '"Writers":' '{' '"mod_policy":' '"",' '"policy":' null, '"version":' '"0"' '}' '},' '"values":' '{' '"MSP":' '{' '"mod_policy":' '"",' '"value":' null, '"version":' '"0"' '}' '},' '"version":' '"0"' '}' '},' '"mod_policy":' '"",' '"policies":' '{},' '"values":' '{},' '"version":' '"0"' '}' '},' '"mod_policy":' '"",' '"policies":' '{},' '"values":' '{},' '"version":' '"0"' '},' '"write_set":' '{' '"groups":' '{' '"Application":' '{' '"groups":' '{' '"Org2MSP":' '{' '"groups":' '{},' '"mod_policy":' '"Admins",' '"policies":' '{' '"Admins":' '{' '"mod_policy":' '"",' '"policy":' null, '"version":' '"0"' '},' '"Endorsement":' '{' '"mod_policy":' '"",' '"policy":' null, '"version":' '"0"' '},' '"Readers":' '{' '"mod_policy":' '"",' '"policy":' null, '"version":' '"0"' '},' '"Writers":' '{' '"mod_policy":' '"",' '"policy":' null, '"version":' '"0"' '}' '},' '"values":' '{' '"AnchorPeers":' '{' '"mod_policy":' '"Admins",' '"value":' '{' '"anchor_peers":' '[' '{' '"host":' '"peer0.org2.example.com",' '"port":' 9051 '}' ']' '},' '"version":' '"0"' '},' '"MSP":' '{' '"mod_policy":' '"",' '"value":' null, '"version":' '"0"' '}' '},' '"version":' '"1"' '}' '},' '"mod_policy":' '"",' '"policies":' '{},' '"values":' '{},' '"version":' '"0"' '}' '},' '"mod_policy":' '"",' '"policies":' '{},' '"values":' '{},' '"version":' '"0"' '}' '}}}}'
+ configtxlator proto_encode --input config_update_in_envelope.json --type common.Envelope --output Org2MSPanchors.tx
2023-11-05 01:35:36.413 UTC 0001 INFO [channelCmd] InitCmdFactory -> Endorser and orderer connections initialized
2023-11-05 01:35:36.424 UTC 0002 INFO [channelCmd] update -> Successfully submitted channel update
Anchor peer set for org 'Org2MSP' on channel 'mychannel'
Channel 'mychannel' joined
```

### 2.部署其中一个链码

```bash
# To deploy the TypeScript chaincode implementation
./network.sh deployCC -ccn basic -ccp ../asset-transfer-basic/chaincode-typescript/ -ccl typescript

# To deploy the Go chaincode implementation
./network.sh deployCC -ccn basic -ccp ../asset-transfer-basic/chaincode-go/ -ccl go

# To deploy the Java chaincode implementation
./network.sh deployCC -ccn basic -ccp ../asset-transfer-basic/chaincode-java/ -ccl java
```

![截屏2023-11-05 09.40.36](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-05 09.40.36.png)

![截屏2023-11-05 09.40.09](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-05 09.40.09.png)

![截屏2023-11-05 09.43.52](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-05 09.43.52.png)

![截屏2023-11-05 09.52.22](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-05 09.52.22.png)

部署链码：

```bash
./network.sh deployCC -ccn basic -ccp ../asset-transfer-basic/chaincode-go/ -ccl go
```

![截屏2023-11-05 10.21.04](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-05 10.21.04.png)

部署详细信息：

```bash
magpie@DLTFabricer:~/go/src/github.com/hyperledger/fabric-samples/test-network$ ./network.sh deployCC -ccn basic -ccp ../asset-transfer-basic/chaincode-go/ -ccl go
Using docker and docker-compose
deploying chaincode on channel 'mychannel'
executing with the following
- CHANNEL_NAME: mychannel
- CC_NAME: basic
- CC_SRC_PATH: ../asset-transfer-basic/chaincode-go/
- CC_SRC_LANGUAGE: go
- CC_VERSION: 1.0
- CC_SEQUENCE: 1
- CC_END_POLICY: NA
- CC_COLL_CONFIG: NA
- CC_INIT_FCN: NA
- DELAY: 3
- MAX_RETRY: 5
- VERBOSE: false
Vendoring Go dependencies at ../asset-transfer-basic/chaincode-go/
~/go/src/github.com/hyperledger/fabric-samples/asset-transfer-basic/chaincode-go ~/go/src/github.com/hyperledger/fabric-samples/test-network
~/go/src/github.com/hyperledger/fabric-samples/test-network
Finished vendoring Go dependencies
+ peer lifecycle chaincode package basic.tar.gz --path ../asset-transfer-basic/chaincode-go/ --lang golang --label basic_1.0
+ res=0
++ peer lifecycle chaincode calculatepackageid basic.tar.gz
+ PACKAGE_ID=basic_1.0:28a1bfd3d9158bf905bd6a043d6ed9da0fb0e6bf65bb52cef930b6a54e48d5d7
Chaincode is packaged
Installing chaincode on peer0.org1...
Using organization 1
+ peer lifecycle chaincode queryinstalled --output json
+ jq -r 'try (.installed_chaincodes[].package_id)'
+ grep '^basic_1.0:28a1bfd3d9158bf905bd6a043d6ed9da0fb0e6bf65bb52cef930b6a54e48d5d7$'
+ test 1 -ne 0
+ peer lifecycle chaincode install basic.tar.gz
+ res=0
2023-06-02 00:48:50.109 UTC 0001 INFO [cli.lifecycle.chaincode] submitInstallProposal -> Installed remotely: response:<status:200 payload:"\nJbasic_1.0:28a1bfd3d9158bf905bd6a043d6ed9da0fb0e6bf65bb52cef930b6a54e48d5d7\022\tbasic_1.0" > 
2023-06-02 00:48:50.232 UTC 0002 INFO [cli.lifecycle.chaincode] submitInstallProposal -> Chaincode code package identifier: basic_1.0:28a1bfd3d9158bf905bd6a043d6ed9da0fb0e6bf65bb52cef930b6a54e48d5d7
Chaincode is installed on peer0.org1
Install chaincode on peer0.org2...
Using organization 2
+ peer lifecycle chaincode queryinstalled --output json
+ jq -r 'try (.installed_chaincodes[].package_id)'
+ grep '^basic_1.0:28a1bfd3d9158bf905bd6a043d6ed9da0fb0e6bf65bb52cef930b6a54e48d5d7$'
+ test 1 -ne 0
+ peer lifecycle chaincode install basic.tar.gz
+ res=0
2023-06-02 00:49:41.984 UTC 0001 INFO [cli.lifecycle.chaincode] submitInstallProposal -> Installed remotely: response:<status:200 payload:"\nJbasic_1.0:28a1bfd3d9158bf905bd6a043d6ed9da0fb0e6bf65bb52cef930b6a54e48d5d7\022\tbasic_1.0" > 
2023-06-02 00:49:41.985 UTC 0002 INFO [cli.lifecycle.chaincode] submitInstallProposal -> Chaincode code package identifier: basic_1.0:28a1bfd3d9158bf905bd6a043d6ed9da0fb0e6bf65bb52cef930b6a54e48d5d7
Chaincode is installed on peer0.org2
Using organization 1
+ peer lifecycle chaincode queryinstalled --output json
+ jq -r 'try (.installed_chaincodes[].package_id)'
+ grep '^basic_1.0:28a1bfd3d9158bf905bd6a043d6ed9da0fb0e6bf65bb52cef930b6a54e48d5d7$'
+ res=0
basic_1.0:28a1bfd3d9158bf905bd6a043d6ed9da0fb0e6bf65bb52cef930b6a54e48d5d7
Query installed successful on peer0.org1 on channel
Using organization 1
+ peer lifecycle chaincode approveformyorg -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile /home/magpie/go/src/github.com/hyperledger/fabric-samples/test-network/organizations/ordererOrganizations/example.com/tlsca/tlsca.example.com-cert.pem --channelID mychannel --name basic --version 1.0 --package-id basic_1.0:28a1bfd3d9158bf905bd6a043d6ed9da0fb0e6bf65bb52cef930b6a54e48d5d7 --sequence 1
+ res=0
2023-06-02 00:49:44.282 UTC 0001 INFO [chaincodeCmd] ClientWait -> txid [e2b2fe2c0512cb3bf36f219a2199d46e1aef556440f58bbe81339213b1ae3961] committed with status (VALID) at localhost:7051
Chaincode definition approved on peer0.org1 on channel 'mychannel'
Using organization 1
Checking the commit readiness of the chaincode definition on peer0.org1 on channel 'mychannel'...
Attempting to check the commit readiness of the chaincode definition on peer0.org1, Retry after 3 seconds.
+ peer lifecycle chaincode checkcommitreadiness --channelID mychannel --name basic --version 1.0 --sequence 1 --output json
+ res=0
{
        "approvals": {
                "Org1MSP": true,
                "Org2MSP": false
        }
}
Checking the commit readiness of the chaincode definition successful on peer0.org1 on channel 'mychannel'
Using organization 2
Checking the commit readiness of the chaincode definition on peer0.org2 on channel 'mychannel'...
Attempting to check the commit readiness of the chaincode definition on peer0.org2, Retry after 3 seconds.
+ peer lifecycle chaincode checkcommitreadiness --channelID mychannel --name basic --version 1.0 --sequence 1 --output json
+ res=0
{
        "approvals": {
                "Org1MSP": true,
                "Org2MSP": false
        }
}
Checking the commit readiness of the chaincode definition successful on peer0.org2 on channel 'mychannel'
Using organization 2
+ peer lifecycle chaincode approveformyorg -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile /home/magpie/go/src/github.com/hyperledger/fabric-samples/test-network/organizations/ordererOrganizations/example.com/tlsca/tlsca.example.com-cert.pem --channelID mychannel --name basic --version 1.0 --package-id basic_1.0:28a1bfd3d9158bf905bd6a043d6ed9da0fb0e6bf65bb52cef930b6a54e48d5d7 --sequence 1
+ res=0
2023-06-02 00:49:52.592 UTC 0001 INFO [chaincodeCmd] ClientWait -> txid [1ca2aca4b3ddaf9062ffc233d104348b26b36b703b781a116e0dcf330841024d] committed with status (VALID) at localhost:9051
Chaincode definition approved on peer0.org2 on channel 'mychannel'
Using organization 1
Checking the commit readiness of the chaincode definition on peer0.org1 on channel 'mychannel'...
Attempting to check the commit readiness of the chaincode definition on peer0.org1, Retry after 3 seconds.
+ peer lifecycle chaincode checkcommitreadiness --channelID mychannel --name basic --version 1.0 --sequence 1 --output json
+ res=0
{
        "approvals": {
                "Org1MSP": true,
                "Org2MSP": true
        }
}
Checking the commit readiness of the chaincode definition successful on peer0.org1 on channel 'mychannel'
Using organization 2
Checking the commit readiness of the chaincode definition on peer0.org2 on channel 'mychannel'...
Attempting to check the commit readiness of the chaincode definition on peer0.org2, Retry after 3 seconds.
+ peer lifecycle chaincode checkcommitreadiness --channelID mychannel --name basic --version 1.0 --sequence 1 --output json
+ res=0
{
        "approvals": {
                "Org1MSP": true,
                "Org2MSP": true
        }
}
Checking the commit readiness of the chaincode definition successful on peer0.org2 on channel 'mychannel'
Using organization 1
Using organization 2
+ peer lifecycle chaincode commit -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile /home/magpie/go/src/github.com/hyperledger/fabric-samples/test-network/organizations/ordererOrganizations/example.com/tlsca/tlsca.example.com-cert.pem --channelID mychannel --name basic --peerAddresses localhost:7051 --tlsRootCertFiles /home/magpie/go/src/github.com/hyperledger/fabric-samples/test-network/organizations/peerOrganizations/org1.example.com/tlsca/tlsca.org1.example.com-cert.pem --peerAddresses localhost:9051 --tlsRootCertFiles /home/magpie/go/src/github.com/hyperledger/fabric-samples/test-network/organizations/peerOrganizations/org2.example.com/tlsca/tlsca.org2.example.com-cert.pem --version 1.0 --sequence 1
+ res=0
2023-06-02 00:50:01.229 UTC 0001 INFO [chaincodeCmd] ClientWait -> txid [f68dc92e7b99f6348e2e1e1a73a0954e3f741c4772034f9c848b784f51c7c1ed] committed with status (VALID) at localhost:7051
2023-06-02 00:50:01.264 UTC 0002 INFO [chaincodeCmd] ClientWait -> txid [f68dc92e7b99f6348e2e1e1a73a0954e3f741c4772034f9c848b784f51c7c1ed] committed with status (VALID) at localhost:9051
Chaincode definition committed on channel 'mychannel'
Using organization 1
Querying chaincode definition on peer0.org1 on channel 'mychannel'...
Attempting to Query committed status on peer0.org1, Retry after 3 seconds.
+ peer lifecycle chaincode querycommitted --channelID mychannel --name basic
+ res=0
Committed chaincode definition for chaincode 'basic' on channel 'mychannel':
Version: 1.0, Sequence: 1, Endorsement Plugin: escc, Validation Plugin: vscc, Approvals: [Org1MSP: true, Org2MSP: true]
Query chaincode definition successful on peer0.org1 on channel 'mychannel'
Using organization 2
Querying chaincode definition on peer0.org2 on channel 'mychannel'...
Attempting to Query committed status on peer0.org2, Retry after 3 seconds.
+ peer lifecycle chaincode querycommitted --channelID mychannel --name basic
+ res=0
Committed chaincode definition for chaincode 'basic' on channel 'mychannel':
Version: 1.0, Sequence: 1, Endorsement Plugin: escc, Validation Plugin: vscc, Approvals: [Org1MSP: true, Org2MSP: true]
Query chaincode definition successful on peer0.org2 on channel 'mychannel'
Chaincode initialization is not required
magpie@DLTFabricer:~/go/src/github.com/hyperledger/fabric-samples/test-network$ 
```

### 3.运行程序

```bash
# To run the Typescript sample application
cd application-gateway-typescript
npm install
npm start

# To run the Go sample application
cd ~/go/src/github.com/hyperledger/fabric-samples/asset-transfer-basic
cd application-gateway-go
go run .

# To run the Java sample application
cd application-gateway-java
./gradlew run
```

![截屏2023-11-05 10.23.37](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-05 10.23.37.png)

![截屏2023-11-05 10.36.50](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-05 10.36.50.png)

运行详细信息：

```bash
cd ~/go/src/github.com/hyperledger/fabric-samples/asset-transfer-basic/application-gateway-go$

magpie@DLTFabricer:~/go/src/github.com/hyperledger/fabric-samples/asset-transfer-basic/application-gateway-go$ go run .
go: downloading github.com/hyperledger/fabric-gateway v1.2.2
go: downloading google.golang.org/genproto v0.0.0-20230216225411-c8e22ba71e44

--> Submit Transaction: InitLedger, function creates the initial set of assets on the ledger 
*** Transaction committed successfully

--> Evaluate Transaction: GetAllAssets, function returns all the current assets on the ledger
*** Result:[
  {
    "AppraisedValue": 300,
    "Color": "blue",
    "ID": "asset1",
    "Owner": "Tomoko",
    "Size": 5
  },
  {
    "AppraisedValue": 400,
    "Color": "red",
    "ID": "asset2",
    "Owner": "Brad",
    "Size": 5
  },
  {
    "AppraisedValue": 500,
    "Color": "green",
    "ID": "asset3",
    "Owner": "Jin Soo",
    "Size": 10
  },
  {
    "AppraisedValue": 600,
    "Color": "yellow",
    "ID": "asset4",
    "Owner": "Max",
    "Size": 10
  },
  {
    "AppraisedValue": 700,
    "Color": "black",
    "ID": "asset5",
    "Owner": "Adriana",
    "Size": 15
  },
  {
    "AppraisedValue": 800,
    "Color": "white",
    "ID": "asset6",
    "Owner": "Michel",
    "Size": 15
  }
]

--> Submit Transaction: CreateAsset, creates new asset with ID, Color, Size, Owner and AppraisedValue arguments 
*** Transaction committed successfully

--> Evaluate Transaction: ReadAsset, function returns asset attributes
*** Result:{
  "AppraisedValue": 1300,
  "Color": "yellow",
  "ID": "asset1685667849677",
  "Owner": "Tom",
  "Size": 5
}

--> Async Submit Transaction: TransferAsset, updates existing asset owner
*** Successfully submitted transaction to transfer ownership from Tom to Mark. 
*** Waiting for transaction commit.
*** Transaction committed successfully

--> Submit Transaction: UpdateAsset asset70, asset70 does not exist and should return an error
*** Successfully caught the error:
Endorse error for transaction 8b30516b9691d27b6c3f4f9e32d9f78dbf582ced7d63354bbaf9c0d58945bd3c with gRPC status Aborted: rpc error: code = Aborted desc = failed to endorse transaction, see attached details for more info
Error Details:
- address: peer0.org1.example.com:7051, mspId: Org1MSP, message: chaincode response 500, the asset asset70 does not exist
magpie@DLTFabricer:~/go/src/github.com/hyperledger/fabric-samples/asset-transfer-basic/application-gateway-go$ 
```

## （四）运行之后

运行完毕之后，进入test- network文件夹删除测试网络的所有节点，并删除您创建的任何账本数据，以便于进行后续实验：

```bash
./network.sh down
```

![截屏2023-11-05 10.39.00](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-05 10.39.00.png)

# 四、报错及解决方案

**1.Error: chaincode install failed with status: 500 - failed to invoke backing implementation of 'InstallChaincode': could not build chaincode: failed to get chaincode package for external build: could not get legacy chaincode package 'basic_1.0.1:8c7091da34c9ed25544ae7cc150fe5484995b9316cbd504f66ac7b810ed8bbdf': open /var/hyperledger/production/chaincodes/basic_1.0.1.8c7091da34c9ed25544ae7cc150fe5484995b9316cbd504f66ac7b810ed8bbdf: no such file or directory**

![截屏2023-11-05 09.50.23](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-05 09.50.23.png)

**解决方案：**到链码所在的目录下提前下载依赖包

```bash
cd fabric-samples/asset-transfer-basic/chaincode-go
```

打开终端：更改go代理

go env -w GOPROXY=https://goproxy.cn,direct

go env -w GO111MODULE=on

go mod vendor

之后就可以正常下载了

![截屏2023-11-05 10.44.12](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-05 10.44.12.png)

# 五、实验心得

本周，我深入学习了 Gateway Asset-transfer-basic 的编写与运行，通过实际操作官方提供的 Asset-transfer-basic 案例，我获得了许多宝贵的经验和教训。

首先，我深刻体会到了基础知识的重要性。在编程过程中，我经常遇到一些棘手的问题，这些问题往往源于我对基础知识的掌握不够深入。例如，在编写 Gateway Asset-transfer-basic 时，我需要对网络协议、编程语言特性和系统调用等基础知识有深入的理解。只有这样，我才能更好地理解问题的本质，找到合适的解决方案。

在实验过程中，我也遇到了一些困难，但都不是什么大问题，都是像在编写代码时，可能会会遇到语法错误和逻辑错误。只要通过仔细阅读文档和调试代码，便可以找到解决问题的方法。这个过程最重要的还是自己体会编写和调试代码的流程，再说了，老师自己运行过一遍的实验指南也能够让我们充分坚持和借鉴，因此除了有些时候从GitHub下东西慢了点，也没有报什么很棘手的错误（前提是版本一定不能乱装！），整个实验过程还是十分顺利的

对于未来的学习和工作，我将继续加强基础知识的学习，提高自己的编程能力。同时，我会积极参与团队项目，提高自己的团队协作能力。我希望能够在未来的学习和工作中不断进步，实现自己的职业目标。

总之，通过这个实验，我不仅学到了很多关于 Gateway Asset-transfer-basic 编写与运行的知识，还深刻认识到了基础知识、团队协作和调试代码的重要性。这些经验和教训将对我的未来学习和工作产生积极的影响。
