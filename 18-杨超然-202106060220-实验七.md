 <img src="/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-08-31 09.48.04.png" alt="截屏2023-08-31 09.48.04" style="zoom:60%;" />

| **报告名称**：   | 实验八：Hyperledger Fabric链码编写实践 |
| ---------------- | -------------------------------------- |
| **学生姓名：**   | 杨超然                                 |
| **学生学号：**   | 202106060220                           |
| **专业班级：**   | 信管2101班                             |
| **学**  **院：** | 工商管理学院                           |
| **指导老师：**   | 周中定                                 |
| **日  期：**     | 2023.9.7                               |

------

[TOC]

------

# What isChainChode?

[¶Reference Link](https://hyperledger-fabric.readthedocs.io/en/latest/chaincode4ade.html#what-is-chaincode)

链码是一个程序，用[Go](https://golang.org/)编写，[Node.js](https://nodejs.org/)， 或实现规定接口的 [Java](https://java.com/en/)。 链码在与对等节点不同的进程中运行，并初始化和管理 账本状态通过应用程序提交的事务。

链码通常处理由 网络，所以它类似于“智能合约”。可以调用链码来更新或查询 建议交易中的分类账。给定适当的权限，链码 可以调用另一个链码，无论是在同一通道还是在不同的通道中，以访问其状态。 请注意，如果被调用链码与调用链码位于不同的通道上， 只允许读取查询。也就是说，不同通道上被调用的链码只是一个， 在后续提交阶段不参与状态验证检查。`Query`

在以下部分中，我们将通过 应用程序开发人员。我们将提供一个资产转移链码示例演练， 以及结构协定 API 中每种方法的用途。如果你 是将链码部署到正在运行的网络的网络运营商， 访问将[智能合约部署到通道](https://hyperledger-fabric.readthedocs.io/en/latest/deploy_chaincode.html)教程和 [Fabric 链码生命周期](https://hyperledger-fabric.readthedocs.io/en/latest/chaincode_lifecycle.html)概念主题。

![截屏2023-10-27 09.00.21](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-27 09.00.21.png)

# Fabric Contract API(结构合约接口)

[¶Reference Link](https://hyperledger-fabric.readthedocs.io/en/latest/chaincode4ade.html#fabric-contract-api)

它提供了合约接口，这是一个高级API，供应用程序开发人员实现智能合约。 在Hyperledger Fabric中，智能合约也被称为链码。使用此 API 为编写业务逻辑提供了高级入口点。 不同语言的结构合约 API 文档可在以下链接中找到：`fabric-contract-api`

> - [Go](https://godoc.org/github.com/hyperledger/fabric-contract-api-go/contractapi)
> - [Node.js](https://hyperledger.github.io/fabric-chaincode-node/main/api/)
> - [Java](https://hyperledger.github.io/fabric-chaincode-java/main/api/org/hyperledger/fabric/contract/package-summary.html)

请注意，在使用合约 API 时，调用的每个链码函数都会传递一个交易上下文“ctx”，从该上下文中传递 你可以获取链码存根（GetStub（） ），它具有访问账本（例如 GetState（） ）和发出请求的功能 更新账本（例如 PutState（） ）。您可以通过下面的特定语言链接了解更多信息。

> - [Go](https://godoc.org/github.com/hyperledger/fabric-chaincode-go/shim#Chaincode)
> - [Node.js](https://hyperledger.github.io/fabric-chaincode-node/main/api/fabric-shim.ChaincodeInterface.html)
> - [Java](https://hyperledger.github.io/fabric-chaincode-java/main/api/org/hyperledger/fabric/shim/Chaincode.html)

在本教程中使用 Go 链码，我们将演示这些 API 的使用 通过实现管理简单“资产”的资产转移链码应用程序。

# Asset Transfer Chaincode

[¶Reference Link](https://hyperledger-fabric.readthedocs.io/en/latest/chaincode4ade.html#asset-transfer-chaincodei)

本次实验中的实验程序是一个基于reference link的基本的示例链码，用于初始化资产的账本，创建、读取、更新和删除资产，检查以查看 如果资产存在，并将资产从一个所有者转移到另一个所有者。

## Choosing a Location for the Code

[¶Reference Link](https://hyperledger-fabric.readthedocs.io/en/latest/chaincode4ade.html#choosing-a-location-for-the-code)

本次实验使用Go语言进行编程，请确保已经安装了[Go](https://golang.org/)并正确配置了系统。

现在，我们需要为链码应用程序创建一个目录。

为了简单起见，让我们使用以下命令：

```bash
mkdir atcc
cd atcc
```

![截屏2023-10-28 13.24.11](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-28 13.24.11.png)

现在，让我们创建模块和源文件，我们将用如下代码填充这些文件：

```bash
go mod init atcc
touch atcc.go
```

![截屏2023-10-28 13.25.09](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-28 13.25.09.png)

## Housekeeping

[¶Reference Link](https://hyperledger-fabric.readthedocs.io/en/latest/chaincode4ade.html#housekeeping)

首先，让我们从一些必要的内部代码管理开始。与每个链码一样，它实现了结构-[合约-api接口](https://godoc.org/github.com/hyperledger/fabric-contract-api-go/contractapi)， 因此，让我们为链码的必要依赖项添加 Go import 语句。我们将导入 结构合约 API 包并定义我们的智能合约。

```go
// atcc.go中加入
package main

import (
  "fmt"
  "encoding/json"
  "log"
  "github.com/hyperledger/fabric-contract-api-go/contractapi"
)

// SmartContract provides functions for managing an Asset
type SmartContract struct {
  contractapi.Contract
}
```

![截屏2023-10-28 13.30.42](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-28 13.30.42.png)接下来，让我们添加一个结构来表示账本上的简单资产。 请注意 JSON 注释，该注释将用于将资产封送到存储在账本上的 JSON。 JSON虽然不是一种确定性的数据格式 - 元素的顺序可以改变，同时仍然在语义上表示相同的数据。 因此，挑战在于能够生成一组一致的 JSON。 下面还显示了实现一致性的好方法，该方法包括按照字母顺序创建资产对象结构。

```go
// Asset describes basic details of what makes up a simple asset
// Insert struct field in alphabetic order => to achieve determinism accross languages
// golang keeps the order when marshal to json but doesn't order automatically

type Asset struct {
  AppraisedValue int    `json:"AppraisedValue"`
  Color          string `json:"Color"`
  ID             string `json:"ID"`
  Owner          string `json:"Owner"`
  Size           int    `json:"Size"`
}
```

![截屏2023-10-28 13.31.05](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-28 13.31.05.png)

## Initializing the Chaincode

接下来，我们将实现该函数，用一些初始数据填充账本。

```go
// InitLedger adds a base set of assets to the ledger
func (s *SmartContract) InitLedger(ctx contractapi.TransactionContextInterface) error {
  assets := []Asset{
    {ID: "asset1", Color: "blue", Size: 5, Owner: "Tomoko", AppraisedValue: 300},
    {ID: "asset2", Color: "red", Size: 5, Owner: "Brad", AppraisedValue: 400},
    {ID: "asset3", Color: "green", Size: 10, Owner: "Jin Soo", AppraisedValue: 500},
    {ID: "asset4", Color: "yellow", Size: 10, Owner: "Max", AppraisedValue: 600},
    {ID: "asset5", Color: "black", Size: 15, Owner: "Adriana", AppraisedValue: 700},
    {ID: "asset6", Color: "white", Size: 15, Owner: "Michel", AppraisedValue: 800},
  }

  for _, asset := range assets {
    assetJSON, err := json.Marshal(asset)
    if err != nil {
        return err
    }

    err = ctx.GetStub().PutState(asset.ID, assetJSON)
    if err != nil {
        return fmt.Errorf("failed to put to world state. %v", err)
    }
  }

  return nil
}
```

![截屏2023-10-28 13.32.33](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-28 13.32.33.png)

然后，编写一个函数，在账本上创建一个尚不存在的资产。在编写链码时，它 在对账本采取行动之前检查账本上是否存在某物是个好主意，如图所示 在下面的函数中。

```go
// CreateAsset issues a new asset to the world state with given details.
func (s *SmartContract) CreateAsset(ctx contractapi.TransactionContextInterface, id string, color string, size int, owner string, appraisedValue int) error {
  exists, err := s.AssetExists(ctx, id)
  if err != nil {
    return err
  }
  if exists {
    return fmt.Errorf("the asset %s already exists", id)
  }

  asset := Asset{
    ID:             id,
    Color:          color,
    Size:           size,
    Owner:          owner,
    AppraisedValue: appraisedValue,
  }
  assetJSON, err := json.Marshal(asset)
  if err != nil {
    return err
  }

  return ctx.GetStub().PutState(id, assetJSON)
}
```

![截屏2023-10-28 13.33.59](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-28 13.33.59.png)

现在我们已经用一些初始资产填充了账本并创建了一个资产， 让我们编写一个函数，允许我们从账本中读取资产。

```go
// ReadAsset returns the asset stored in the world state with given id.
func (s *SmartContract) ReadAsset(ctx contractapi.TransactionContextInterface, id string) (*Asset, error) {
  assetJSON, err := ctx.GetStub().GetState(id)
  if err != nil {
    return nil, fmt.Errorf("failed to read from world state: %v", err)
  }
  if assetJSON == nil {
    return nil, fmt.Errorf("the asset %s does not exist", id)
  }

  var asset Asset
  err = json.Unmarshal(assetJSON, &asset)
  if err != nil {
    return nil, err
  }

  return &asset, nil
}
```

![截屏2023-10-28 13.34.55](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-28 13.34.55.png)

现在我们的账本上有可以与之交互的资产，让我们编写一个链码函数，允许我们更新允许更改的资产的属性。

```go
// UpdateAsset updates an existing asset in the world state with provided parameters.
func (s *SmartContract) UpdateAsset(ctx contractapi.TransactionContextInterface, id string, color string, size int, owner string, appraisedValue int) error {
  exists, err := s.AssetExists(ctx, id)
  if err != nil {
    return err
  }
  if !exists {
    return fmt.Errorf("the asset %s does not exist", id)
  }

  // overwriting original asset with new asset
  asset := Asset{
    ID:             id,
    Color:          color,
    Size:           size,
    Owner:          owner,
    AppraisedValue: appraisedValue,
  }
  assetJSON, err := json.Marshal(asset)
  if err != nil {
    return err
  }

  return ctx.GetStub().PutState(id, assetJSON)
}
```

![截屏2023-10-28 13.36.13](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-28 13.36.13.png)

在某些情况下，我们需要能够从分类账中删除资产， 因此，让我们编写一个函数来处理该需求。

```go
// DeleteAsset deletes an given asset from the world state.
func (s *SmartContract) DeleteAsset(ctx contractapi.TransactionContextInterface, id string) error {
  exists, err := s.AssetExists(ctx, id)
  if err != nil {
    return err
  }
  if !exists {
    return fmt.Errorf("the asset %s does not exist", id)
  }

  return ctx.GetStub().DelState(id)
}
```

之后，编写函数实现检查资产是否存在的行动

```go
// AssetExists returns true when asset with given ID exists in world state
func (s *SmartContract) AssetExists(ctx contractapi.TransactionContextInterface, id string) (bool, error) {
  assetJSON, err := ctx.GetStub().GetState(id)
  if err != nil {
    return false, fmt.Errorf("failed to read from world state: %v", err)
  }

  return assetJSON != nil, nil
}
```

接下来，我们将编写一个函数，该函数支持将资产从一个所有者转移到另一个所有者

```python
// TransferAsset updates the owner field of asset with given id in world state.
func (s *SmartContract) TransferAsset(ctx contractapi.TransactionContextInterface, id string, newOwner string) error {
  asset, err := s.ReadAsset(ctx, id)
  if err != nil {
    return err
  }

  asset.Owner = newOwner
  assetJSON, err := json.Marshal(asset)
  if err != nil {
    return err
  }

  return ctx.GetStub().PutState(id, assetJSON)
}
```

最后，让我们编写一个函数，我们将调用该函数，该函数使账本的查询能够 返回账本上的所有资产。

```python
// GetAllAssets returns all assets found in world state
func (s *SmartContract) GetAllAssets(ctx contractapi.TransactionContextInterface) ([]*Asset, error) {
  // range query with empty string for startKey and endKey does an
  // open-ended query of all assets in the chaincode namespace.
  resultsIterator, err := ctx.GetStub().GetStateByRange("", "")
  if err != nil {
    return nil, err
  }
  defer resultsIterator.Close()

  var assets []*Asset
  for resultsIterator.HasNext() {
    queryResponse, err := resultsIterator.Next()
    if err != nil {
      return nil, err
    }

    var asset Asset
    err = json.Unmarshal(queryResponse.Value, &asset)
    if err != nil {
      return nil, err
    }
    assets = append(assets, &asset)
  }

  return assets, nil
}
```

## Pulling it All Together

在上面对实例代码进行详细的解释后，atcc.go文件的链码程序完整源代码如下：

```go
package main

import (
  "encoding/json"
  "fmt"
  "log"

  "github.com/hyperledger/fabric-contract-api-go/contractapi"
)

// SmartContract provides functions for managing an Asset
type SmartContract struct {
  contractapi.Contract
}

// Asset describes basic details of what makes up a simple asset
type Asset struct {
  ID             string `json:"ID"`
  Color          string `json:"color"`
  Size           int    `json:"size"`
  Owner          string `json:"owner"`
  AppraisedValue int    `json:"appraisedValue"`
}

// InitLedger adds a base set of assets to the ledger
func (s *SmartContract) InitLedger(ctx contractapi.TransactionContextInterface) error {
  assets := []Asset{
    {ID: "asset1", Color: "blue", Size: 5, Owner: "Tomoko", AppraisedValue: 300},
    {ID: "asset2", Color: "red", Size: 5, Owner: "Brad", AppraisedValue: 400},
    {ID: "asset3", Color: "green", Size: 10, Owner: "Jin Soo", AppraisedValue: 500},
    {ID: "asset4", Color: "yellow", Size: 10, Owner: "Max", AppraisedValue: 600},
    {ID: "asset5", Color: "black", Size: 15, Owner: "Adriana", AppraisedValue: 700},
    {ID: "asset6", Color: "white", Size: 15, Owner: "Michel", AppraisedValue: 800},
  }

  for _, asset := range assets {
    assetJSON, err := json.Marshal(asset)
    if err != nil {
      return err
    }

    err = ctx.GetStub().PutState(asset.ID, assetJSON)
    if err != nil {
      return fmt.Errorf("failed to put to world state. %v", err)
    }
  }

  return nil
}

// CreateAsset issues a new asset to the world state with given details.
func (s *SmartContract) CreateAsset(ctx contractapi.TransactionContextInterface, id string, color string, size int, owner string, appraisedValue int) error {
  exists, err := s.AssetExists(ctx, id)
  if err != nil {
    return err
  }
  if exists {
    return fmt.Errorf("the asset %s already exists", id)
  }

  asset := Asset{
    ID:             id,
    Color:          color,
    Size:           size,
    Owner:          owner,
    AppraisedValue: appraisedValue,
  }
  assetJSON, err := json.Marshal(asset)
  if err != nil {
    return err
  }

  return ctx.GetStub().PutState(id, assetJSON)
}

// ReadAsset returns the asset stored in the world state with given id.
func (s *SmartContract) ReadAsset(ctx contractapi.TransactionContextInterface, id string) (*Asset, error) {
  assetJSON, err := ctx.GetStub().GetState(id)
  if err != nil {
    return nil, fmt.Errorf("failed to read from world state: %v", err)
  }
  if assetJSON == nil {
    return nil, fmt.Errorf("the asset %s does not exist", id)
  }

  var asset Asset
  err = json.Unmarshal(assetJSON, &asset)
  if err != nil {
    return nil, err
  }

  return &asset, nil
}

// UpdateAsset updates an existing asset in the world state with provided parameters.
func (s *SmartContract) UpdateAsset(ctx contractapi.TransactionContextInterface, id string, color string, size int, owner string, appraisedValue int) error {
  exists, err := s.AssetExists(ctx, id)
  if err != nil {
    return err
  }
  if !exists {
    return fmt.Errorf("the asset %s does not exist", id)
  }

  // overwriting original asset with new asset
  asset := Asset{
    ID:             id,
    Color:          color,
    Size:           size,
    Owner:          owner,
    AppraisedValue: appraisedValue,
  }
  assetJSON, err := json.Marshal(asset)
  if err != nil {
    return err
  }

  return ctx.GetStub().PutState(id, assetJSON)
}

// DeleteAsset deletes an given asset from the world state.
func (s *SmartContract) DeleteAsset(ctx contractapi.TransactionContextInterface, id string) error {
  exists, err := s.AssetExists(ctx, id)
  if err != nil {
    return err
  }
  if !exists {
    return fmt.Errorf("the asset %s does not exist", id)
  }

  return ctx.GetStub().DelState(id)
}

// AssetExists returns true when asset with given ID exists in world state
func (s *SmartContract) AssetExists(ctx contractapi.TransactionContextInterface, id string) (bool, error) {
  assetJSON, err := ctx.GetStub().GetState(id)
  if err != nil {
    return false, fmt.Errorf("failed to read from world state: %v", err)
  }

  return assetJSON != nil, nil
}

// TransferAsset updates the owner field of asset with given id in world state.
func (s *SmartContract) TransferAsset(ctx contractapi.TransactionContextInterface, id string, newOwner string) error {
  asset, err := s.ReadAsset(ctx, id)
  if err != nil {
    return err
  }

  asset.Owner = newOwner
  assetJSON, err := json.Marshal(asset)
  if err != nil {
    return err
  }

  return ctx.GetStub().PutState(id, assetJSON)
}

// GetAllAssets returns all assets found in world state
func (s *SmartContract) GetAllAssets(ctx contractapi.TransactionContextInterface) ([]*Asset, error) {
  // range query with empty string for startKey and endKey does an
  // open-ended query of all assets in the chaincode namespace.
  resultsIterator, err := ctx.GetStub().GetStateByRange("", "")
  if err != nil {
    return nil, err
  }
  defer resultsIterator.Close()

  var assets []*Asset
  for resultsIterator.HasNext() {
    queryResponse, err := resultsIterator.Next()
    if err != nil {
      return nil, err
    }

    var asset Asset
    err = json.Unmarshal(queryResponse.Value, &asset)
    if err != nil {
      return nil, err
    }
    assets = append(assets, &asset)
  }

  return assets, nil
}

func main() {
  assetChaincode, err := contractapi.NewChaincode(&SmartContract{})
  if err != nil {
    log.Panicf("Error creating asset-transfer-basic chaincode: %v", err)
  }

  if err := assetChaincode.Start(); err != nil {
    log.Panicf("Error starting asset-transfer-basic chaincode: %v", err)
  }
}
```

![截屏2023-10-28 13.27.43](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-28 13.27.43.png)

# Chaincode access control

链码可以利用客户端（提交者）证书进行访问 使用 控制决策。此外 结构协定 API 提供提取客户端标识的扩展 API 来自可用于访问控制决策的提交者的证书， 无论是基于客户端身份本身，还是基于组织身份， 或在客户端标识属性上。`ctx.GetStub().GetCreator()`

例如，表示为键/值的资产可能包括 作为值一部分的客户端标识（例如作为 JSON 属性） 表示资产所有者），并且只有此客户才能获得授权 以在将来更新键/值。客户端标识 库扩展 API 可以在链码中用于检索此 提交者信息以做出此类访问控制决策。

# Managing external dependencies for chaincode written in Go（管理链码的外部依赖关系）

Go 链码依赖于不是 Go 包（如链码垫片） 标准库的一部分。这些包的源必须包含在 您的链码包，当它安装到对等节点时。如果您已构建 您的链码作为一个模块，最简单的方法是“供应商”的 在打包链码之前依赖关系。`go mod vendor`

```go
go mod tidy
go mod vendor
```

这会将链码的外部依赖项放入本地目录中

![截屏2023-10-29 10.15.58](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-29 10.15.58.png)

# JSON determinism

能够可预测地处理数据格式至关重要，并且能够搜索区块链中保存的数据。

## 技术问题与解决方案

存储在 Fabric 中的数据格式由用户自行决定。 最低级别的 API 接受一个字节数组并存储该数组 - 这代表什么不是 Fabric 关心的问题。 重要的是在模拟交易时，给定相同的输入链码给出相同的字节数组。 否则，背书可能并不完全匹配，交易将不会提交或无效。

JSON 通常用作在账本上存储数据的数据格式，如果使用 CouchDB 查询，则需要 JSON。

JSON虽然不是一种确定性的数据格式 - 元素的顺序可以改变， 同时仍然在语义上表示相同的数据。因此，挑战在于能够生成一组一致的 JSON。

生成跨多种语言的一致集合。 每种语言都有不同的功能和库，可用于将对象转换为 JSON。 跨不同语言实现确定性的最佳方法是选择一种规范方式作为格式化 JSON 的通用准则。 为了获得跨语言的一致哈希，您可以按字母顺序格式化 JSON。

## Golang

在 Golang 中，该包用于将结构对象序列化为 JSON。 更具体地说，使用函数，后者按排序键顺序封送映射，并按声明字段的顺序保留结构。 由于结构是按字段声明顺序封送的，因此在定义新结构时请遵循字母顺序。`encoding/json Marshal`

## Node.js

在Javascript中，当将对象序列化为JSON时，通常使用该函数。 但是，为了获得一致的结果，需要一个确定性的 JSON.stringify（） 版本;通过这种方式，可以从字符串化的结果中获得一致的哈希。 是一个很好的库，也可以结合使用以达到字母顺序。[此处](https://www.npmjs.com/package/json-stringify-deterministic)获取更深入的教程。`JSON.stringify() json-stringify-deterministic sort-keys-recursive`

## Java

Java 提供了多个库来将对象序列化为 JSON 字符串。但是，并非所有它们都提供一致性和排序。 例如，该库不提供任何一致性，因此应避免用于此应用程序。另一方面 该库非常适合我们的目的，因为它按字母顺序生成一致的 JSON。`Gson Genson`

您可以在[asset-transfer-basic](https://github.com/hyperledger/fabric-samples/tree/main/asset-transfer-basic)链码上找到这种做法的一个很好的例子。

![截屏2023-10-29 22.05.58](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-29 22.05.58.png)



**⚠️注**

这只是我们认为可以有效的众多方法之一。 序列化时，您可以使用各种方法来实现一致性;不过 考虑到Fabric中使用的编程语言的不同特征， 按字母顺序排列的方法代表了解决问题的简单而有效的方法。 总之，如果最适合您的需求，请随意采用不同的方法。 附言如果您使用其他方法，请不要忘记在评论中告诉我们。

# 报错与解决方案

**1.Fatal error when initializing core config**

输入peer chaincode package 时报错：

![截屏2023-10-29 10.20.31](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-29 10.20.31.png)

**解决方案：**根据报错，发现原因是路径的config多打了一个$

使用如下命令进入bashrc文件进行修改即可

```bash
sudo vim ~/.bashrc
```

修改之后，终端输入source .bashrc，报错即可解决。

# 实验心得

本周我通过阅读https://hyperledger-fabric.readthedocs.io/en/latest/chaincode4ade.html#what-is-chaincode)深入学习了Hyperledger Fabric链码编写。这个文档为我揭示了链码的概念、功能、编写步骤以及如何在Hyperledger Fabric网络中部署和执行。通过学习，我不仅对Hyperledger Fabric有了更深入的理解，也从中收获了很多实践经验。

首先，我对链码的概念和功能有了更深入的理解。链码是一种在Hyperledger Fabric网络上执行的业务逻辑，它允许我们实现对区块链数据的读取和写入。这让我明白了链码在Hyperledger Fabric中的重要地位，它就像是一个微型的智能合约，可以让我们在区块链上执行特定的业务逻辑。

在学习过程中，我发现编写链码的步骤并不复杂，主要包括定义输入参数、实现链码函数、测试和验证等步骤。然而，这并不意味着编写链码没有挑战。在编写过程中，我遇到了很多困难和错误。例如，我曾经在定义输入参数时犯过错误，导致链码无法正确执行。通过反复测试和查阅文档，我最终找到了问题所在，并成功修复了错误。

这次学习让我深刻认识到实践的重要性。虽然理论学习是基础，但只有通过实践，才能真正掌握链码编写的技巧和方法。在未来的学习和实践中，我将积极参与社区讨论，与他人分享经验，并继续深入了解Hyperledger Fabric的相关知识。我还会利用所学知识尝试编写自己的链码，以检验自己的学习成果。

此外，我还将注重与其他技术的结合，如物联网、大数据等。我相信通过结合这些技术，我们可以更好地利用Hyperledger Fabric的特性，为各种场景提供更高效、更安全的解决方案。

总之，通过本周的学习，我对Hyperledger Fabric链码编写有了更深入的理解和实践经验。虽然过程中遇到了一些困难和错误，但这也让我更加坚定了学习区块链技术的决心。我相信随着时间的推移和实践的积累，我会成为一名更优秀的区块链开发者。
