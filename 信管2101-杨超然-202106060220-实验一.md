 <img src="/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-08-31 09.48.04.png" alt="截屏2023-08-31 09.48.04" style="zoom:60%;" />

| **报告名称**：   | 实验一：Go语言编程初探 |
| ---------------- | ---------------------- |
| **学生姓名：**   | 杨超然                 |
| **学生学号：**   | 202106060220           |
| **专业班级：**   | 信管2101班             |
| **学**  **院：** | 工商管理学院           |
| **指导老师：**   | 周中定                 |
| **日  期：**     | 2023.9.14              |

------

[TOC]

------

# 实验一：Go语言编程初探

## （一）Go语言环境安装

### 1.MacOS系统

安装包下载地址为：https://go.dev/dl/。

如果打不开可以使用这个地址：https://golang.google.cn/dl/。

各个系统对应的包名：

| 操作系统 | 包名                           |
| :------- | :----------------------------- |
| Windows  | go1.4.windows-amd64.msi        |
| Linux    | go1.4.linux-amd64.tar.gz       |
| Mac      | go1.4.darwin-amd64-osx10.8.pkg |
| FreeBSD  | go1.4.freebsd-amd64.tar.gz     |

*MAC 系统下你可以使用* **.pkg** *结尾的安装包直接双击来完成安装，安装目录在* **/usr/local/go/** *下。*

![截屏2023-09-14 13.15.12](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-14 13.15.12.png)

进入终端，使用go version查看是否成功安装：

![截屏2023-09-14 13.16.03](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-14 13.16.03.png)

### 2.Linux系统

依旧使用Ubuntu22.04，在官网下载符合Linux操作系统的环境：

![截屏2023-09-14 14.50.59](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-14 14.50.59.png)

接下来输入如下代码进行解压与安装：

```shell
$ cd ~
$ mkdir -p ~/go/src ~/go/pkg ~/go/bin
$ wget https://golang.google.cn/dl/go1.21.1.linux-arm64.tar.gz #该步骤为下载压缩包的代码
$ sudo tar -zxvf go1.21.1.linux-arm64.tar.gz -C /usr/local/ 
$ ls /usr/local
```

![截屏2023-09-14 14.55.56](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-14 14.55.56.png)

#### 2.1go全局环境配置

```shell
$ sudo vim /etc/profile
```

配置如下：

```shell
export PATH=$PATH:/usr/local/go/bin
export GOROOT=/usr/local/go
export GOPATH=$HOME/go
export PATH=$PATH:$GOPATH/bin
```

![截屏2023-09-14 14.58.56](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-14 14.58.56.png)

再通过如下命令更新环境变量：

```shell
$ source /etc/profile
```

查看go环境：

```shell
$ go env
```

![截屏2023-09-14 15.01.18](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-14 15.01.18.png)

#### 2.2GO111MODULE设置

Go version >= 1.13，直接用go env -w 设置（注意大小写）

```shell
go env -w GOPROXY=https://goproxy/cn,direct
#go env -w GOPROXY=https://mirrors.aliyun.com/goproxy,direct 
go env -w GO111MODULE=on
```

![截屏2023-09-14 15.04.57](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-14 15.04.57.png)

![截屏2023-09-14 15.03.02](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-14 15.03.02.png)

#### 2.3go mod 命令

go module 使用前置条件: GO111MODULE 设置为 on
·在当前文件夹下初始化一个新的 module，创建 go.mod 文件： go mod init name 
·拉取缺少的模块，移除不用的模块 ： go mod tidy
·将依赖复制到 vendor 下 : go mod vendor 
·下载依赖 : go mod download
·检验依赖: go mod verify 
·显示模块依赖图: go mod graph 
·解释为什么需要依赖: go mod why 
·编辑 go.mod 文件: go eidt
·查看命令列表：go mod

·查看命令帮助文档: go help mod <command>

### 3.配置VSCode

#### 3.1下载或更新VSCode

需要保证你的 vscode 是「最新的」，因为我在配置的时候发现，虽然我安装的 Go 是最新的版本，但是因为 vscode 还是 2020 的版本，导致通过 vscode 安装的相关扩展的版本很低，从而出现了一系列问题。

所以，如果你还没安装 vscode 直接去下载最新的 vscode 即可，网络上有很多教程。

如果你已经有 vscode 了，可以检查一下版本是否是最新版，方法如下：

打开 vscode → 文件 → 首选项 → 设置：
![截屏2023-09-14 13.19.00](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-14 13.19.00.png)

然后在上方搜索栏搜索「更新」，找到「Update: Mode」：

![截屏2023-09-14 13.20.54](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-14 13.20.54.png)

选择 manual，这样软件不会自动更新，但是你可以自己手动检查更新。

然后点击 帮助 → 检查更新，如果软件不是最新版，则会自动下载更新包并完成软件更新：

![截屏2023-09-14 13.21.32](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-14 13.21.32.png)

#### 3.2安装go扩展

先安装go扩展：

![截屏2023-09-14 13.22.46](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-14 13.22.46.png)

更新 Go 工具：
`ctrl + shift + P` 搜索 `Go: Install/Update Tools`：

![截屏2023-09-14 13.26.42](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-14 13.26.42.png)

全部选择好后，点确定后开始安装：

![截屏2023-09-14 13.26.07](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-14 13.26.07.png)

vscode 底部的输出端可以看到安装情况：

![截屏2023-09-14 13.47.23](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-14 13.47.23.png)

![截屏2023-09-14 14.27.49](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-14 14.27.49.png)

### 4.编写go示例程序

在Visual Studio Code中，打开将在其中创建 Go 应用程序的根目录的文件夹。 若要打开文件夹，请单击活动栏中的资源管理器图标，然后单击“ **打开文件夹**”。单击“资源管理器”面板中的“ **新建文件夹** ”，然后为名为 的示例 Go 应用程序创建根控制器 crgo

单击“资源管理器”面板中的“ **新建文件** ”，然后为该文件命名 `main.go`:

![截屏2023-09-14 14.37.31](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-14 14.37.31.png)

打开终端 **“终端 > 新建终端**”，然后运行 命令 `go mod init crgo` 来初始化示例 Go 应用。

![截屏2023-09-14 14.40.07](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-14 14.40.07.png)

将以下代码复制到 文件中 `main.go`：

```go
package main

import "fmt"

func main() {
    name := "Go Developers"
    fmt.Println("Azure for", name)
}
```

在第七行设置断点，并进行调试：

![截屏2023-09-14 14.42.41](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-14 14.42.41.png)

## （二）Go语言结构

在我们开始学习 Go 编程语言的基础构建模块前，让我们先来了解 Go 语言最简单程序的结构。

Go 语言的基础组成有以下几个部分：

- 包声明
- 引入包
- 函数
- 变量
- 语句 & 表达式
- 注释

接下来让我们来看下简单的代码，该代码输出了"Hello World!":

```go
package main

import "fmt"

func main() {
	/*This is my first go code!! */
	fmt.Println("hello world สวัสดีโลก Bonjour le monde こんにちは世界 សួស្តីពិភពលោក")
}
```

1. 第一行代码 *package main* 定义了包名。你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。
2. 下一行 *import "fmt"* 告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），fmt 包实现了格式化 IO（输入/输出）的函数。
3. 下一行 *func main()* 是程序开始执行的函数。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。
4. 下一行 /*...*/ 是注释，在程序执行时将被忽略。单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。 
5. 下一行 *fmt.Println(...)* 可以将字符串输出到控制台，并在最后自动增加换行字符 \n。 
   使用 fmt.Print("hello, world\n") 可以得到相同的结果。 
   Print 和 Println 这两个函数也支持使用变量，如：fmt.Println(arr)。如果没有特别指定，它们会以默认的打印格式将变量 arr 输出到控制台。
6. 当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ）。

运行代码时，只要把代码粘贴到vscode运行即可:

![截屏2023-09-14 15.29.33](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-14 15.29.33.png)

## （三）Go语言基础语法

### 1.Go标记

Go 程序可以由多个标记组成，可以是关键字，标识符，常量，字符串，符号。如以下 GO 语句由 6 个标记组成：

```go
fmt.Println("Hello, World!")
```

6 个标记是(每行一个)：

```
1. fmt
2. .
3. Println
4. (
5. "Hello, World!"
6. )
```

### 2.行分隔符

在 Go 程序中，一行代表一个语句结束。每个语句不需要像 C 家族中的其它语言一样以分号 ; 结尾，因为这些工作都将由 Go 编译器自动完成。

如果你打算将多个语句写在同一行，它们则必须使用 ; 人为区分，但在实际开发中我们并不鼓励这种做法。

以下为两个语句：

```go
fmt.Println("Hello, World!")
fmt.Println("cr is learning go :)")
```

![截屏2023-09-14 15.40.09](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-14 15.40.09.png)

### 3.注释

注释不会被编译，每一个包应该有相关注释。

单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾。如：

```go
// 单行注释
/*
 Author by 菜鸟教程
 我是多行注释
 */
```

![截屏2023-09-14 15.43.18](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-14 15.43.18.png)

### 4.标识符

标识符用来命名变量、类型等程序实体。一个标识符实际上就是一个或是多个字母(A~Z和a~z)数字(0~9)、下划线_组成的序列，但是第一个字符必须是字母或下划线而不能是数字。

以下是有效的标识符：

```
mahesh   kumar   abc   move_name   a_123
myname50   _temp   j   a23b9   retVal
```

以下是无效的标识符：

- 1ab（以数字开头）
- case（Go 语言的关键字）
- a+b（运算符是不允许的

### 5.字符串链接

Go 语言的字符串连接可以通过 **+** 实现：

```go
package main
import "fmt"
func main() {
    fmt.Println("A" + "B")
}
```

输出的结果即为AB:

![截屏2023-09-14 16.28.30](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-14 16.28.30.png)

### 6.关键字

下面列举了 Go 代码中会使用到的 25 个关键字或保留字：

| break    | default     | func   | interface | select |
| -------- | ----------- | ------ | --------- | ------ |
| case     | defer       | go     | map       | struct |
| chan     | else        | goto   | package   | switch |
| const    | fallthrough | if     | range     | type   |
| continue | for         | import | return    | var    |

除了以上介绍的这些关键字，Go 语言还有 36 个预定义标识符：

| append | bool    | byte    | cap     | close  | complex | complex64 | complex128 | uint16  |
| ------ | ------- | ------- | ------- | ------ | ------- | --------- | ---------- | ------- |
| copy   | false   | float32 | float64 | imag   | int     | int8      | int16      | uint32  |
| int32  | int64   | iota    | len     | make   | new     | nil       | panic      | uint64  |
| print  | println | real    | recover | string | true    | uint      | uint8      | uintptr |

程序一般由关键字、常量、变量、运算符、类型和函数组成。

程序中可能会使用到这些分隔符：括号 ()，中括号 [] 和大括号 {}。

程序中可能会使用到这些标点符号：**.**、**,**、**;**、**:** 和 **…**。

### 7.空格

在 Go 语言中，空格通常用于分隔标识符、关键字、运算符和表达式，以提高代码的可读性。

Go 语言中变量的声明必须使用空格隔开，如：

```go
var x int
const Pi float64 = 3.14159265358979323846
```

在变量与运算符间加入空格，程序看起来更加美观，如：

```go
fruit = apples + oranges; 
```

在关键字和表达式之间要使用空格，例如：

```go
if x > 0 {
    // do something
}
```

在函数调用时，函数名和左边等号之间要使用空格，参数之间也要使用空格,例如：

```go
result := add(2, 3)
```

### 8.格式化字符串

Go 语言中使用 **fmt.Sprintf** 或 **fmt.Printf** 格式化字符串并赋值给新串：

- **Sprintf** 根据格式化参数生成格式化的字符串并返回该字符串。
- **Printf** 根据格式化参数生成格式化的字符串并写入标准输出。

Sprintf实例：

```go
package main

import "fmt"

func main() {
	/*%d 表示整形数字 %s 表示字符串 */
	var stockcode = 123
	var enddate = "2023.9.14"
	var url = "code=%d&enddate=%s"
	var target_url = fmt.Sprintf(url, stockcode, enddate)
	fmt.Println(target_url)
}
```

![截屏2023-09-14 16.45.38](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-14 16.45.38.png)

Printf实例：

```go
package main

import (
    "fmt"
)

func main() {
   // %d 表示整型数字，%s 表示字符串
    var stockcode=123
    var enddate="2020-12-31"
    var url="Code=%d&endDate=%s"
    fmt.Printf(url,stockcode,enddate)
}
```

![截屏2023-09-14 16.48.36](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-14 16.48.36.png)

## （四）Go语言数据类型

在 Go 编程语言中，数据类型用于声明函数和变量。

数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。

Go 语言按类别有以下几种数据类型：

| 序号 | 类型和描述                                                   |
| :--- | :----------------------------------------------------------- |
| 1    | **布尔型** 布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。 |
| 2    | **数字类型** 整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。 |
| 3    | **字符串类型:** 字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。 |
| 4    | **派生类型:** 包括：(a) 指针类型（Pointer）(b) 数组类型(c) 结构化类型(struct)(d) Channel 类型(e) 函数类型 (f) 切片类型 (g) 接口类型（interface）(h) Map 类型 |

### 1.数字类型

Go 也有基于架构的类型，例如：int、uint 和 uintptr。

| 序号 | 类型和描述                                                   |
| :--- | :----------------------------------------------------------- |
| 1    | **uint8** 无符号 8 位整型 (0 到 255)                         |
| 2    | **uint16** 无符号 16 位整型 (0 到 65535)                     |
| 3    | **uint32** 无符号 32 位整型 (0 到 4294967295)                |
| 4    | **uint64** 无符号 64 位整型 (0 到 18446744073709551615)      |
| 5    | **int8** 有符号 8 位整型 (-128 到 127)                       |
| 6    | **int16** 有符号 16 位整型 (-32768 到 32767)                 |
| 7    | **int32** 有符号 32 位整型 (-2147483648 到 2147483647)       |
| 8    | **int64** 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) |

### 2.浮点类型

| 序号 | 类型和描述                        |
| :--- | :-------------------------------- |
| 1    | **float32** IEEE-754 32位浮点型数 |
| 2    | **float64** IEEE-754 64位浮点型数 |
| 3    | **complex64** 32 位实数和虚数     |
| 4    | **complex128** 64 位实数和虚数    |

### 3.其他数字类型

以下列出了其他更多的数字类型：

| 序号 | 类型和描述                               |
| :--- | :--------------------------------------- |
| 1    | **byte** 类似 uint8                      |
| 2    | **rune** 类似 int32                      |
| 3    | **uint** 32 或 64 位                     |
| 4    | **int** 与 uint 一样大小                 |
| 5    | **uintptr** 无符号整型，用于存放一个指针 |

## （五）Go语言变量

### 1.变量定义

变量来源于数学，是计算机语言中能储存计算结果或能表示值抽象概念。

变量可以通过变量名访问。

Go 语言变量名由字母、数字、下划线组成，其中首个字符不能为数字。

声明变量的一般形式是使用 var 关键字，并在变量名后标明变量的类别：

```go
var identifier type
```

可以一次性申明多个变量：

```go
var identifier1, identifier2 type
```

实例如下：

```go
package main
import "fmt"
func main() {
    var a string = "cr"
    fmt.Println(a)

var b, c int = 1, 2
fmt.Println(b, c)

}
```

![截屏2023-09-14 16.57.27](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-14 16.57.27.png)

### 2.变量声明

**第一种，指定变量类型，如果没有初始化，则变量默认为零值。**

实例如下：

```go
package main
import "fmt"
func main() {

    // 声明一个变量并初始化
    var a = "crrr"
    fmt.Println(a)
    
    // 没有初始化就为零值
    var b int
    fmt.Println(b)
    
    // bool 零值为 false
    var c bool
    fmt.Println(c)

}
```

![截屏2023-09-14 17.00.33](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-14 17.00.33.png)

注：没有进行初始化时

- 数值类型（包括complex64/128）为 **0**
- 布尔类型为 **false**
- 字符串为 **""**（空字符串）
- 以下几种类型为 **nil**：

```go
var a *int
var a []int
var a map[string] int
var a chan int
var a func(string) int
var a error // error 是接口
```

实例如下：

```go
package main

import "fmt"

func main() {
    var i int
    var f float64
    var b bool
    var s string
    fmt.Printf("%v %v %v %q\n", i, f, b, s)
}
```

![截屏2023-09-14 17.02.30](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-14 17.02.30.png)

**第二种，根据值自行判定变量类型。**例如如下实例的输出结果即为True：

```go
package main
import "fmt"
func main() {
    var d = true
    fmt.Println(d)
}
```

**第三种，如果变量已经使用 var 声明过了，再使用 \**:=\** 声明变量，就产生编译错误，格式：**

```go
v_name := value
```

例如：

```go
var intVal int 
intVal :=1 // 这时候会产生编译错误，因为 intVal 已经声明，不需要重新声明
```

因此为了避免这种编译错误，我们只需要直接使用如下语句即可：

```go
intVal := 1 // 此时不会产生编译错误，因为有声明新的变量，因为 := 是一个声明语句
```

可以将 var f string = "Cr" 简写为 f := "Cr"：

```go
package main
import "fmt"
func main() {
    f := "Cr" // var f string = "Cr"

    fmt.Println(f)

}
```

![截屏2023-09-14 17.09.11](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-14 17.09.11.png)

### 3.多变量声明

直接通过一个实例理解多变量声明的格式：

```go
package main
import "fmt"

var x, y int
var (  // 这种因式分解关键字的写法一般用于声明全局变量
    a int
    b bool
)

var c, d int = 1, 2
var e, f = 123, "hello"

//这种不带声明格式的只能在函数体中出现
//g, h := 123, "hello"

func main(){
    g, h := 123, "hello"
    fmt.Println(x, y, a, b, c, d, e, f, g, h)
}
```

![截屏2023-09-14 17.10.57](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-14 17.10.57.png)

### 4.值类型和引用类型

所有像 int、float、bool 和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值：

![截屏2023-09-14 17.12.09](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-14 17.12.09.png)

当使用等号 `=` 将一个变量的值赋值给另一个变量时，如：`j = i`，实际上是在内存中将 i 的值进行了拷贝：

![截屏2023-09-14 17.12.36](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-14 17.12.36.png)

你可以通过 &i 来获取变量 i 的内存地址，例如：0xf840000040（每次的地址都可能不一样）。

值类型变量的值存储在堆中。

内存地址会根据机器的不同而有所不同，甚至相同的程序在不同的机器上执行后也会有不同的内存地址。因为每台机器可能有不同的存储器布局，并且位置分配也可能不同。

更复杂的数据通常会需要使用多个字，这些数据一般使用引用类型保存。

一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置。

![截屏2023-09-14 17.12.54](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-14 17.12.54.png)

这个内存地址称之为指针，这个指针实际上也被存在另外的某一个值中。

同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。

当使用赋值语句 r2 = r1 时，只有引用（地址）被复制。

如果 r1 的值被改变了，那么这个值的所有引用都会指向被修改后的内容，在这个例子中，r2 也会受到影响。

### 5.简短形式，使用 := 赋值操作符

我们知道可以在变量的初始化时省略变量的类型而由系统自动推断，声明语句写上 var 关键字其实是显得有些多余了，因此我们可以将它们简写为 a := 50 或 b := false。

a 和 b 的类型（int 和 bool）将由编译器自动推断。

这是使用变量的首选形式，但是它只能被用在函数体内，而不可以用于全局变量的声明与赋值。使用操作符 := 可以高效地创建一个新的变量，称之为初始化声明。

注意事项：

如果在相同的代码块中，我们不可以再次对于相同名称的变量使用初始化声明，例如：a := 20 就是不被允许的，编译器会提示错误 no new variables on left side of :=，但是 a = 20 是可以的，因为这是给相同的变量赋予一个新的值。

如果你在定义变量 a 之前使用它，则会得到编译错误 undefined: a。

如果你声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误，例如下面这个例子当中的变量 a：

```go
package main

import "fmt"

func main() {
   var a string = "abc"
   fmt.Println("hello, world")
}
```

尝试编译这段代码将得到错误 **a declared but not used**。

此外，单纯地给 a 赋值也是不够的，这个值必须被使用，所以使用

```go
fmt.Println("hello, world", a)
```

会移除错误。但是全局变量是允许声明但不使用的。 同一类型的多个变量可以声明在同一行，如：

```go
var a, b, c int
```

多变量可以在同一行进行赋值，如：

```go
var a, b int
var c string
a, b, c = 5, 7, "abc"
```

上面这行假设了变量 a，b 和 c 都已经被声明，否则的话应该这样使用：

```go
a, b, c := 5, 7, "abc"
```

右边的这些值以相同的顺序赋值给左边的变量，所以 a 的值是 5， b 的值是 7，c 的值是 "abc"。

这被称为 并行 或 同时 赋值。

如果你想要交换两个变量的值，则可以简单地使用 **a, b = b, a**，两个变量的类型必须是相同。

空白标识符 _ 也被用于抛弃值，如值 5 在：_, b = 5, 7 中被抛弃。

_ 实际上是一个只写变量，你不能得到它的值。这样做是因为 Go 语言中你必须使用所有被声明的变量，但有时你并不需要使用从一个函数得到的所有返回值。

并行赋值也被用于当一个函数返回多个返回值时，比如这里的 val 和错误 err 是通过调用 Func1 函数同时得到：val, err = Func1(var1)。

## （六）Go语言常量

### 1.常量的定义

常量是一个简单值的标识符，在程序运行时，不会被修改的量。

常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。

```go
const identifier [type] = value
```

其中，[type]在定义时可以省略，因为编译器可以自动识别

- 显式类型定义： `const b string = "abc"`
- 隐式类型定义： `const b = "abc"`

多个相同类型变量的声明可简写为：

```go
const c_name1, c_name2 = value1, value2
```

实例如下：

```go
package main

import "fmt"

func main() {
   const LENGTH int = 10
   const WIDTH int = 5   
   var area int
   const a, b, c = 1, false, "str" //多重赋值

   area = LENGTH * WIDTH
   fmt.Printf("面积为 : %d", area)
   println()
   println(a, b, c)   
}
```

![截屏2023-09-15 16.42.55](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-15 16.42.55.png)

常量还可以用作枚举：

```go
const (
    Unknown = 0
    Female = 1
    Male = 2
)
```

数字 0、1 和 2 分别代表未知性别、女性和男性。

常量可以用len(), cap(), unsafe.Sizeof()函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过：

```go
package main

import "unsafe"
const (
    a = "abc"
    b = len(a)
    c = unsafe.Sizeof(a)
)

func main(){
    println(a, b, c)
}
```

![截屏2023-09-15 16.45.33](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-15 16.45.33.png)

### 2.iota

iota，特殊常量，可以认为是一个可以被编译器修改的常量。

iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。

iota 可以被用作枚举值：

```go
const (
    a = iota
    b = iota
    c = iota
)
```

第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a=0, b=1, c=2 可以简写为如下形式：

```go
const (
    a = iota
    b
    c
)
```

实例如下：

```go
package main

import "fmt"

func main() {
    const (
            a = iota   //0
            b          //1
            c          //2
            d = "ha"   //独立值，iota += 1
            e          //"ha"   iota += 1
            f = 100    //iota +=1
            g          //100  iota +=1
            h = iota   //7,恢复计数
            i          //8
    )
    fmt.Println(a,b,c,d,e,f,g,h,i)
}
```

![截屏2023-09-15 16.51.27](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-15 16.51.27.png)

```go
package main

import "fmt"
const (
    i=1<<iota
    j=3<<iota
    k
    l
)

func main() {
    fmt.Println("i=",i)
    fmt.Println("j=",j)
    fmt.Println("k=",k)
    fmt.Println("l=",l)
}
```

![截屏2023-09-15 16.52.28](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-15 16.52.28.png)

iota 表示从 0 开始自动加 1，所以 **i=1<<0**, **j=3<<1**（**<<** 表示左移的意思），即：i=1, j=6，这没问题，关键在 k 和 l，从输出结果看 **k=3<<2**，**l=3<<3**。

简单表述:

- **i=1**：左移 0 位，不变仍为 1。
- **j=3**：左移 1 位，变为二进制 **110**，即 6。
- **k=3**：左移 2 位，变为二进制 **1100**，即 12。
- **l=3**：左移 3 位，变为二进制 **11000**，即 24。

注：**<<n==\*(2^n)**。

## （七）Go语言运算符

运算符用于在程序运行时执行数学或逻辑运算。

Go 语言内置的运算符有：

- 算术运算符
- 关系运算符
- 逻辑运算符
- 位运算符
- 赋值运算符
- 其他运算符

### 1.算术运算符

下表列出了所有Go语言的算术运算符。假定 A 值为 10，B 值为 20。

| 运算符 | 描述 | 实例               |
| :----- | :--- | :----------------- |
| +      | 相加 | A + B 输出结果 30  |
| -      | 相减 | A - B 输出结果 -10 |
| *      | 相乘 | A * B 输出结果 200 |
| /      | 相除 | B / A 输出结果 2   |
| %      | 求余 | B % A 输出结果 0   |
| ++     | 自增 | A++ 输出结果 11    |
| --     | 自减 | A-- 输出结果 9     |

实例如下：

```go
package main

import "fmt"

func main() {

   var a int = 21
   var b int = 10
   var c int

   c = a + b
   fmt.Printf("第一行 - c 的值为 %d\n", c )
   c = a - b
   fmt.Printf("第二行 - c 的值为 %d\n", c )
   c = a * b
   fmt.Printf("第三行 - c 的值为 %d\n", c )
   c = a / b
   fmt.Printf("第四行 - c 的值为 %d\n", c )
   c = a % b
   fmt.Printf("第五行 - c 的值为 %d\n", c )
   a++
   fmt.Printf("第六行 - a 的值为 %d\n", a )
   a=21   // 为了方便测试，a 这里重新赋值为 21
   a--
   fmt.Printf("第七行 - a 的值为 %d\n", a )
}
```

![截屏2023-09-15 17.03.44](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-15 17.03.44.png)

### 2.关系运算符

下表列出了所有Go语言的关系运算符。假定 A 值为 10，B 值为 20。

| 运算符 | 描述                                                         | 实例              |
| :----- | :----------------------------------------------------------- | :---------------- |
| ==     | 检查两个值是否相等，如果相等返回 True 否则返回 False。       | (A == B) 为 False |
| !=     | 检查两个值是否不相等，如果不相等返回 True 否则返回 False。   | (A != B) 为 True  |
| >      | 检查左边值是否大于右边值，如果是返回 True 否则返回 False。   | (A > B) 为 False  |
| <      | 检查左边值是否小于右边值，如果是返回 True 否则返回 False。   | (A < B) 为 True   |
| >=     | 检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。 | (A >= B) 为 False |
| <=     | 检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。 | (A <= B) 为 True  |

实例如下：

```go
package main

import "fmt"

func main() {
   var a int = 21
   var b int = 10

   if( a == b ) {
      fmt.Printf("第一行 - a 等于 b\n" )
   } else {
      fmt.Printf("第一行 - a 不等于 b\n" )
   }
   if ( a < b ) {
      fmt.Printf("第二行 - a 小于 b\n" )
   } else {
      fmt.Printf("第二行 - a 不小于 b\n" )
   } 

   if ( a > b ) {
      fmt.Printf("第三行 - a 大于 b\n" )
   } else {
      fmt.Printf("第三行 - a 不大于 b\n" )
   }
   /* Lets change value of a and b */
   a = 5
   b = 20
   if ( a <= b ) {
      fmt.Printf("第四行 - a 小于等于 b\n" )
   }
   if ( b >= a ) {
      fmt.Printf("第五行 - b 大于等于 a\n" )
   }
}


```

![截屏2023-09-15 17.11.05](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-15 17.11.05.png)

### 3.逻辑运算符

下表列出了所有Go语言的逻辑运算符。假定 A 值为 True，B 值为 False。

| 运算符 | 描述                                                         | 实例               |
| :----- | :----------------------------------------------------------- | :----------------- |
| &&     | 逻辑 AND 运算符。 如果两边的操作数都是 True，则条件 True，否则为 False。 | (A && B) 为 False  |
| \|\|   | 逻辑 OR 运算符。 如果两边的操作数有一个 True，则条件 True，否则为 False。 | (A \|\| B) 为 True |
| !      | 逻辑 NOT 运算符。 如果条件为 True，则逻辑 NOT 条件 False，否则为 True。 | !(A && B) 为 True  |

实例如下：

```go
package main

import "fmt"

func main() {
   var a bool = true
   var b bool = false
   if ( a && b ) {
      fmt.Printf("第一行 - 条件为 true\n" )
   }
   if ( a || b ) {
      fmt.Printf("第二行 - 条件为 true\n" )
   }
   /* 修改 a 和 b 的值 */
   a = false
   b = true
   if ( a && b ) {
      fmt.Printf("第三行 - 条件为 true\n" )
   } else {
      fmt.Printf("第三行 - 条件为 false\n" )
   }
   if ( !(a && b) ) {
      fmt.Printf("第四行 - 条件为 true\n" )
   }
}
```

![截屏2023-09-15 17.22.22](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-15 17.22.22.png)

### 4.位运算符

位运算符对整数在内存中的二进制位进行操作。

下表列出了位运算符 &, |, 和 ^ 的计算：

| p    | q    | p & q | p \| q | p ^ q |
| :--- | :--- | :---- | :----- | :---- |
| 0    | 0    | 0     | 0      | 0     |
| 0    | 1    | 0     | 1      | 1     |
| 1    | 1    | 1     | 1      | 0     |
| 1    | 0    | 0     | 1      | 1     |

假定 A = 60; B = 13; 其二进制数转换为：

```go
A = 0011 1100

B = 0000 1101

-----------------

A&B = 0000 1100

A|B = 0011 1101

A^B = 0011 0001
```

Go 语言支持的位运算符如下表所示。假定 A 为60，B 为13：

| 运算符 | 描述                                                         | 实例                                   |
| :----- | :----------------------------------------------------------- | :------------------------------------- |
| &      | 按位与运算符"&"是双目运算符。 其功能是参与运算的两数各对应的二进位相与。 | (A & B) 结果为 12, 二进制为 0000 1100  |
| \|     | 按位或运算符"\|"是双目运算符。 其功能是参与运算的两数各对应的二进位相或 | (A \| B) 结果为 61, 二进制为 0011 1101 |
| ^      | 按位异或运算符"^"是双目运算符。 其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 | (A ^ B) 结果为 49, 二进制为 0011 0001  |
| <<     | 左移运算符"<<"是双目运算符。左移n位就是乘以2的n次方。 其功能把"<<"左边的运算数的各二进位全部左移若干位，由"<<"右边的数指定移动的位数，高位丢弃，低位补0。 | A << 2 结果为 240 ，二进制为 1111 0000 |
| >>     | 右移运算符">>"是双目运算符。右移n位就是除以2的n次方。 其功能是把">>"左边的运算数的各二进位全部右移若干位，">>"右边的数指定移动的位数。 | A >> 2 结果为 15 ，二进制为 0000 1111  |

实例如下：

```go
package main

import "fmt"

func main() {

   var a uint = 60      /* 60 = 0011 1100 */  
   var b uint = 13      /* 13 = 0000 1101 */
   var c uint = 0          

   c = a & b       /* 12 = 0000 1100 */ 
   fmt.Printf("第一行 - c 的值为 %d\n", c )

   c = a | b       /* 61 = 0011 1101 */
   fmt.Printf("第二行 - c 的值为 %d\n", c )

   c = a ^ b       /* 49 = 0011 0001 */
   fmt.Printf("第三行 - c 的值为 %d\n", c )

   c = a << 2     /* 240 = 1111 0000 */
   fmt.Printf("第四行 - c 的值为 %d\n", c )

   c = a >> 2     /* 15 = 0000 1111 */
   fmt.Printf("第五行 - c 的值为 %d\n", c )
}
```

![截屏2023-09-15 17.30.19](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-15 17.30.19.png)

### 5.赋值运算符

| 运算符 | 描述                                           | 实例                                  |
| :----- | :--------------------------------------------- | :------------------------------------ |
| =      | 简单的赋值运算符，将一个表达式的值赋给一个左值 | C = A + B 将 A + B 表达式结果赋值给 C |
| +=     | 相加后再赋值                                   | C += A 等于 C = C + A                 |
| -=     | 相减后再赋值                                   | C -= A 等于 C = C - A                 |
| *=     | 相乘后再赋值                                   | C *= A 等于 C = C * A                 |
| /=     | 相除后再赋值                                   | C /= A 等于 C = C / A                 |
| %=     | 求余后再赋值                                   | C %= A 等于 C = C % A                 |
| <<=    | 左移后赋值                                     | C <<= 2 等于 C = C << 2               |
| >>=    | 右移后赋值                                     | C >>= 2 等于 C = C >> 2               |
| &=     | 按位与后赋值                                   | C &= 2 等于 C = C & 2                 |
| ^=     | 按位异或后赋值                                 | C ^= 2 等于 C = C ^ 2                 |
| \|=    | 按位或后赋值                                   | C \|= 2 等于 C = C \| 2               |

实例如下：

```go
package main

import "fmt"

func main() {
   var a int = 21
   var c int

   c =  a
   fmt.Printf("第 1 行 - =  运算符实例，c 值为 = %d\n", c )

   c +=  a
   fmt.Printf("第 2 行 - += 运算符实例，c 值为 = %d\n", c )

   c -=  a
   fmt.Printf("第 3 行 - -= 运算符实例，c 值为 = %d\n", c )

   c *=  a
   fmt.Printf("第 4 行 - *= 运算符实例，c 值为 = %d\n", c )

   c /=  a
   fmt.Printf("第 5 行 - /= 运算符实例，c 值为 = %d\n", c )

   c  = 200; 

   c <<=  2
   fmt.Printf("第 6行  - <<= 运算符实例，c 值为 = %d\n", c )

   c >>=  2
   fmt.Printf("第 7 行 - >>= 运算符实例，c 值为 = %d\n", c )

   c &=  2
   fmt.Printf("第 8 行 - &= 运算符实例，c 值为 = %d\n", c )

   c ^=  2
   fmt.Printf("第 9 行 - ^= 运算符实例，c 值为 = %d\n", c )

   c |=  2
   fmt.Printf("第 10 行 - |= 运算符实例，c 值为 = %d\n", c )

}
```

![截屏2023-09-15 17.35.48](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-15 17.35.48.png)

### 6.其他运算符

下表列出了Go语言的其他运算符。

| 运算符 | 描述             | 实例                       |
| :----- | :--------------- | :------------------------- |
| &      | 返回变量存储地址 | &a; 将给出变量的实际地址。 |
| *      | 指针变量。       | *a; 是一个指针变量         |

相关实例如下：

```go
package main

import "fmt"

func main() {
   var a int = 4
   var b int32
   var c float32
   var ptr *int

   /* 运算符实例 */
   fmt.Printf("第 1 行 - a 变量类型为 = %T\n", a );
   fmt.Printf("第 2 行 - b 变量类型为 = %T\n", b );
   fmt.Printf("第 3 行 - c 变量类型为 = %T\n", c );

   /*  & 和 * 运算符实例 */
   ptr = &a     /* 'ptr' 包含了 'a' 变量的地址 */
   fmt.Printf("a 的值为  %d\n", a);
   fmt.Printf("*ptr 为 %d\n", *ptr);
}
```

![截屏2023-09-15 17.38.05](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-15 17.38.05.png)

### 7.运算符优先级

有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低：

| 优先级 | 运算符           |
| :----- | :--------------- |
| 5      | * / % << >> & &^ |
| 4      | + - \| ^         |
| 3      | == != < <= > >=  |
| 2      | &&               |
| 1      | \|\|             |

当然，也可以通过使用括号来临时提升某个表达式的整体运算优先级。实例如下：

```go
package main

import "fmt"

func main() {
   var a int = 20
   var b int = 10
   var c int = 15
   var d int = 5
   var e int;

   e = (a + b) * c / d;      // ( 30 * 15 ) / 5
   fmt.Printf("(a + b) * c / d 的值为 : %d\n",  e );

   e = ((a + b) * c) / d;    // (30 * 15 ) / 5
   fmt.Printf("((a + b) * c) / d 的值为  : %d\n" ,  e );

   e = (a + b) * (c / d);   // (30) * (15/5)
   fmt.Printf("(a + b) * (c / d) 的值为  : %d\n",  e );

   e = a + (b * c) / d;     //  20 + (150/5)
   fmt.Printf("a + (b * c) / d 的值为  : %d\n" ,  e );  
}
```

![截屏2023-09-15 17.39.49](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-15 17.39.49.png)

## （八）Go语言条件语句

条件语句需要开发者通过指定一个或多个条件，并通过测试条件是否为 true 来决定是否执行指定语句，并在条件为 false 的情况在执行另外的语句。

Go 语言提供了以下几种条件判断语句：

| 语句                                                         | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [if 语句](https://www.runoob.com/go/go-if-statement.html)    | **if 语句** 由一个布尔表达式后紧跟一个或多个语句组成。       |
| [if...else 语句](https://www.runoob.com/go/go-if-else-statement.html) | **if 语句** 后可以使用可选的 **else 语句**, else 语句中的表达式在布尔表达式为 false 时执行。 |
| [if 嵌套语句](https://www.runoob.com/go/go-nested-if-statements.html) | 你可以在 **if** 或 **else if** 语句中嵌入一个或多个 **if** 或 **else if** 语句。 |
| [switch 语句](https://www.runoob.com/go/go-switch-statement.html) | **switch** 语句用于基于不同条件执行不同动作。                |
| [select 语句](https://www.runoob.com/go/go-select-statement.html) | **select** 语句类似于 **switch** 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。 |

### 1.if语句

实例如下：

```go
package main

import "fmt"

func main() {
   /* 定义局部变量 */
   var a int = 10

   /* 使用 if 语句判断布尔表达式 */
   if a < 20 {
       /* 如果条件为 true 则执行以下语句 */
       fmt.Printf("a 小于 20\n" )
   }
   fmt.Printf("a 的值为 : %d\n", a)
}
```

![截屏2023-09-15 21.26.43](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-15 21.26.43.png)

### 2.if...else语句

下例使用了一个if...else语句来判断一个数的大小：

```go
package main

import "fmt"

func main() {
   /* 局部变量定义 */
   var a int = 100;

   /* 判断布尔表达式 */
   if a < 20 {
       /* 如果条件为 true 则执行以下语句 */
       fmt.Printf("a 小于 20\n" );
   } else {
       /* 如果条件为 false 则执行以下语句 */
       fmt.Printf("a 不小于 20\n" );
   }
   fmt.Printf("a 的值为 : %d\n", a);

}
```

![截屏2023-09-15 21.46.58](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-15 21.46.58.png)

### 3.if嵌套语句

即在if和if..else中再嵌入一个或多个 if 或 else if 语句。实例如下：

```go
package main

import "fmt"

func main() {
   /* 定义局部变量 */
   var a int = 100
   var b int = 200

   /* 判断条件 */
   if a == 100 {
       /* if 条件语句为 true 执行 */
       if b == 200 {
          /* if 条件语句为 true 执行 */
          fmt.Printf("a 的值为 100 ， b 的值为 200\n" );
       }
   }
   fmt.Printf("a 值为 : %d\n", a );
   fmt.Printf("b 值为 : %d\n", b );
}
```

![截屏2023-09-15 22.24.57](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-15 22.24.57.png)

### 4.switch语句

switch 语句用于基于不同条件执行不同动作，每一个 case 分支都是唯一的，从上至下逐一测试，直到匹配为止。

switch 语句执行的过程从上至下，直到找到匹配项，匹配项后面也不需要再加 break。

switch 默认情况下 case 最后自带 break 语句，匹配成功后就不会执行其他 case，如果我们需要执行后面的 case，可以使用 **fallthrough** 。

实例如下：

```go
package main

import "fmt"

func main() {
   /* 定义局部变量 */
   var grade string = "B"
   var marks int = 90

   switch marks {
      case 90: grade = "A"
      case 80: grade = "B"
      case 50,60,70 : grade = "C"
      default: grade = "D"  
   }

   switch {
      case grade == "A" :
         fmt.Printf("优秀!\n" )     
      case grade == "B", grade == "C" :
         fmt.Printf("良好\n" )      
      case grade == "D" :
         fmt.Printf("及格\n" )      
      case grade == "F":
         fmt.Printf("不及格\n" )
      default:
         fmt.Printf("差\n" );
   }
   fmt.Printf("你的等级是 %s\n", grade );      
}
```

![截屏2023-09-15 22.28.54](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-15 22.28.54.png)

#### 4.1Type Switch

switch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型。实例如下：

```go
package main

import "fmt"

func main() {
   var x interface{}
     
   switch i := x.(type) {
      case nil:   
         fmt.Printf(" x 的类型 :%T",i)                
      case int:   
         fmt.Printf("x 是 int 型")                       
      case float64:
         fmt.Printf("x 是 float64 型")           
      case func(int) float64:
         fmt.Printf("x 是 func(int) 型")                      
      case bool, string:
         fmt.Printf("x 是 bool 或 string 型" )       
      default:
         fmt.Printf("未知型")     
   }   
}
```

![截屏2023-09-15 22.30.59](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-15 22.30.59.png)

#### 4.2fallthrough

使用 fallthrough 会强制执行后面的 case 语句，fallthrough 不会判断下一条 case 的表达式结果是否为 true。实例如下：

```go
package main

import "fmt"

func main() {

    switch {
    case false:
            fmt.Println("1、case 条件语句为 false")
            fallthrough
    case true:
            fmt.Println("2、case 条件语句为 true")
            fallthrough
    case false:
            fmt.Println("3、case 条件语句为 false")
            fallthrough
    case true:
            fmt.Println("4、case 条件语句为 true")
    case false:
            fmt.Println("5、case 条件语句为 false")
            fallthrough
    default:
            fmt.Println("6、默认 case")
    }

}
```

![截屏2023-09-15 22.33.14](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-15 22.33.14.png)

从以上代码输出的结果可以看出：switch 从第一个判断表达式为 true 的 case 开始执行，如果 case 带有 fallthrough，程序会继续执行下一条 case，且它不会去判断下一个 case 的表达式是否为 true。

### 5.select语句

select 是 Go 中的一个控制结构，类似于 switch 语句。

select 语句只能用于通道操作，每个 case 必须是一个通道操作，要么是发送要么是接收。

select 语句会监听所有指定的通道上的操作，一旦其中一个通道准备好就会执行相应的代码块。

如果多个通道都准备好，那么 select 语句会随机选择一个通道执行。如果所有通道都没有准备好，那么执行 default 块中的代码。

实例如下：

```go
package main

import (
    "fmt"
    "time"
)

func main() {

    c1 := make(chan string)
    c2 := make(chan string)
    
    go func() {
        time.Sleep(1 * time.Second)
        c1 <- "one"
    }()
    go func() {
        time.Sleep(2 * time.Second)
        c2 <- "two"
    }()
    
    for i := 0; i < 2; i++ {
        select {
        case msg1 := <-c1:
            fmt.Println("received", msg1)
        case msg2 := <-c2:
            fmt.Println("received", msg2)
        }
    }

}
```

![截屏2023-09-15 22.37.07](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-15 22.37.07.png)

以上实例中，我们创建了两个通道 c1 和 c2。

select 语句等待两个通道的数据。如果接收到 c1 的数据，就会打印 "received one"；如果接收到 c2 的数据，就会打印 "received two"。

## （九）Go语言循环语句

### 1.循环处理语句

在不少实际问题中有许多具有规律性的重复操作，因此在程序中就需要重复执行某些语句。

Go 语言提供了以下几种类型循环处理语句：

| 循环类型                                                   | 描述                                 |
| :--------------------------------------------------------- | :----------------------------------- |
| [for 循环](https://www.runoob.com/go/go-for-loop.html)     | 重复执行语句块                       |
| [循环嵌套](https://www.runoob.com/go/go-nested-loops.html) | 在 for 循环中嵌套一个或多个 for 循环 |

#### 1.1for循环

for 循环是一个循环控制结构，可以执行指定次数的循环。其语法流程为：给定一个初始值进行条件判断，当条件为true时，执行代码块实现递增，当条件判断为false时，退出循环。

实例如下（计算1到10的数字之和）：

```go
package main

import "fmt"

func main() {
   sum := 0
      for i := 0; i <= 10; i++ {
         sum += i
      }
   fmt.Println(sum)
}
```

![截屏2023-09-16 08.20.06](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-16 08.20.06.png)

init 和 post 参数是可选的，我们可以直接省略它，类似 While 语句。

以下实例在 sum 小于 10 的时候计算 sum 自相加后的值：

```go
package main

import "fmt"

func main() {
   sum := 1
   for ; sum <= 10; {
      sum += sum
   }
   fmt.Println(sum)

   // 这样写也可以，更像 While 语句形式
   for sum <= 10{
      sum += sum
   }
   fmt.Println(sum)
}
```

![截屏2023-09-16 08.21.10](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-16 08.21.10.png)

此外，for- each range循环格式可以可以对字符串、数组、切片等进行迭代输出元素。实例如下（for 循环的 range 格式可以省略 key 和 value）：

```go
package main
import "fmt"

func main() {
   strings := []string{"google", "runoob"}
   for i, s := range strings {
      fmt.Println(i, s)
   }

   numbers := [6]int{1, 2, 3, 5} 
   for i,x:= range numbers {
      fmt.Printf("第 %d 位 x 的值 = %d\n", i,x)
   }  
}
```

![截屏2023-09-16 08.25.36](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-16 08.25.36.png)

#### 1.2循环嵌套

循环嵌套，即在循环内使用循环。以下实例使用循环嵌套来输出 2 到 100 间的素数：

```go
package main

import "fmt"

func main() {
   /* 定义局部变量 */
   var i, j int

   for i=2; i < 100; i++ {
      for j=2; j <= (i/j); j++ {
         if(i%j==0) {
            break; // 如果发现因子，则不是素数
         }
      }
      if(j > (i/j)) {
         fmt.Printf("%d  是素数\n", i);
      }
   }  
}
```

![截屏2023-09-16 08.32.51](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-16 08.32.51.png)

### 2.循环控制语句

循环控制语句可以控制循环体内语句的执行过程。

GO 语言支持以下几种循环控制语句：

| 控制语句                                                     | 描述                                             |
| :----------------------------------------------------------- | :----------------------------------------------- |
| [break 语句](https://www.runoob.com/go/go-break-statement.html) | 经常用于中断当前 for 循环或跳出 switch 语句      |
| [continue 语句](https://www.runoob.com/go/go-continue-statement.html) | 跳过当前循环的剩余语句，然后继续进行下一轮循环。 |
| [goto 语句](https://www.runoob.com/go/go-goto-statement.html) | 将控制转移到被标记的语句。                       |

#### 2.1break语句

在 Go 语言中，break 语句用于终止当前循环或者 switch 语句的执行，并跳出该循环或者 switch 语句的代码块。

break 语句可以用于以下几个方面：。

- 用于循环语句中跳出循环，并开始执行循环之后的语句。
- break 在 switch 语句中在执行一条 case 后跳出语句的作用。
- break 可应用在 select 语句中。
- 在多重循环中，可以用标号 label 标出想 break 的循环。

以下实例在变量 a 大于 15 的时候跳出循环：

```go
package main

import "fmt"

func main() {
   /* 定义局部变量 */
   var a int = 10

   /* for 循环 */
   for a < 20 {
      fmt.Printf("a 的值为 : %d\n", a);
      a++
      if a > 15 {
         /* a 大于 15 时使用 break 语句跳出循环 */
         break
      }
   }
}
```

![截屏2023-09-16 08.35.48](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-16 08.35.48.png)

同样的，在switch和select语句中，我们都可以使用break，相关实例如下：

```go
// switch语句中使用break
package main

import "fmt"

func main() {
	day := "Tuesday"
	switch day {
	case "Monday":
		fmt.Println("It's Monday.")
	case "Tuesday":
		fmt.Println("It's Tuesday.")
		break // 跳出 switch 语句
	case "Wednesday":
		fmt.Println("It's Wednesday.")
	}
}
```

![截屏2023-09-16 08.38.28](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-16 08.38.28.png)

```go
//select语句中使用 break
package main

import (
    "fmt"
    "time"
)

func main() {
    ch1 := make(chan int)
    ch2 := make(chan int)

    go func() {
        time.Sleep(2 * time.Second)
        ch1 <- 1
    }()
    
    go func() {
        time.Sleep(1 * time.Second)
        ch2 <- 2
    }()
    
    select {
    case <-ch1:
        fmt.Println("Received from ch1.")
    case <-ch2:
        fmt.Println("Received from ch2.")
        break // 跳出 select 语句
    }

}
```

![截屏2023-09-16 08.40.28](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-16 08.40.28.png)

#### 2.2continue语句

Go 语言的 continue 语句 有点像 break 语句。但是 continue 不是跳出循环，而是跳过当前循环执行下一次循环语句。 

for 循环中，执行 continue 语句会触发 for 增量语句的执行。

在多重循环中，可以用标号 label 标出想 continue 的循环。

以下实例实现了在变量 a 等于 15 的时候跳过本次循环执行下一次循环：

```go
package main

import "fmt"

func main() {
   /* 定义局部变量 */
   var a int = 10

   /* for 循环 */
   for a < 20 {
      if a == 15 {
         /* 跳过此次循环 */
         a = a + 1;
         continue;
      }
      fmt.Printf("a 的值为 : %d\n", a);
      a++;     
   }  
}
```

![截屏2023-09-16 08.43.04](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-16 08.43.04.png)

#### 2.3goto语句

Go 语言的 goto 语句可以无条件地转移到过程中指定的行。

goto 语句通常与条件语句配合使用。可用来实现条件转移， 构成循环，跳出循环体等功能。

但是，在结构化程序设计中一般不主张使用 goto 语句， 以免造成程序流程的混乱，使理解和调试程序都产生困难。因此只列出如下一个简单的实例，在变量 a 等于 15 的时候跳过本次循环并回到循环的开始语句 LOOP 处：

```go
package main

import "fmt"

func main() {
   /* 定义局部变量 */
   var a int = 10

   /* 循环 */
   LOOP: for a < 20 {
      if a == 15 {
         /* 跳过迭代 */
         a = a + 1
         goto LOOP
      }
      fmt.Printf("a的值为 : %d\n", a)
      a++     
   }  
}
```

![截屏2023-09-16 08.45.06](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-16 08.45.06.png)

### 3.无限循环

如果循环中条件语句永远不为 false 则会进行无限循环，我们可以通过 for 循环语句中只设置一个条件表达式来执行无限循环（需使用control+c退出循环）：

```go
package main

import "fmt"

func main() {
    for true  {
        fmt.Printf("这是无限循环。\n");
    }
}
```

![截屏2023-09-16 08.46.52](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-16 08.46.52.png)

## （十）Go语言函数

函数是基本的代码块，用于执行一个任务。

Go 语言最少有个 main() 函数。

你可以通过函数来划分不同功能，逻辑上每个函数执行的是指定的任务。

函数声明告诉了编译器函数的名称，返回类型，和参数。

Go 语言标准库提供了多种可动用的内置的函数。例如，len() 函数可以接受不同类型参数并返回该类型的长度。如果我们传入的是字符串则返回字符串的长度，如果传入的是数组，则返回数组中包含的元素个数。

### 1.定义

Go 语言函数定义格式如下：

```go
func function_name( [parameter list] ) [return_types] {
   函数体
}
```

函数定义解析：

- func：函数由 func 开始声明
- function_name：函数名称，参数列表和返回值类型构成了函数签名。
- parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。
- return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。
- 函数体：函数定义的代码集合。

以下实例为 max() 函数的代码，该函数传入两个整型参数 num1 和 num2，并返回这两个参数的最大值：

```go
/* 函数返回两个数的最大值 */
func max(num1, num2 int) int {
   /* 声明局部变量 */
   var result int

   if (num1 > num2) {
      result = num1
   } else {
      result = num2
   }
   return result 
}
```

### 2.函数调用

当创建函数时，你定义了函数需要做什么，通过调用该函数来执行指定任务。

调用函数，向函数传递参数，并返回值，例如以下实例在 main() 函数中调用 max（）函数：

```go
package main

import "fmt"

func main() {
   /* 定义局部变量 */
   var a int = 100
   var b int = 200
   var ret int

   /* 调用函数并返回最大值 */
   ret = max(a, b)

   fmt.Printf( "最大值是 : %d\n", ret )
}

/* 函数返回两个数的最大值 */
func max(num1, num2 int) int {
   /* 定义局部变量 */
   var result int

   if (num1 > num2) {
      result = num1
   } else {
      result = num2
   }
   return result 
}
```

![截屏2023-09-16 09.15.35](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-16 09.15.35.png)

### 3.返回多个值

实例如下：

```go
package main

import "fmt"

func swap(x, y string) (string, string) {
   return y, x
}

func main() {
   a, b := swap("CR", "is your dad")
   fmt.Println(a, b)
}
```

![截屏2023-09-16 09.23.26](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-16 09.23.26.png)

### 4.函数参数

函数如果使用参数，该变量可称为函数的形参。

形参就像定义在函数体内的局部变量。

调用函数，可以通过两种方式来传递参数：

| 传递类型                                                     | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [值传递](https://www.runoob.com/go/go-function-call-by-value.html) | 值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。 |
| [引用传递](https://www.runoob.com/go/go-function-call-by-reference.html) | 引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。 |

默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。

#### 4.1值传递

传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。

默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。

以下定义了 swap() 函数：

```go
/* 定义相互交换值的函数 */
func swap(x, y int) int {
   var temp int

   temp = x /* 保存 x 的值 */
   x = y    /* 将 y 值赋给 x */
   y = temp /* 将 temp 值赋给 y*/

   return temp;
}
```

以下实例则是使用值传递来调用 swap() 函数：

```go
package main

import "fmt"

func main() {
   /* 定义局部变量 */
   var a int = 100
   var b int = 200

   fmt.Printf("交换前 a 的值为 : %d\n", a )
   fmt.Printf("交换前 b 的值为 : %d\n", b )

   /* 通过调用函数来交换值 */
   swap(a, b)

   fmt.Printf("交换后 a 的值 : %d\n", a )
   fmt.Printf("交换后 b 的值 : %d\n", b )
}

/* 定义相互交换值的函数 */
func swap(x, y int) int {
   var temp int

   temp = x /* 保存 x 的值 */
   x = y    /* 将 y 值赋给 x */
   y = temp /* 将 temp 值赋给 y*/

   return temp;
}
```

![截屏2023-09-16 09.31.38](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-16 09.31.38.png)

#### 4.2引用传递

```go
引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。

引用传递指针参数传递到函数内，以下是交换函数 swap() 使用了引用传递：

package main

import "fmt"

func main() {
   /* 定义局部变量 */
   var a int = 100
   var b int= 200

   fmt.Printf("交换前，a 的值 : %d\n", a )
   fmt.Printf("交换前，b 的值 : %d\n", b )

   /* 调用 swap() 函数

   * &a 指向 a 指针，a 变量的地址
   * &b 指向 b 指针，b 变量的地址
     */
        swap(&a, &b)

   fmt.Printf("交换后，a 的值 : %d\n", a )
   fmt.Printf("交换后，b 的值 : %d\n", b )
}

func swap(x *int, y *int) {
   var temp int
   temp = *x    /* 保存 x 地址上的值 */
   *x = *y      /* 将 y 值赋给 x */
   *y = temp    /* 将 temp 值赋给 y */
}
```

![截屏2023-09-16 09.35.52](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-16 09.35.52.png)

### 5.函数用法

| 函数用法                                                     | 描述                                     |
| :----------------------------------------------------------- | :--------------------------------------- |
| [函数作为另外一个函数的实参](https://www.runoob.com/go/go-function-as-values.html) | 函数定义后可作为另外一个函数的实参数传入 |
| [闭包](https://www.runoob.com/go/go-function-closures.html)  | 闭包是匿名函数，可在动态编程中使用       |
| [方法](https://www.runoob.com/go/go-method.html)             | 方法就是一个包含了接受者的函数           |

#### 5.1函数作为实参

Go 语言可以很灵活的创建函数，并作为另外一个函数的实参。以下实例中我们在定义的函数中初始化一个变量，该函数仅仅是为了使用内置函数 **math.sqrt()**，实例为：

```go
package main

import (
   "fmt"
   "math"
)

func main(){
   /* 声明函数变量 */
   getSquareRoot := func(x float64) float64 {
      return math.Sqrt(x)
   }

   /* 使用函数 */
   fmt.Println(getSquareRoot(9))

}
```

![截屏2023-09-16 09.38.52](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-16 09.38.52.png)

#### 5.2闭包

Go 语言支持匿名函数，可作为闭包。匿名函数是一个"内联"语句或表达式。匿名函数的优越性在于可以直接使用函数内的变量，不必申明。

匿名函数是一种没有函数名的函数，通常用于在函数内部定义函数，或者作为函数参数进行传递。

以下实例中，我们创建了函数 getSequence() ，返回另外一个函数。该函数的目的是在闭包中递增 i 变量，代码如下：

```go
package main

import "fmt"

func getSequence() func() int {
   i:=0
   return func() int {
      i+=1
     return i  
   }
}

func main(){
   /* nextNumber 为一个函数，函数 i 为 0 */
   nextNumber := getSequence()  

   /* 调用 nextNumber 函数，i 变量自增 1 并返回 */
   fmt.Println(nextNumber())
   fmt.Println(nextNumber())
   fmt.Println(nextNumber())

   /* 创建新的函数 nextNumber1，并查看结果 */
   nextNumber1 := getSequence()  
   fmt.Println(nextNumber1())
   fmt.Println(nextNumber1())
}
```

![截屏2023-09-16 09.40.16](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-16 09.40.16.png)

以下实例我们定义了多个匿名函数，并展示了如何将匿名函数赋值给变量、在函数内部使用匿名函数以及将匿名函数作为参数传递给其他函数。

```go
package main

import "fmt"

func main() {
    // 定义一个匿名函数并将其赋值给变量add
    add := func(a, b int) int {
        return a + b
    }

    // 调用匿名函数
    result := add(3, 5)
    fmt.Println("3 + 5 =", result)
    
    // 在函数内部使用匿名函数
    multiply := func(x, y int) int {
        return x * y
    }
    
    product := multiply(4, 6)
    fmt.Println("4 * 6 =", product)
    
    // 将匿名函数作为参数传递给其他函数
    calculate := func(operation func(int, int) int, x, y int) int {
        return operation(x, y)
    }
    
    sum := calculate(add, 2, 8)
    fmt.Println("2 + 8 =", sum)
    
    // 也可以直接在函数调用中定义匿名函数
    difference := calculate(func(a, b int) int {
        return a - b
    }, 10, 4)
    fmt.Println("10 - 4 =", difference)

}
```

![截屏2023-09-16 09.42.44](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-16 09.42.44.png)

#### 5.3方法

Go 语言中同时有函数和方法。一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。

下面定义一个结构体类型和该类型的一个方法：

```go
package main

import (
   "fmt"  
)

/* 定义结构体 */
type Circle struct {
  radius float64
}

func main() {
  var c1 Circle
  c1.radius = 10.00
  fmt.Println("圆的面积 = ", c1.getArea())
}

//该 method 属于 Circle 类型对象中的方法
func (c Circle) getArea() float64 {
  //c.radius 即为 Circle 类型对象中的属性
  return 3.14 * c.radius * c.radius
}
```

![截屏2023-09-16 09.43.59](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-16 09.43.59.png)

## （十一）Go 语言变量作用域

作用域为已声明标识符所表示的常量、类型、变量、函数或包在源代码中的作用范围。

Go 语言中变量可以在三个地方声明：

- 函数内定义的变量称为局部变量
- 函数外定义的变量称为全局变量
- 函数定义中的变量称为形式参数

接下来让我们具体了解局部变量、全局变量和形式参数。

### 1.局部变量

在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。

以下实例中 main() 函数使用了局部变量 a, b, c：

```go
package main

import "fmt"

func main() {
   /* 声明局部变量 */
   var a, b, c int 

   /* 初始化参数 */
   a = 10
   b = 20
   c = a + b

   fmt.Printf ("结果： a = %d, b = %d and c = %d\n", a, b, c)
}
```

![截屏2023-09-16 09.48.14](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-16 09.48.14.png)

### 2.全局变量

在函数体外声明的变量称之为全局变量，全局变量可以在整个包甚至外部包（被导出后）使用。

全局变量可以在任何函数中使用，以下实例演示了如何使用全局变量：

```go
package main

import "fmt"

/* 声明全局变量 */
var g int

func main() {

   /* 声明局部变量 */
   var a, b int

   /* 初始化参数 */
   a = 10
   b = 20
   g = a + b

   fmt.Printf("结果： a = %d, b = %d and g = %d\n", a, b, g)
}
```

![截屏2023-09-16 09.52.01](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-16 09.52.01.png)

注：Go 语言程序中全局变量与局部变量名称可以相同，但是函数内的局部变量会被优先考虑

### 3.形式参数

形式参数会作为函数的局部变量来使用。实例如下：

```go
package main

import "fmt"

/* 声明全局变量 */
var a int = 20;

func main() {
   /* main 函数中声明局部变量 */
   var a int = 10
   var b int = 20
   var c int = 0

   fmt.Printf("main()函数中 a = %d\n",  a);
   c = sum( a, b);
   fmt.Printf("main()函数中 c = %d\n",  c);
}

/* 函数定义-两数相加 */
func sum(a, b int) int {
   fmt.Printf("sum() 函数中 a = %d\n",  a);
   fmt.Printf("sum() 函数中 b = %d\n",  b);

   return a + b;
}
```

![截屏2023-09-16 09.54.03](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-16 09.54.03.png)

### 4.初始化局部变量与全局变量

不同类型的局部和全局变量默认值为：

| 数据类型 | 初始化默认值 |
| :------- | :----------- |
| int      | 0            |
| float32  | 0            |
| pointer  | nil          |

## （十二）Go语言数组

Go 语言提供了数组类型的数据结构。

数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，这种类型可以是任意的原始类型例如整型、字符串或者自定义类型。

相对于去声明 **number0, number1, ..., number99** 的变量，使用数组形式 **numbers[0], numbers[1] ..., numbers[99]** 更加方便且易于扩展。

数组元素可以通过索引（位置）来读取（或者修改），索引从 0 开始，第一个元素索引为 0，第二个索引为 1，以此类推。

![截屏2023-09-16 09.57.17](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-16 09.57.17.png)

### 1.数组声明

Go 语言数组声明需要指定元素类型及元素个数，如以下定义了数组 balance 长度为 10 类型为 float32：

```go
var balance [10]float32
```

### 2.初始化数组

以下演示了数组初始化：

以下实例声明一个名为 numbers 的整数数组，其大小为 5，在声明时，数组中的每个元素都会根据其数据类型进行默认初始化，对于整数类型，初始值为 0。

```go
var numbers [5]int
```

还可以使用初始化列表来初始化数组的元素：

```go
var numbers = [5]int{1, 2, 3, 4, 5}
```

以上代码创建一个名为 numbers 的整数数组，并将其大小设置为 5，并初始化元素的值。

**注意：**在 Go 语言中，数组的大小是类型的一部分，因此不同大小的数组是不兼容的，也就是说 **[5]int** 和 **[10]int** 是不同的类型。

以下定义了数组 balance 长度为 5 类型为 float32，并初始化数组的元素：

```go
var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}
```

我们也可以通过字面量在声明数组的同时快速初始化数组：

```go
balance := [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}
```

如果数组长度不确定，可以使用 **...** 代替数组的长度，编译器会根据元素个数自行推断数组的长度：

```go
var balance = [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}
或
balance := [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}
```

如果设置了数组的长度，我们还可以通过指定下标来初始化元素：

```go
//  将索引为 1 和 3 的元素初始化
balance := [5]float32{1:2.0,3:7.0}
```

初始化数组中 **{}** 中的元素个数不能大于 **[]** 中的数字。

如果忽略 **[]** 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小：

```go
 balance[4] = 50.0
```

以上实例读取了第五个元素。数组元素可以通过索引（位置）来读取（或者修改），索引从 0 开始，第一个元素索引为 0，第二个索引为 1，以此类推。

### 3.访问数组元素

数组元素可以通过索引（位置）来读取。格式为数组名后加中括号，中括号中为索引的值。例如：

```go
var salary float32 = balance[9]
```

以上实例读取了数组 balance 第 10 个元素的值。

完整数组操作声明、赋值、访问）的实例如下：

```go
package main

import "fmt"

func main() {
   var n [10]int /* n 是一个长度为 10 的数组 */
   var i,j int

   /* 为数组 n 初始化元素 */         
   for i = 0; i < 10; i++ {
      n[i] = i + 100 /* 设置元素为 i + 100 */
   }

   /* 输出每个数组元素的值 */
   for j = 0; j < 10; j++ {
      fmt.Printf("Element[%d] = %d\n", j, n[j] )
   }
}
```

![截屏2023-09-16 10.08.43](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-16 10.08.43.png)

### 4.多维数组

Go 语言支持多维数组，如以下实例声明了三维的整型数组：

```go
var threedim [5][10][4]int
```

#### 4.1二维数组

二维数组是最简单的多维数组，二维数组本质上是由一维数组组成的。二维数组定义方式如下：

```go
var arrayName [ x ][ y ] variable_type
```

variable_type 为 Go 语言的数据类型，arrayName 为数组名，二维数组可认为是一个表格，x 为行，y 为列，下图演示了一个二维数组 a 为三行四列，二维数组中的元素可通过 **a[ i ] [ j ]** 来访问：

![截屏2023-09-16 21.22.47](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-16 21.22.47.png)

有关二维数组的实例如下：

```go
package main

import "fmt"

func main() {
    // Step 1: 创建数组
    values := [][]int{}

    // Step 2: 使用 append() 函数向空的二维数组添加两行一维数组
    row1 := []int{1, 2, 3}
    row2 := []int{4, 5, 6}
    values = append(values, row1)
    values = append(values, row2)
    
    // Step 3: 显示两行数据
    fmt.Println("Row 1")
    fmt.Println(values[0])
    fmt.Println("Row 2")
    fmt.Println(values[1])
    
    // Step 4: 访问第一个元素
    fmt.Println("第一个元素为：")
    fmt.Println(values[0][0])

}
```

![截屏2023-09-17 09.52.55](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-17 09.52.55.png)

#### 4.2初始化二维数组

多维数组可通过大括号来初始值。以下实例为一个 3 行 4 列的二维数组：

```go
a := [3][4]int{  
 {0, 1, 2, 3} ,   /*  第一行索引为 0 */
 {4, 5, 6, 7} ,   /*  第二行索引为 1 */
 {8, 9, 10, 11},   /* 第三行索引为 2 */
}
```

**注意：**以上代码中倒数第二行的 **}** 必须要有逗号，因为最后一行的 **}** 不能单独一行，也可以写成这样：

```go
a := [3][4]int{  
 {0, 1, 2, 3} ,   /*  第一行索引为 0 */
 {4, 5, 6, 7} ,   /*  第二行索引为 1 */
 {8, 9, 10, 11}}   /* 第三行索引为 2 */
```

以下实例初始化一个 2 行 2 列 的二维数组：

```go
package main

import "fmt"

func main() {
    // 创建二维数组
    sites := [2][2]string{}

    // 向二维数组添加元素
    sites[0][0] = "Google"
    sites[0][1] = "Runoob"
    sites[1][0] = "Taobao"
    sites[1][1] = "Weibo"
    
    // 显示结果
    fmt.Println(sites)

}
```

![截屏2023-09-17 09.55.29](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-17 09.55.29.png)

#### 4.3访问二维数组

二维数组通过指定坐标来访问。如数组中的行索引与列索引，例如：

```go
val := a[2][3]
或
var value int = a[2][3]
```

以上实例访问了二维数组 val 第三行的第四个元素。

二维数组可以使用循环嵌套来输出元素：

```go
package main

import "fmt"

func main() {
   /* 数组 - 5 行 2 列*/
   var a = [5][2]int{ {0,0}, {1,2}, {2,4}, {3,6},{4,8}}
   var i, j int

   /* 输出数组元素 */
   for  i = 0; i < 5; i++ {
      for j = 0; j < 2; j++ {
         fmt.Printf("a[%d][%d] = %d\n", i,j, a[i][j] )
      }
   }
}
```

![截屏2023-09-17 09.59.54](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-17 09.59.54.png)

### 5.向函数传递数组

如果你想向函数传递数组参数，你需要在函数定义时，声明形参为数组，我们可以通过以下两种方式来声明：

方式一 形参设定数组大小：

```go
void myFunction(param [10]int)
{
.
.
.
}
```

方式二 形参未设定数组大小：

```go
void myFunction(param []int)
{
.
.
.
}
```

让我们看下以下实例，实例中函数接收整型数组参数，另一个参数指定了数组元素的个数，并返回平均值：

```go
func getAverage(arr []int, size int) float32
{
   var i int
   var avg, sum float32  

   for i = 0; i < size; ++i {
      sum += arr[i]
   }

   avg = sum / size

   return avg;
}
```

接下来我们来调用这个函数：

```go
package main

import "fmt"

func main() {
   /* 数组长度为 5 */
   var  balance = [5]int {1000, 2, 3, 17, 50}
   var avg float32

   /* 数组作为参数传递给函数 */
   avg = getAverage( balance, 5 ) ;

   /* 输出返回的平均值 */
   fmt.Printf( "平均值为: %f ", avg );
}
func getAverage(arr [5]int, size int) float32 {
   var i,sum int
   var avg float32  

   for i = 0; i < size;i++ {
      sum += arr[i]
   }

   avg = float32(sum) / float32(size)

   return avg;
}
```

![截屏2023-09-17 10.05.27](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-17 10.05.27.png)

## （十三）Go语言指针

Go 语言中指针是很容易学习的，Go 语言中使用指针可以更简单的执行一些任务。

接下来让我们来一步步学习 Go 语言指针。

我们都知道，变量是一种使用方便的占位符，用于引用计算机内存地址。

Go 语言的取地址符是 &，放到一个变量前使用就会返回相应变量的内存地址。

以下实例演示了变量在内存中地址：

```go
package main

import "fmt"

func main() {
   var a int = 10   

   fmt.Printf("变量的地址: %x\n", &a  )
}
```



现在我们已经了解了什么是内存地址和如何去访问它。接下来我们将具体介绍指针。

### 1.什么是指针

一个指针变量指向了一个值的内存地址。

类似于变量和常量，在使用指针前你需要声明指针。指针声明格式如下：

```go
var var_name *var-type
```

var-type 为指针类型，var_name 为指针变量名，* 号用于指定变量是作为一个指针。以下是有效的指针声明：

```go
var ip *int        /* 指向整型*/
var fp *float32    /* 指向浮点型 */
```

本例中这是一个指向 int 和 float32 的指针。

### 2.如何使用指针

指针使用流程：

- 定义指针变量。
- 为指针变量赋值。
- 访问指针变量中指向地址的值。

在指针类型前面加上 * 号（前缀）来获取指针所指向的内容。

```go
package main

import "fmt"

func main() {
   var a int= 20   /* 声明实际变量 */
   var ip *int        /* 声明指针变量 */

   ip = &a  /* 指针变量的存储地址 */

   fmt.Printf("a 变量的地址是: %x\n", &a  )

   /* 指针变量的存储地址 */
   fmt.Printf("ip 变量储存的指针地址: %x\n", ip )

   /* 使用指针访问值 */
   fmt.Printf("*ip 变量的值: %d\n", *ip )
}
 
```

![截屏2023-09-17 10.09.57](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-17 10.09.57.png)

### 3.Go空指针

当一个指针被定义后没有分配到任何变量时，它的值为 nil。

nil 指针也称为空指针。

nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。

一个指针变量通常缩写为 ptr。

查看以下实例：

```go
package main

import "fmt"

func main() {
   var  ptr *int

   fmt.Printf("ptr 的值为 : %x\n", ptr  )
}
```

![截屏2023-09-17 10.12.25](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-17 10.12.25.png)

空指针判断：

```go
if(ptr != nil)     /* ptr 不是空指针 */
if(ptr == nil)    /* ptr 是空指针 */
```

### 4.Go指针数组

在我们了解指针数组前，先看个实例，定义了长度为 3 的整型数组：

```go
package main

import "fmt"

const MAX int = 3

func main() {

   a := []int{10,100,200}
   var i int

   for i = 0; i < MAX; i++ {
      fmt.Printf("a[%d] = %d\n", i, a[i] )
   }
}
```

![截屏2023-09-17 10.13.11](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-17 10.13.11.png)

有一种情况，我们可能需要保存数组，这样我们就需要使用到指针。

以下声明了整型指针数组：

```go
var ptr [MAX]*int;
```

ptr 为整型指针数组。因此每个元素都指向了一个值。以下实例的三个整数将存储在指针数组中：

```go
package main

import "fmt"

const MAX int = 3

func main() {
   a := []int{10,100,200}
   var i int
   var ptr [MAX]*int;

   for  i = 0; i < MAX; i++ {
      ptr[i] = &a[i] /* 整数地址赋值给指针数组 */
   }

   for  i = 0; i < MAX; i++ {
      fmt.Printf("a[%d] = %d\n", i,*ptr[i] )
   }
}
```

![截屏2023-09-17 10.13.54](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-17 10.13.54.png)

### 5.指向指针的指针

如果一个指针变量存放的又是另一个指针变量的地址，则称这个指针变量为指向指针的指针变量。

当定义一个指向指针的指针变量时，第一个指针存放第二个指针的地址，第二个指针存放变量的地址：

![截屏2023-09-16 22.12.11](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-16 22.12.11.png)

访问指向指针的指针变量值需要使用两个 * 号，如下所示：

```go
package main

import "fmt"

func main() {

   var a int
   var ptr *int
   var pptr **int

   a = 3000

   /* 指针 ptr 地址 */
   ptr = &a

   /* 指向指针 ptr 地址 */
   pptr = &ptr

   /* 获取 pptr 的值 */
   fmt.Printf("变量 a = %d\n", a )
   fmt.Printf("指针变量 *ptr = %d\n", *ptr )
   fmt.Printf("指向指针的指针变量 **pptr = %d\n", **pptr)
}
```

![截屏2023-09-17 10.14.28](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-17 10.14.28.png)

### 6.指针作为函数参数

Go 语言允许向函数传递指针，只需要在函数定义的参数上设置为指针类型即可。

以下实例演示了如何向函数传递指针，并在函数调用后修改函数内的值：

```go
package main

import "fmt"

func main() {
   /* 定义局部变量 */
   var a int = 100
   var b int= 200

   fmt.Printf("交换前 a 的值 : %d\n", a )
   fmt.Printf("交换前 b 的值 : %d\n", b )

   /* 调用函数用于交换值

   * &a 指向 a 变量的地址
   * &b 指向 b 变量的地址
     */
        swap(&a, &b);

   fmt.Printf("交换后 a 的值 : %d\n", a )
   fmt.Printf("交换后 b 的值 : %d\n", b )
}

func swap(x *int, y *int) {
   var temp int
   temp = *x    /* 保存 x 地址的值 */
   *x = *y      /* 将 y 赋值给 x */
   *y = temp    /* 将 temp 赋值给 y */
}
```

![截屏2023-09-17 10.14.57](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-17 10.14.57.png)

## （十四）报错及解决方案

### 1.go插件无法安装

在安装go的相关插件时，报错如下：

![截屏2023-09-14 13.35.47](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-14 13.35.47.png)

**解决方案：**由于go插件大部分来自于GitHub，因为网络原因无法下载，因此下载插件只能通过设置GOPROXY代理解决：

```shell
go env -w GOPROXY=https://mirrors.aliyun.com/goproxy/
```

同时，执行如下命令：

```shell
git clone https://github.com/josharian/impl
```

 然后切换到GOPATH目录，执行如下命令：

```shell
PS C:\go\repository> go install github.com/josharian/impl@latest
PS C:\go\repository> go install github.com/ramya-rao-a/go-outline@latest
go: downloading github.com/ramya-rao-a/go-outline v0.0.0-20210608161538-9736a4bde949
go: downloading golang.org/x/tools v0.1.1
PS C:\go\repository>
```

 上述命令结束之后，重启VSCode，这下写Go代码就没有问题了。

![截屏2023-09-14 13.47.23](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-14 13.47.23.png)

### 2.expected 'package', found 'EOF'

运行hello world代码时，报错如下：

![截屏2023-09-14 15.20.16](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-14 15.20.16.png)

**解决方案：**按control+s保存一下文件就好了。

![截屏2023-09-14 15.21.26](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-14 15.21.26.png)

### 3.function main is undeclared in the main package

在运行函数代码时，报错如下：

![截屏2023-09-16 09.00.09](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-16 09.00.09.png)

**解决方案：**出现该报错的原因是函数max在主包中未申明，需要将main函数作为运行入口，因此，需要先创立一个main函数，再在main函数中调用max函数即可

![截屏2023-09-16 09.15.35](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-16 09.15.35.png)

## （十五）实验总结与反思

本学期，我们开始了区块链技术与运用的相关学习，在第一节课上，老师并未给我们讲那些过于泛化和概念性的知识，用老师的话来说，比起这些张口乱喷的东西不如直接上干货来的实在。

但还是有一些基本的观点需要我们知道的，比如一开始老师就纠正了我们——虚拟机其实是一个Linux服务器装载ubuntu操作系统。除此之外，分布式账本技术DLT也是一个我第一次听说的概念。

分布式账本技术（[DLT](https://so.csdn.net/so/search?q=DLT&spm=1001.2101.3001.7020)）是指允许在一个网络化数据库中同时进行访问、验证和记录更新的技术基础设施和协议。DLT是区块链的创建技术，该基础设施允许用户查看任何变化以及谁做了这些变化，减少了对数据的审计需求，确保了数据的可靠性，并且只向需要它的人提供访问权限。

**关键点**

- 分布式账本由一个节点网络维护，每个节点都有一个账本的副本，验证信息，并帮助达成关于其准确性的共识。
- 分布式账本已经存在了几十年，但自从比特币推出以来，它们变得更加知名、被研究、使用和开发。
- 分布式账本可以用于几乎所有收集和使用数据的行业。
- 所有区块链都是分布式账本，但并不是所有分布式账本都是区块链。
- 尽管DLT增强了问责制、安全性和可访问性，但它仍然复杂、难以扩展，并且没有受到强有力的监管。

**分布式账本的历史**

分布式计算并不新鲜——企业和政府已经使用这个概念几十年了。在20世纪90年代，不同地点的多台计算机和用户能够解决问题并将解决方案返回到一个中心位置。

数据科学、计算、软件、硬件和其他技术的进步使账本变得更加强大。通过内部网和互联网协议提高了连接性，使得更多的数据可以被收集、分析和使用。然而，由于现在有很多用户可以访问数据，因此有必要验证这些变化。

计算机和数据科学家开发了减少对数据审计需求的程序。这些程序使用自动化和数据加密技术来验证[数据库事务](https://so.csdn.net/so/search?q=数据库事务&spm=1001.2101.3001.7020)或数据库状态的变化。这被称为共识——即对交易有效性的自动化多数意见一致的行为，其中交易只是对数据库状态所做的改变。

分布式账本技术（DLT）是指一种利用加密技术来安全准确地存储信息的技术，信息可以通过“密钥”和数字签名来访问。一旦信息被存储，它就可以成为一个不可变的数据库；网络的规则，写入数据库编程的代码中，决定了账本的管理。

如果某件事是不可变的，那么它就无法被改变。分布式账本只有在被编程成这样的时候才是不可变的。区块链总是不可变的，因为它们是去中心化的公共账本。

由于它们是去中心化、私密和加密的，分布式账本更不容易受到网络犯罪的影响，因为所有存储在网络上的副本都需要同时被攻击才能成功。此外，点对点共享和更新记录使整个过程更快、更有效、更便宜。

分布式账本网络上的每个设备都存储了账本的副本。这些设备被称为节点——一个网络可以有任意数量的节点。任何对账本的更改，例如将数据从一个区块移动到另一个区块，都会在所有节点上记录。因为每个节点都有账本的副本，每个节点都会发布其最新交易版本的版本。

如果网络对最新账本的有效性达成共识，那么交易就会被最终确定、加密，并作为后续交易的基础。这就是区块链如何发展的——每个区块包含了前一个区块的加密信息，这使得它们不可能被改变。 行业使用分布式账本技术 分布式账本被创建用于许多不同的目的，但其中最常用的一种方式是作为一个平台，供其他人进行扩展和使用。其中一个较为知名的分布式账本是Hyperledger Fabric。它是一个模块化和可扩展的DLT平台，许多企业已经使用它来创建涵盖多个行业的解决方案。一些实施了DLT解决方案的行业包括航空、教育、医疗、保险、制造、运输和公用事业。 

供应链可以从DLT中受益匪浅。许多因素使它们低效、不准确，并容易受到腐败或损失的影响。富士通（Fujitsu），一家全球数据和信息技术公司，设计了分布式账本技术来增强供应链透明度和防欺诈能力，通过在账本上记录和跟踪数据。

富士通的大米交易所（Rice Exchange）是为了交易大米而创建的，确保有关来源、价格、保险、运输和结算等数据记录在账本上。任何参与者都可以查看任何数据，并找到有关整个过程的准确信息，因为它无法被更改。所有数据都由平台自动输入和保护——它最终将为大米集装箱提供跟踪信息，因为它被运送到最终目的地。

至于本周对Go语言的基本语法和相关知识的学习，我也在这几个学期对编程语言的学习过程中找到了一些节奏，因此学习起来也相对更加得心应手了一些。但归根到底，现在还是学习go语言的一个起步阶段，我所了解的还都是一些基础的语法，所做的也只是对着代码敲一敲，所以心态自然好。希望在之后的学习中也能够维持着一份平静，发自内心地以学习知识为目的。
