 <img src="/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-08-31 09.48.04.png" alt="截屏2023-08-31 09.48.04" style="zoom:60%;" />

| **报告名称**：   | 实验九：Hyperledger Fabric 2.5+Gin+Gateway 读取/写入账本数据 |
| ---------------- | ------------------------------------------------------------ |
| **学生姓名：**   | 杨超然                                                       |
| **学生学号：**   | 202106060220                                                 |
| **专业班级：**   | 信管2101班                                                   |
| **学**  **院：** | 工商管理学院                                                 |
| **指导老师：**   | 周中定                                                       |
| **日  期：**     | 2023.11.9                                                    |

------

[TOC]

------

# 一、实验说明

[Reference Link](https://blog.csdn.net/weixin_42694422/article/details/130741285)

![截屏2023-11-09 15.52.57](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-09 15.52.57.png)

## （一）Gin框架优点

1. 轻量级，高性能、扩展性强、稳定性强、相对而言比较简洁
2. Gin是使用Go/golang语言实现的HTTP Web框架，接口简洁，性能极高
3. Gin是一个golang的微框架，封装比较优雅，API友好，源码注释比较明确，具有快速灵活，容错方便等特点。
4. 其实对于golang而言，web框架的依赖要远比Python，Java之类的要小。自身的net/http足够简单，性能也非常不错。
5. 框架更像是一些常用函数或者工具的集合。借助框架开发，不仅可以省去很多常用的封装带来的时间，也有助于团队的编码风格和形成规范。

## （二）Fabric Gateway

Fabric-Gateway是Hyperledger Fabric v2.4 在peer上增加的一项服务，逐步减少Java SDK API的使用频率，并希望大家的客户端开发集中使用Gateway来完成。

网关SDK是应用程序与区块链网络交互的一个工具，提供了一些简单的API向账本提交交易或者查询，只需要一个peer运行一个应用进程即可提交事务。

应用开发者能够专注于业务逻辑，而不必关系Fabric的基础架构逻辑。因此，API提供了组织和合约的逻辑抽象，而不是对操作抽象也不是对链码和peer的抽象

https://hyperledger-fabric.readthedocs.io/en/latest/gateway.html 官方文档地址go版本

![截屏2023-11-09 15.54.14](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-09 15.54.14.png)

## （三）Gateway搭建客户端需要哪些文件

首先，要想提交交易，我们需要以一个合法的身份标识（Identities） 去连接到Fabric网络。

大家在创建Identies时，会为节点与账户分别生成密钥证书材料，这里的账户就是我们在客户端中需要的身份标识。

与我们熟悉的基于账号和密码的登录方式不同，Fabric中以私钥与证书（包含被信任实体签名后的公钥）标识一个身份Identity。

因此，我们需要提供一个被当前通道所信任账户的注册证书与公钥。

其次，与peer节点进行通信，需要指定peer的endpoint（端点），Fabric通信过程通常启用TLS协议以确保安全，因此我们还需要提供上述账户的TLS证书。

最后，还需指定要调用的链码所在的**通道，链码名称、调用的合约方法名称，以及要给方法传递的参数***（后面代码中会有体现）

## （四）Gateway搭建客户端需要哪些文件

在使用peer chaincode invoke命令提交交易时，我们需要使用–peerAddresses指定背书节点，并在后面用–TLSRootCertFile指定与该背书节点通信所用的TLS根证书，当我们需要多个节点进行背书时时，CLI需要在命令中逐个指定。

```bash
$ peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride 
orderer.example.com --tls --cafile
"${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example. 
com/msp/tlscacerts/tlsca.example.com-cert.pem" -C mychannel -n mycc -- 
peerAddresses localhost:7051 --tlsRootCertFiles
"${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.exampl 
e.com/tls/ca.crt" --peerAddresses localhost:9051 --tlsRootCertFiles
"${PWD}/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.exampl 
e.com/tls/ca.crt" -c '{"function":"Init","Args":["A","100","B","200"]}'
```

但是在用Gateway API开发客户端的时候，有没有发现除了指定要和哪个peer节点通信外，我们没有指定过任何和背书有关的信息？

这项功能得益于服务发现（Service Discovery）。

客户端要想完成与Fabric网络交互的一系列任务，那么就有必要获知网络的拓扑以及相关通道的各种策略（例如背书策略）。

早期这些是由程序员静态配置在客户端本地的，但是网络拓扑易变，一个成熟的客户端应用不可能每次连接都手动修改客户端的配置。发现来完成背书。

服务发现属于peer节点功能的一部分。可以通过服务发现获知网络拓扑、背书政策以及在线节点等内容。

我们的Gateway客户端通过Peer节点调用服务发现来获取目标链码的背书策略，并且获知目前在线的可以满足背书政策的背书节点集合（包括IP地址和端口），Gateway默认选取满足背书政策且节点数量最少的一组节点发送背书请求，如果每个集合节点数量一样将随机选取。

因此如果背书失败，请检查节点状态以及服务发现是否启动。

# 二、前置部署与链码配置

## （一）Gin安装

```bash
go get -u github.com/gin-gonic/gin
```

⚠️务必注意：**go版本要在1.45版本及其以上**，不然无法使用Gin框架里面的部分组件。

![截屏2023-11-09 16.45.12](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-09 16.45.12.png)

```bash
# 查看go的版本号
go version
```

![截屏2023-11-09 16.20.47](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-09 16.20.47.png)

## （二）启动网络

```bash
$ cd ~/go/src/github.com/hyperledger/fabric-samples/test-network
$ ./network.sh up
# 如果想要同时启动CA服务器和couchdb
$ ./network.sh up createChannel -ca -s couchdb
```

![截屏2023-11-09 16.47.24](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-09 16.47.24.png)

![截屏2023-11-09 16.48.06](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-09 16.48.06.png)

```bash
# 运行详细信息
Using docker and docker-compose
Creating channel 'mychannel'.
If network is not up, starting nodes with CLI timeout of '5' tries and CLI delay of '3' seconds and using database 'couchdb 
Network Running Already
Using docker and docker-compose
Generating channel genesis block 'mychannel.block'
Using organization 1
/home/hadoop/go/bin/configtxgen
+ '[' 0 -eq 1 ']'
+ configtxgen -profile ChannelUsingRaft -outputBlock ./channel-artifacts/mychannel.block -channelID mychannel
2023-11-09 16:47:49.522 CST 0001 INFO [common.tools.configtxgen] main -> Loading configuration
2023-11-09 16:47:49.526 CST 0002 INFO [common.tools.configtxgen.localconfig] completeInitialization -> orderer type: etcdraft
2023-11-09 16:47:49.526 CST 0003 INFO [common.tools.configtxgen.localconfig] completeInitialization -> Orderer.EtcdRaft.Options unset, setting to tick_interval:"500ms" election_tick:10 heartbeat_tick:1 max_inflight_blocks:5 snapshot_interval_size:16777216 
2023-11-09 16:47:49.526 CST 0004 INFO [common.tools.configtxgen.localconfig] Load -> Loaded configuration: /home/hadoop/go/src/github.com/hyperledger/fabric-samples/test-network/configtx/configtx.yaml
2023-11-09 16:47:49.528 CST 0005 INFO [common.tools.configtxgen] doOutputBlock -> Generating genesis block
2023-11-09 16:47:49.528 CST 0006 INFO [common.tools.configtxgen] doOutputBlock -> Creating application channel genesis block
2023-11-09 16:47:49.528 CST 0007 INFO [common.tools.configtxgen] doOutputBlock -> Writing genesis block
+ res=0
Creating channel mychannel
Adding orderers
+ . scripts/orderer.sh mychannel
+ '[' 0 -eq 1 ']'
+ res=0
Status: 201
{
	"name": "mychannel",
	"url": "/participation/v1/channels/mychannel",
	"consensusRelation": "consenter",
	"status": "active",
	"height": 1
}

Channel 'mychannel' created
Joining org1 peer to the channel...
Using organization 1
+ peer channel join -b ./channel-artifacts/mychannel.block
+ res=0
2023-11-09 16:47:55.663 CST 0001 INFO [grpc] AddTraceEvent -> [core] [Channel #1] Channel created
2023-11-09 16:47:55.664 CST 0002 INFO [grpc] AddTraceEvent -> [core] [Channel #1] original dial target is: "localhost:7051"
2023-11-09 16:47:55.664 CST 0003 INFO [grpc] AddTraceEvent -> [core] [Channel #1] parsed dial target is: {Scheme:localhost Authority: URL:{Scheme:localhost Opaque:7051 User: Host: Path: RawPath: OmitHost:false ForceQuery:false RawQuery: Fragment: RawFragment:}}
2023-11-09 16:47:55.664 CST 0004 INFO [grpc] AddTraceEvent -> [core] [Channel #1] fallback to scheme "passthrough"
2023-11-09 16:47:55.664 CST 0005 INFO [grpc] AddTraceEvent -> [core] [Channel #1] parsed dial target is: {Scheme:passthrough Authority: URL:{Scheme:passthrough Opaque: User: Host: Path:/localhost:7051 RawPath: OmitHost:false ForceQuery:false RawQuery: Fragment: RawFragment:}}
2023-11-09 16:47:55.664 CST 0006 INFO [grpc] AddTraceEvent -> [core] [Channel #1] Channel authority set to "localhost:7051"
2023-11-09 16:47:55.664 CST 0007 INFO [grpc] AddTraceEvent -> [core] [Channel #1] Resolver state updated: {
  "Addresses": [
    {
      "Addr": "localhost:7051",
      "ServerName": "",
      "Attributes": null,
      "BalancerAttributes": null,
      "Type": 0,
      "Metadata": null
    }
  ],
  "ServiceConfig": null,
  "Attributes": null
} (resolver returned new addresses)
2023-11-09 16:47:55.664 CST 0008 INFO [grpc] AddTraceEvent -> [core] [Channel #1] Channel switches to new LB policy "pick_first"
2023-11-09 16:47:55.664 CST 0009 INFO [grpc] AddTraceEvent -> [core] [Channel #1 SubChannel #2] Subchannel created
2023-11-09 16:47:55.664 CST 000a INFO [grpc] AddTraceEvent -> [core] [Channel #1] Channel Connectivity change to CONNECTING
2023-11-09 16:47:55.664 CST 000b INFO [grpc] AddTraceEvent -> [core] [Channel #1 SubChannel #2] Subchannel Connectivity change to CONNECTING
2023-11-09 16:47:55.664 CST 000c INFO [grpc] AddTraceEvent -> [core] [Channel #1 SubChannel #2] Subchannel picks a new address "localhost:7051" to connect
2023-11-09 16:47:55.664 CST 000d INFO [grpc] Infof -> [core] pickfirstBalancer: UpdateSubConnState: 0x4000231098, {CONNECTING <nil>}
2023-11-09 16:47:55.668 CST 000e INFO [grpc] AddTraceEvent -> [core] [Channel #1 SubChannel #2] Subchannel Connectivity change to READY
2023-11-09 16:47:55.668 CST 000f INFO [grpc] Infof -> [core] pickfirstBalancer: UpdateSubConnState: 0x4000231098, {READY <nil>}
2023-11-09 16:47:55.668 CST 0010 INFO [grpc] AddTraceEvent -> [core] [Channel #1] Channel Connectivity change to READY
2023-11-09 16:47:55.668 CST 0011 INFO [channelCmd] InitCmdFactory -> Endorser and orderer connections initialized
2023-11-09 16:47:55.684 CST 0012 INFO [channelCmd] executeJoin -> Successfully submitted proposal to join channel
Joining org2 peer to the channel...
Using organization 2
+ peer channel join -b ./channel-artifacts/mychannel.block
+ res=0
2023-11-09 16:47:58.743 CST 0001 INFO [grpc] AddTraceEvent -> [core] [Channel #1] Channel created
2023-11-09 16:47:58.743 CST 0002 INFO [grpc] AddTraceEvent -> [core] [Channel #1] original dial target is: "localhost:9051"
2023-11-09 16:47:58.743 CST 0003 INFO [grpc] AddTraceEvent -> [core] [Channel #1] parsed dial target is: {Scheme:localhost Authority: URL:{Scheme:localhost Opaque:9051 User: Host: Path: RawPath: OmitHost:false ForceQuery:false RawQuery: Fragment: RawFragment:}}
2023-11-09 16:47:58.743 CST 0004 INFO [grpc] AddTraceEvent -> [core] [Channel #1] fallback to scheme "passthrough"
2023-11-09 16:47:58.743 CST 0005 INFO [grpc] AddTraceEvent -> [core] [Channel #1] parsed dial target is: {Scheme:passthrough Authority: URL:{Scheme:passthrough Opaque: User: Host: Path:/localhost:9051 RawPath: OmitHost:false ForceQuery:false RawQuery: Fragment: RawFragment:}}
2023-11-09 16:47:58.743 CST 0006 INFO [grpc] AddTraceEvent -> [core] [Channel #1] Channel authority set to "localhost:9051"
2023-11-09 16:47:58.743 CST 0007 INFO [grpc] AddTraceEvent -> [core] [Channel #1] Resolver state updated: {
  "Addresses": [
    {
      "Addr": "localhost:9051",
      "ServerName": "",
      "Attributes": null,
      "BalancerAttributes": null,
      "Type": 0,
      "Metadata": null
    }
  ],
  "ServiceConfig": null,
  "Attributes": null
} (resolver returned new addresses)
2023-11-09 16:47:58.743 CST 0008 INFO [grpc] AddTraceEvent -> [core] [Channel #1] Channel switches to new LB policy "pick_first"
2023-11-09 16:47:58.743 CST 0009 INFO [grpc] AddTraceEvent -> [core] [Channel #1 SubChannel #2] Subchannel created
2023-11-09 16:47:58.743 CST 000a INFO [grpc] AddTraceEvent -> [core] [Channel #1] Channel Connectivity change to CONNECTING
2023-11-09 16:47:58.743 CST 000b INFO [grpc] AddTraceEvent -> [core] [Channel #1 SubChannel #2] Subchannel Connectivity change to CONNECTING
2023-11-09 16:47:58.743 CST 000c INFO [grpc] AddTraceEvent -> [core] [Channel #1 SubChannel #2] Subchannel picks a new address "localhost:9051" to connect
2023-11-09 16:47:58.743 CST 000d INFO [grpc] Infof -> [core] pickfirstBalancer: UpdateSubConnState: 0x4000176798, {CONNECTING <nil>}
2023-11-09 16:47:58.746 CST 000e INFO [grpc] AddTraceEvent -> [core] [Channel #1 SubChannel #2] Subchannel Connectivity change to READY
2023-11-09 16:47:58.746 CST 000f INFO [grpc] Infof -> [core] pickfirstBalancer: UpdateSubConnState: 0x4000176798, {READY <nil>}
2023-11-09 16:47:58.746 CST 0010 INFO [grpc] AddTraceEvent -> [core] [Channel #1] Channel Connectivity change to READY
2023-11-09 16:47:58.746 CST 0011 INFO [channelCmd] InitCmdFactory -> Endorser and orderer connections initialized
2023-11-09 16:47:58.761 CST 0012 INFO [channelCmd] executeJoin -> Successfully submitted proposal to join channel
Setting anchor peer for org1...
Using organization 1
Fetching channel config for channel mychannel
Using organization 1
Fetching the most recent configuration block for the channel
+ peer channel fetch config config_block.pb -o orderer.example.com:7050 --ordererTLSHostnameOverride orderer.example.com -c mychannel --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/organizations/ordererOrganizations/example.com/tlsca/tlsca.example.com-cert.pem
2023-11-09 08:47:58.878 UTC 0001 INFO [channelCmd] InitCmdFactory -> Endorser and orderer connections initialized
2023-11-09 08:47:58.881 UTC 0002 INFO [cli.common] readBlock -> Received block: 0
2023-11-09 08:47:58.881 UTC 0003 INFO [channelCmd] fetch -> Retrieving last config block: 0
2023-11-09 08:47:58.882 UTC 0004 INFO [cli.common] readBlock -> Received block: 0
+ configtxlator proto_decode --input config_block.pb --type common.Block --output config_block.json
Decoding config block to JSON and isolating config to Org1MSPconfig.json
+ jq '.data.data[0].payload.data.config' config_block.json
Generating anchor peer update transaction for Org1 on channel mychannel
+ jq '.channel_group.groups.Application.groups.Org1MSP.values += {"AnchorPeers":{"mod_policy": "Admins","value":{"anchor_peers": [{"host": "peer0.org1.example.com","port": 7051}]},"version": "0"}}' Org1MSPconfig.json
+ configtxlator proto_encode --input Org1MSPconfig.json --type common.Config --output original_config.pb
+ configtxlator proto_encode --input Org1MSPmodified_config.json --type common.Config --output modified_config.pb
+ configtxlator compute_update --channel_id mychannel --original original_config.pb --updated modified_config.pb --output config_update.pb
+ configtxlator proto_decode --input config_update.pb --type common.ConfigUpdate --output config_update.json
+ jq .
++ cat config_update.json
+ echo '{"payload":{"header":{"channel_header":{"channel_id":"mychannel", "type":2}},"data":{"config_update":{' '"channel_id":' '"mychannel",' '"isolated_data":' '{},' '"read_set":' '{' '"groups":' '{' '"Application":' '{' '"groups":' '{' '"Org1MSP":' '{' '"groups":' '{},' '"mod_policy":' '"",' '"policies":' '{' '"Admins":' '{' '"mod_policy":' '"",' '"policy":' null, '"version":' '"0"' '},' '"Endorsement":' '{' '"mod_policy":' '"",' '"policy":' null, '"version":' '"0"' '},' '"Readers":' '{' '"mod_policy":' '"",' '"policy":' null, '"version":' '"0"' '},' '"Writers":' '{' '"mod_policy":' '"",' '"policy":' null, '"version":' '"0"' '}' '},' '"values":' '{' '"MSP":' '{' '"mod_policy":' '"",' '"value":' null, '"version":' '"0"' '}' '},' '"version":' '"0"' '}' '},' '"mod_policy":' '"",' '"policies":' '{},' '"values":' '{},' '"version":' '"0"' '}' '},' '"mod_policy":' '"",' '"policies":' '{},' '"values":' '{},' '"version":' '"0"' '},' '"write_set":' '{' '"groups":' '{' '"Application":' '{' '"groups":' '{' '"Org1MSP":' '{' '"groups":' '{},' '"mod_policy":' '"Admins",' '"policies":' '{' '"Admins":' '{' '"mod_policy":' '"",' '"policy":' null, '"version":' '"0"' '},' '"Endorsement":' '{' '"mod_policy":' '"",' '"policy":' null, '"version":' '"0"' '},' '"Readers":' '{' '"mod_policy":' '"",' '"policy":' null, '"version":' '"0"' '},' '"Writers":' '{' '"mod_policy":' '"",' '"policy":' null, '"version":' '"0"' '}' '},' '"values":' '{' '"AnchorPeers":' '{' '"mod_policy":' '"Admins",' '"value":' '{' '"anchor_peers":' '[' '{' '"host":' '"peer0.org1.example.com",' '"port":' 7051 '}' ']' '},' '"version":' '"0"' '},' '"MSP":' '{' '"mod_policy":' '"",' '"value":' null, '"version":' '"0"' '}' '},' '"version":' '"1"' '}' '},' '"mod_policy":' '"",' '"policies":' '{},' '"values":' '{},' '"version":' '"0"' '}' '},' '"mod_policy":' '"",' '"policies":' '{},' '"values":' '{},' '"version":' '"0"' '}' '}}}}'
+ configtxlator proto_encode --input config_update_in_envelope.json --type common.Envelope --output Org1MSPanchors.tx
2023-11-09 08:47:59.102 UTC 0001 INFO [channelCmd] InitCmdFactory -> Endorser and orderer connections initialized
2023-11-09 08:47:59.113 UTC 0002 INFO [channelCmd] update -> Successfully submitted channel update
Anchor peer set for org 'Org1MSP' on channel 'mychannel'
Setting anchor peer for org2...
Using organization 2
Fetching channel config for channel mychannel
Using organization 2
Fetching the most recent configuration block for the channel
+ peer channel fetch config config_block.pb -o orderer.example.com:7050 --ordererTLSHostnameOverride orderer.example.com -c mychannel --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/organizations/ordererOrganizations/example.com/tlsca/tlsca.example.com-cert.pem
2023-11-09 08:47:59.256 UTC 0001 INFO [channelCmd] InitCmdFactory -> Endorser and orderer connections initialized
2023-11-09 08:47:59.258 UTC 0002 INFO [cli.common] readBlock -> Received block: 1
2023-11-09 08:47:59.258 UTC 0003 INFO [channelCmd] fetch -> Retrieving last config block: 1
2023-11-09 08:47:59.259 UTC 0004 INFO [cli.common] readBlock -> Received block: 1
Decoding config block to JSON and isolating config to Org2MSPconfig.json
+ configtxlator proto_decode --input config_block.pb --type common.Block --output config_block.json
+ jq '.data.data[0].payload.data.config' config_block.json
Generating anchor peer update transaction for Org2 on channel mychannel
+ jq '.channel_group.groups.Application.groups.Org2MSP.values += {"AnchorPeers":{"mod_policy": "Admins","value":{"anchor_peers": [{"host": "peer0.org2.example.com","port": 9051}]},"version": "0"}}' Org2MSPconfig.json
+ configtxlator proto_encode --input Org2MSPconfig.json --type common.Config --output original_config.pb
+ configtxlator proto_encode --input Org2MSPmodified_config.json --type common.Config --output modified_config.pb
+ configtxlator compute_update --channel_id mychannel --original original_config.pb --updated modified_config.pb --output config_update.pb
+ configtxlator proto_decode --input config_update.pb --type common.ConfigUpdate --output config_update.json
+ jq .
++ cat config_update.json
+ echo '{"payload":{"header":{"channel_header":{"channel_id":"mychannel", "type":2}},"data":{"config_update":{' '"channel_id":' '"mychannel",' '"isolated_data":' '{},' '"read_set":' '{' '"groups":' '{' '"Application":' '{' '"groups":' '{' '"Org2MSP":' '{' '"groups":' '{},' '"mod_policy":' '"",' '"policies":' '{' '"Admins":' '{' '"mod_policy":' '"",' '"policy":' null, '"version":' '"0"' '},' '"Endorsement":' '{' '"mod_policy":' '"",' '"policy":' null, '"version":' '"0"' '},' '"Readers":' '{' '"mod_policy":' '"",' '"policy":' null, '"version":' '"0"' '},' '"Writers":' '{' '"mod_policy":' '"",' '"policy":' null, '"version":' '"0"' '}' '},' '"values":' '{' '"MSP":' '{' '"mod_policy":' '"",' '"value":' null, '"version":' '"0"' '}' '},' '"version":' '"0"' '}' '},' '"mod_policy":' '"",' '"policies":' '{},' '"values":' '{},' '"version":' '"0"' '}' '},' '"mod_policy":' '"",' '"policies":' '{},' '"values":' '{},' '"version":' '"0"' '},' '"write_set":' '{' '"groups":' '{' '"Application":' '{' '"groups":' '{' '"Org2MSP":' '{' '"groups":' '{},' '"mod_policy":' '"Admins",' '"policies":' '{' '"Admins":' '{' '"mod_policy":' '"",' '"policy":' null, '"version":' '"0"' '},' '"Endorsement":' '{' '"mod_policy":' '"",' '"policy":' null, '"version":' '"0"' '},' '"Readers":' '{' '"mod_policy":' '"",' '"policy":' null, '"version":' '"0"' '},' '"Writers":' '{' '"mod_policy":' '"",' '"policy":' null, '"version":' '"0"' '}' '},' '"values":' '{' '"AnchorPeers":' '{' '"mod_policy":' '"Admins",' '"value":' '{' '"anchor_peers":' '[' '{' '"host":' '"peer0.org2.example.com",' '"port":' 9051 '}' ']' '},' '"version":' '"0"' '},' '"MSP":' '{' '"mod_policy":' '"",' '"value":' null, '"version":' '"0"' '}' '},' '"version":' '"1"' '}' '},' '"mod_policy":' '"",' '"policies":' '{},' '"values":' '{},' '"version":' '"0"' '}' '},' '"mod_policy":' '"",' '"policies":' '{},' '"values":' '{},' '"version":' '"0"' '}' '}}}}'
+ configtxlator proto_encode --input config_update_in_envelope.json --type common.Envelope --output Org2MSPanchors.tx
2023-11-09 08:47:59.487 UTC 0001 INFO [channelCmd] InitCmdFactory -> Endorser and orderer connections initialized
2023-11-09 08:47:59.497 UTC 0002 INFO [channelCmd] update -> Successfully submitted channel update
Anchor peer set for org 'Org2MSP' on channel 'mychannel'
Channel 'mychannel' joined

```

## （三）部署链码

安装部署官方资产链码（大家可以在官方链码文件夹中找得到）
关于如何部署自己编写的go语言链码并实例化测试，参考我这篇博客学习：
Fabric 超级账本学习【2】Fabric2.4网络环境下部署自己编写的go语言链码并实例化测试（手把手教 
学，步骤超详细）

```bash
./network.sh deployCC -ccn basic -ccp ../asset-transfer-basic/chaincode-go -ccl go
```

![截屏2023-11-09 16.54.27](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-09 16.54.27.png)

![截屏2023-11-09 16.59.43](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-09 16.59.43.png)

## （四）操作链码环境配置

以org1的组织管理员身份去操作链码

```bash
export PATH=${PWD}/../bin:$PATH
export FABRIC_CFG_PATH=$PWD/../config/
export CORE_PEER_TLS_ENABLED=true
export CORE_PEER_LOCALMSPID="Org1MSP"
export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt
export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
export CORE_PEER_ADDRESS=localhost:7051
```

![截屏2023-11-09 17.13.09](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-09 17.13.09.png)

![截屏2023-11-09 17.12.52](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-09 17.12.52.png)

## （五）初始化链码

```bash
peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile "${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem" -C mychannel -n basic --peerAddresses localhost:7051 --tlsRootCertFiles "${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt" --peerAddresses localhost:9051 --tlsRootCertFiles "${PWD}/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt" -c '{"function":"InitLedger","Args":[""]}'添加资产
peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile "${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem" -C mychannel -n basic --peerAddresses localhost:7051 --tlsRootCertFiles "${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt" --peerAddresses localhost:9051 --tlsRootCertFiles "${PWD}/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt" -c '{"function":"CreateAsset","Args":["asset66", "yellow", "6", "Tom", "130660"]}'
```

![截屏2023-11-09 17.14.11](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-09 17.14.11.png)

# 三、账本数据的读取与写入

## （一）添加资产

```bash
peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile "${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem" -C mychannel -n basic -- peerAddresses localhost:7051 --tlsRootCertFiles "${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt" --peerAddresses localhost:9051 --tlsRootCertFiles "${PWD}/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt" -c '{"function":"CreateAsset","Args":["asset66", "yellow", "6", "Tom", "130660"]}'
```

![截屏2023-11-09 19.01.19](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-09 19.01.19.png)

## （二）查询通道账本中的资产列

```bash
$ peer chaincode query -C mychannel -n basic -c '{"Args":["GetAllAssets"]}'
```

可以看到我们存入的Tom的那一列已经被查询出来了：

![截屏2023-11-09 19.02.07](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-09 19.02.07.png)

## （三）访问 CouchDb

```bash
192.168.31.181:5984/_utils
```

访问couchdb，可以看到已经存入了值 
⚠️注：用户名和密码一般默认是: admin和adminpw

![截屏2023-11-09 19.09.05](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-09 19.09.05.png)

![截屏2023-11-09 19.09.20](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-09 19.09.20.png)

## （四）整合Gin框架并访问账本数据进行读写操作

![截屏2023-11-09 19.12.25](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-09 19.12.25.png)

![截屏2023-11-09 19.15.43](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-09 19.15.43.png)

接下来，我们需要编写一个主程序main.go，以实现数据查询功能

```go
package main
 
import (
	"bytes"
	"crypto/x509"
	"encoding/json"
	"fmt"
	"github.com/gin-gonic/gin"
	"github.com/hyperledger/fabric-gateway/pkg/client"
	"github.com/hyperledger/fabric-gateway/pkg/identity"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials"
	"io/ioutil"
	"path"
	"time"
)
 
const (
	mspID         = "Org1MSP"
	cryptoPath    = "./peerOrganizations/org1.example.com"
	certPath      = cryptoPath + "/users/User1@org1.example.com/msp/signcerts/cert.pem"
	keyPath       = cryptoPath + "/users/User1@org1.example.com/msp/keystore/"
	tlsCertPath   = cryptoPath + "/peers/peer0.org1.example.com/tls/ca.crt"
	peerEndpoint  = "192.168.136.130:7051"
	gatewayPeer   = "peer0.org1.example.com"
	channelName   = "mychannel"
	chaincodeName = "basic"
)
 
type Asset struct {
	AppraisedValue int    `form:"appraisedValue" json:"appraisedValue" `
	Color          string `form:"color" json:"color"`
	ID             string `form:"id" json:"id"`
	Owner          string `form:"owner" json:"owner"`
	Size           int    `form:"size" json:"size"`
}
 
func main() {
	// The gRPC client connection should be shared by all Gateway connections to this endpoint
	clientConnection := newGrpcConnection()
	defer clientConnection.Close()
 
	id := newIdentity()
	sign := newSign()
 
	// Create a Gateway connection for a specific client identity
	gateway, err := client.Connect(
		id,
		client.WithSign(sign),
		client.WithClientConnection(clientConnection),
		// Default timeouts for different gRPC calls
		client.WithEvaluateTimeout(5*time.Second),
		client.WithEndorseTimeout(15*time.Second),
		client.WithSubmitTimeout(5*time.Second),
		client.WithCommitStatusTimeout(1*time.Minute),
	)
	if err != nil {
		panic(err)
	}
	defer gateway.Close()
	network := gateway.GetNetwork(channelName)
	contract := network.GetContract(chaincodeName)
 
	r := gin.Default()
	r1 := r.Group("/fabric2.4")
	r1.POST("/CreateAsset", func(c *gin.Context) {
		var asset Asset
		c.ShouldBind(&asset)
		c.JSON(200, asset)
		marshal, _ := json.Marshal(asset)
		fmt.Println(string(marshal))
		fmt.Println("asset:", asset)
	})
	r1.POST("/GetAllAssets", func(c *gin.Context) {
		result := getAllAssets(contract)
		c.JSON(200, result)
	})
	r.Run(":8080") // 监听并在 0.0.0.0:8080 上启动服务
 
}
 
// Evaluate a transaction to query ledger state.
func getAllAssets(contract *client.Contract) string {
	fmt.Println("Evaluate Transaction: GetAllAssets, function returns all the current assets on the ledger")
 
	evaluateResult, err := contract.EvaluateTransaction("GetAllAssets")
	if err != nil {
		panic(fmt.Errorf("failed to evaluate transaction: %w", err))
	}
	result := formatJSON(evaluateResult)
 
	fmt.Printf("*** Result:%s\n", result)
 
	return string(evaluateResult)
}
 
// newGrpcConnection creates a gRPC connection to the Gateway server.
func newGrpcConnection() *grpc.ClientConn {
	certificate, err := loadCertificate(tlsCertPath)
	if err != nil {
		panic(err)
	}
 
	certPool := x509.NewCertPool()
	certPool.AddCert(certificate)
	transportCredentials := credentials.NewClientTLSFromCert(certPool, gatewayPeer)
 
	connection, err := grpc.Dial(peerEndpoint, grpc.WithTransportCredentials(transportCredentials))
	if err != nil {
		panic(fmt.Errorf("failed to create gRPC connection: %w", err))
	}
 
	return connection
}
 
// newIdentity creates a client identity for this Gateway connection using an X.509 certificate.
func newIdentity() *identity.X509Identity {
	certificate, err := loadCertificate(certPath)
	if err != nil {
		panic(err)
	}
 
	id, err := identity.NewX509Identity(mspID, certificate)
	if err != nil {
		panic(err)
	}
 
	return id
}
 
func loadCertificate(filename string) (*x509.Certificate, error) {
	certificatePEM, err := ioutil.ReadFile(filename)
	if err != nil {
		return nil, fmt.Errorf("failed to read certificate file: %w", err)
	}
	return identity.CertificateFromPEM(certificatePEM)
}
 
// newSign creates a function that generates a digital signature from a message digest using a private key.
func newSign() identity.Sign {
	files, err := ioutil.ReadDir(keyPath)
	if err != nil {
		panic(fmt.Errorf("failed to read private key directory: %w", err))
	}
	privateKeyPEM, err := ioutil.ReadFile(path.Join(keyPath, files[0].Name()))
 
	if err != nil {
		panic(fmt.Errorf("failed to read private key file: %w", err))
	}
 
	privateKey, err := identity.PrivateKeyFromPEM(privateKeyPEM)
	if err != nil {
		panic(err)
	}
 
	sign, err := identity.NewPrivateKeySign(privateKey)
	if err != nil {
		panic(err)
	}
 
	return sign
}
 
// Format JSON data
func formatJSON(data []byte) string {
	var prettyJSON bytes.Buffer
	if err := json.Indent(&prettyJSON, data, " ", ""); err != nil {
		panic(fmt.Errorf("failed to parse JSON: %w", err))
	}
	return prettyJSON.String()
}
```

⚠️注意：代码中的ip等配置信息需要根据自己的虚拟机进行修改

![截屏2023-11-10 17.09.17](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-10 17.09.17.png)

## （五）修改配置信息

```bash
const (
  mspID         = "Org1MSP"
  cryptoPath    = "./peerOrganizations/org1.example.com" 
  certPath      = cryptoPath +
"/users/User1@org1.example.com/msp/signcerts/cert.pem"
  keyPath       = cryptoPath + "/users/User1@org1.example.com/msp/keystore/" 
  tlsCertPath   = cryptoPath + "/peers/peer0.org1.example.com/tls/ca.crt"
  peerEndpoint  = "10.37.129.254" // 修改成服务器IP地址或者自己虚拟机里面的IP地 
址
  gatewayPeer   = "peer0.org1.example.com" 
  channelName   = "mychannel"
  chaincodeName = "basic" 
)
```

启动 go 项目，运行main.go之后可以看到后端已经查询到初始化的资产信息：

![截屏2023-11-09 19.20.18](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-09 19.20.18.png)

接下来在fabric网络中查询加入的信息：

获取所有资产信息 localhost:8090/fabric/GetAllAssets：

![截屏2023-11-09 19.31.15](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-09 19.31.15.png)

创建资产 localhost:8090/fabric/CreateAsset：

![截屏2023-11-09 19.34.45](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-09 19.34.45.png)

再次查询，可以查询到上一步创建的资产信息了：

![截屏2023-11-09 19.35.41](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-09 19.35.41.png)

访问 CouchDb，添加的资产信息已经上链，数据成功上链（即刚刚添加的12345）：

![截屏2023-11-09 19.37.01](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-09 19.37.01.png)

# 四、实验结束操作

运行完毕之后，进入test- network文件夹删除测试网络的所有节点，并删除创建的任何账本数据，以便于进行后续实验：

```bash
./network.sh down
```

![截屏2023-11-05 10.39.00](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-05 10.39.00.png)

# 五、实验报错与解决方案

**1.无法安装Gin**

![截屏2023-11-09 16.32.23](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-09 16.32.23.png)

**解决方案：**

首先打开终端配置开启mod

```bash
 go env -w GO111MODULE=on
```

由于get命令不能在模块外执行，因此我们需要到fabric目录中执行命令

![截屏2023-11-09 16.45.12](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-11-09 16.45.12.png)

# 六、实验心得与总结

本周我学习了Hyperledger Fabric 2.5、Gin以及Gateway与读取/写入账本数据相关的内容。通过这个实验，我深入了解了Hyperledger Fabric的高性能和可扩展性，同时学习了使用Gin来编写智能合约，并使用Gateway来与外部客户端通信。以下是我的实验心得体会：

首先，通过学习Hyperledger Fabric 2.5，我了解了它的架构、组件以及如何使用它来创建和管理联盟链。其中，令我印象深刻的是Hyperledger Fabric的模块化和可扩展性，这使得它能够适应不同的业务场景。此外，Hyperledger Fabric的安全性和隐私保护也让我对区块链技术有了更深入的认识。

在学习Gin的过程中，我了解到它是一个用于编写智能合约的Go语言框架。通过使用Gin，我们可以轻松地创建智能合约，并实现复杂的业务逻辑。此外，Gin还提供了许多有用的工具和库，例如Ledger和Crypto，这些工具和库可以帮助我们更好地处理账本数据。

在关于Gateway的学习中，我了解了它如何作为Hyperledger Fabric与外部客户端通信的桥梁。通过使用Gateway，我们可以轻松地从外部应用程序访问Hyperledger Fabric上的数据和交易。此外，Gateway还提供了许多有用的功能，例如身份验证、安全性和流量控制。

在实验过程中，我遇到了一些困难和挑战，也有很多需要我注意的地方。例如老师每周都会强调一遍的版本问题，虽然我的版本没问题，但也经历过上学期做大数据项目版本不匹配的痛苦，所以这学期才更加小心，还有，在使用Gin编写智能合约时，我遇到了一个问题，即在处理账本数据时无法正确读取和写入数据。经过仔细检查代码和文档，我发现原来是我对Gin的API理解不够深入。此外，在使用Gateway与外部客户端通信时，我也遇到了一个问题，即无法正确配置Gateway来处理HTTP请求。经过一番调试和查阅文档，我发现原来是我对Gateway的配置过程理解不够准确。总而言之，可能这几次试验碰到的问题并没有体现在报错上，但是并不代表整个试验就像报告过程一样一帆风顺。但能从问题中学到点东西，也算是件好事吧。

通过这次实验，我学到了很多有关Hyperledger Fabric、Gin和Gateway的知识。我不仅深入了解了Hyperledger Fabric的架构和组件，还学会了如何使用Gin编写智能合约和处理账本数据。此外，我也掌握了如何使用Gateway与外部客户端通信并访问Hyperledger Fabric上的数据。

对于未来的学习和工作，我将继续深入研究Hyperledger Fabric、Gin和Gateway的相关内容。我希望能够更好地掌握这些技术，并将它们应用到实际项目中。同时，我也希望能够与其他开发者一起探讨和学习更多有关区块链技术的知识和应用场景。

总之，这次实验让我对Hyperledger Fabric、Gin和Gateway有了更深入的了解和应用体验。我相信这些知识和经验将对我的未来学习和工作产生积极的影响。
