 <img src="/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-08-31 09.48.04.png" alt="截屏2023-08-31 09.48.04" style="zoom:60%;" />

| **报告名称**：   | 实验三：     |
| ---------------- | ------------ |
| **学生姓名：**   | 杨超然       |
| **学生学号：**   | 202106060220 |
| **专业班级：**   | 信管2101班   |
| **学**  **院：** | 工商管理学院 |
| **指导老师：**   | 周中定       |
| **日  期：**     | 2023.9.28    |

------

[TOC]



------

# 一、Docker初探

参考：Docker菜鸟教程

## （一）Docker概述

![截屏2023-09-28 22.20.53](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-28 22.20.53.png)

Docker 是一个开源的应用容器引擎，基于[Go 语言](https://www.runoob.com/go/go-tutorial.html)并遵从 Apache2.0 协议开源。
Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。
容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。
Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版）  和 EE（Enterprise Edition: 企业版），我们用社区版就可以了。

### 1.Docker的应用场景

- Web 应用的自动化打包和发布。
- 自动化测试和持续集成、发布。
- 在服务型环境中部署和调整数据库或其他的后台应用。
- 从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。

------

### 2.Docker 的优点

Docker 是一个用于开发，交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，您可以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。

**2.1快速，一致地交付您的应用程序**

Docker 允许开发人员使用您提供的应用程序或服务的本地容器在标准化环境中工作，从而简化了开发的生命周期。

容器非常适合持续集成和持续交付（CI / CD）工作流程，请考虑以下示例方案：

- 您的开发人员在本地编写代码，并使用 Docker 容器与同事共享他们的工作。
- 他们使用 Docker 将其应用程序推送到测试环境中，并执行自动或手动测试。
- 当开发人员发现错误时，他们可以在开发环境中对其进行修复，然后将其重新部署到测试环境中，以进行测试和验证。
- 测试完成后，将修补程序推送给生产环境，就像将更新的镜像推送到生产环境一样简单。

**2.2响应式部署和扩展**

Docker 是基于容器的平台，允许高度可移植的工作负载。Docker 容器可以在开发人员的本机上，数据中心的物理或虚拟机上，云服务上或混合环境中运行。

Docker 的可移植性和轻量级的特性，还可以使您轻松地完成动态管理的工作负担，并根据业务需求指示，实时扩展或拆除应用程序和服务。

**2.3在同一硬件上运行更多工作负载**

Docker 轻巧快速。它为基于虚拟机管理程序的虚拟机提供了可行、经济、高效的替代方案，因此您可以利用更多的计算能力来实现业务目标。Docker 非常适合于高密度环境以及中小型部署，而您可以用更少的资源做更多的事情。

------

### 3.相关链接

Docker 官网：[https://www.docker.com](https://www.docker.com/)

Github Docker 源码：https://github.com/docker/docker-ce

------



## （二）Docker架构

Docker 包括三个基本概念:

- **镜像（Image）**：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。
- **容器（Container）**：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。
- **仓库（Repository）**：仓库可看成一个代码控制中心，用来保存镜像。

Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。

Docker 容器通过 Docker 镜像来创建。

容器与镜像的关系类似于面向对象编程中的对象与类。

| Docker | 面向对象 |
| :----- | :------- |
| 容器   | 对象     |
| 镜像   | 类       |

![img](https://www.runoob.com/wp-content/uploads/2016/04/576507-docker1.png)

| 概念                   | 说明                                                         |
| :--------------------- | :----------------------------------------------------------- |
| Docker 镜像(Images)    | Docker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。  |
| Docker 容器(Container) | 容器是独立运行的一个或一组应用，是镜像运行时的实体。         |
| Docker 客户端(Client)  | Docker 客户端通过命令行或者其他工具使用 Docker SDK (https://docs.docker.com/develop/sdk/) 与 Docker 的守护进程通信。 |
| Docker 主机(Host)      | 一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。       |
| Docker Registry        | Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub([https://hub.docker.com](https://hub.docker.com/)) 提供了庞大的镜像集合供使用。一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 **<仓库名>:<标签>** 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 **latest** 作为默认标签。 |
| Docker Machine         | Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。 |

## （三）Docker安装

### 1.Ubuntu Docker安装

Docker Engine-Community 支持以下的 Ubuntu 版本：

- Xenial 16.04 (LTS)
- Bionic 18.04 (LTS)
- Cosmic 18.10
- Disco 19.04
- 其他更新的版本……

Docker Engine - Community 支持上 x86_64（或 amd64）armhf，arm64，s390x （IBM Z），和 ppc64le（IBM的Power）架构。

------



#### 手动安装

##### 卸载旧版本

Docker 的旧版本被称为 docker，docker.io 或 docker-engine 。如果已安装，请卸载它们：

```shell
$ sudo apt-get remove docker docker-engine docker.io containerd runc
```

当前称为 Docker Engine-Community 软件包 docker-ce 。

安装 Docker Engine-Community，以下介绍两种方式。

##### 使用 Docker 仓库进行安装

在新主机上首次安装 Docker Engine-Community 之前，需要设置 Docker 仓库。之后，您可以从仓库安装和更新 Docker 。

##### 设置仓库

更新 apt 包索引。

```
$ sudo apt-get update
```

![截屏2023-09-28 22.48.05](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-28 22.48.05.png)

安装 apt 依赖包，用于通过HTTPS来获取仓库:

```shell
$ sudo apt-get install \
  apt-transport-https \
  ca-certificates \
  curl \
  gnupg-agent \
  software-properties-common
```

![截屏2023-09-29 08.25.04](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 08.25.04.png)

![截屏2023-09-29 08.25.33](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 08.25.33.png)

添加 Docker 的官方 GPG 密钥：

```shell
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
```

![截屏2023-09-29 08.28.43](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 08.28.43.png)

9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88 通过搜索指纹的后8个字符，验证您现在是否拥有带有指纹的密钥。

```shell
$ sudo apt-key fingerprint 0EBFCD88
   
pub   rsa4096 2017-02-22 [SCEA]
      9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88
uid   [ unknown] Docker Release (CE deb) <docker@docker.com>
sub   rsa4096 2017-02-22 [S]
```

![截屏2023-09-29 08.29.56](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 08.29.56.png)

使用以下指令设置稳定版仓库（笔者用的是ARM架构，因此需要把amd64改写为arm64）

```shell
$ sudo add-apt-repository \
   "deb [arch=arm64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/ \
  $(lsb_release -cs) \
  stable"
```

![截屏2023-09-29 08.33.46](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 08.33.46.png)

##### 安装 Docker Engine-Community

更新 apt 包索引。

```shell
$ sudo apt-get update
```

安装最新版本的 Docker Engine-Community 和 containerd ，或者转到下一步安装特定版本：

```shell
$ sudo apt-get install docker-ce docker-ce-cli containerd.io
```

![截屏2023-09-29 08.36.47](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 08.36.47.png)

测试 Docker 是否安装成功，输入以下指令，打印出以下信息则安装成功:

```shell
$ sudo docker run hello-world

Unable to find image 'hello-world:latest' locally
latest: Pulling from library/hello-world
1b930d010525: Pull complete                                                                                                                                  Digest: sha256:c3b4ada4687bbaa170745b3e4dd8ac3f194ca95b2d0518b417fb47e5879d9b5f
Status: Downloaded newer image for hello-world:latest


Hello from Docker!
This message shows that your installation appears to be working correctly.


To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.


To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash


Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/


For more examples and ideas, visit:
 https://docs.docker.com/get-started/
```

![截屏2023-09-29 08.39.41](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 08.39.41.png)

------



#### 卸载 docker

删除安装包：

```
sudo apt-get purge docker-ce
```

删除镜像、容器、配置文件等内容：

```
sudo rm -rf /var/lib/docker
```

## （四）Docker镜像加速

### 1.镜像挂载

国内从 DockerHub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务，例如：

- 科大镜像：**https://docker.mirrors.ustc.edu.cn/**
- 网易：**https://hub-mirror.c.163.com/**
- 阿里云：**https://<你的ID>.mirror.aliyuncs.com**
- 七牛云加速器：**https://reg-mirror.qiniu.com**

当配置某一个加速器地址之后，若发现拉取不到镜像，请切换到另一个加速器地址。国内各大云服务商均提供了 Docker 镜像加速服务，建议根据运行 Docker 的云平台选择对应的镜像加速服务。

阿里云镜像获取地址：https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors，登陆后，左侧菜单选中镜像加速器就可以看到你的专属地址了

------

对于使用 systemd 的系统（Ubuntu16.04+、Debian8+、CentOS7），请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）：

```shell
{"registry-mirrors":["https://reg-mirror.qiniu.com"]}
```

![截屏2023-09-29 09.12.16](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 09.12.16.png)

之后重新启动服务：

```shell
sudo systemctl daemon-reload
sudo systemctl restart docker
```

------



### 2.检查加速器是否生效

检查加速器是否生效配置加速器之后，如果拉取镜像仍然十分缓慢，请手动检查加速器配置是否生效，在命令行执行 **docker info**，如果从结果中看到了如下内容，说明配置成功。

```shell
$ docker info
Registry Mirrors:
    https://reg-mirror.qiniu.com
```

![截屏2023-09-29 09.33.10](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 09.33.10.png)

------

## （五）Docker使用

### 1.Docker Hello World

Docker 允许你在容器内运行应用程序， 使用 **docker run** 命令来在容器内运行一个应用程序。输出Hello world

```shell
docker run ubuntu:22.04 /bin/echo "Hello world"
```

各个参数解析：

- **docker:** Docker 的二进制执行文件。
- **run:** 与前面的 docker 组合来运行一个容器。
- **ubuntu:22.04** 指定要运行的镜像，Docker 首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。
- **/bin/echo "Hello world":** 在启动的容器里执行的命令

以上命令完整的意思可以解释为：Docker 以 ubuntu15.10 镜像创建一个新容器，然后在容器里执行 bin/echo "Hello world"，然后输出结果。

(如下结果就是在本地主机上没找到ubuntu22.04，自动下载了公共镜像，然后运行出了hello world)

![截屏2023-09-29 09.38.28](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 09.38.28.png)

### 2.运行交互式容器

我们通过 docker 的两个参数 -i -t，让 docker 运行的容器实现**"对话"**的能力：

```shell
docker run -i -t ubuntu:22.04 /bin/bash
root@fec5fda7590d:/# 
```

各个参数解析：

- **-t:** 在新容器内指定一个伪终端或终端。
- **-i:** 允许你对容器内的标准输入 (STDIN) 进行交互。

![截屏2023-09-29 09.44.22](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 09.44.22.png)

注意第二行 **root@fec5fda7590d:/#**，此时我们已进入一个 ubuntu22.04 系统的容器

我们尝试在容器中运行命令 **cat /proc/version**和**ls**分别查看当前系统的版本信息和当前目录下的文件列表：

![截屏2023-09-29 09.46.52](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 09.46.52.png)

我们可以通过运行 exit 命令或者使用 CTRL+D 来退出容器。

```shell
root@0123ce188bd8:/#  exit
exit
```

![截屏2023-09-29 09.47.58](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 09.47.58.png)

### 3.启动容器（后台模式）

使用以下命令创建一个以进程方式运行的容器：

```shell
docker run -d ubuntu:22.04 /bin/sh -c "while true; do echo hello world; sleep 1; done"
```

![截屏2023-09-29 09.53.42](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 09.53.42.png)

在输出中，我们没有看到期望的 "hello world"，而是一串长字符

**08c034b97650f364877882133fa4dd7df20794f3c49d99be6a55d20a18f2d93a**

这个长字符串叫做容器 ID，对每个容器来说都是唯一的，我们可以通过容器 ID 来查看对应的容器发生了什么。

首先，我们需要确认容器有在运行，可以通过 **docker ps** 来查看：

![截屏2023-09-29 09.54.55](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 09.54.55.png)

输出详情介绍：

**CONTAINER ID:** 容器 ID。

**IMAGE:** 使用的镜像。

**COMMAND:** 启动容器时运行的命令。

**CREATED:** 容器的创建时间。

**STATUS:** 容器状态。

状态有7种：

- created（已创建）
- restarting（重启中）
- running 或 Up（运行中）
- removing（迁移中）
- paused（暂停）
- exited（停止）
- dead（死亡）

**PORTS:** 容器的端口信息和使用的连接类型（tcp\udp）。

**NAMES:** 自动分配的容器名称。

在宿主主机内使用 **docker logs** 命令，查看容器内的标准输出：

```shell
docker logs 08c034b97650
```

![截屏2023-09-29 09.57.24](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 09.57.24.png)

### 4.停止容器

我们使用 **docker stop** 命令来停止容器:

![截屏2023-09-29 10.03.24](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 10.03.24.png)

通过 **docker ps** 查看，容器已经停止工作:

```shell
docker ps
```

![截屏2023-09-29 10.03.56](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 10.03.56.png)

## （六）Docker容器使用

### 1.Docker 客户端

docker 客户端非常简单 ,我们可以直接输入 docker 命令来查看到 Docker 客户端的所有命令选项。

```shell
docker
```

![截屏2023-09-29 16.05.17](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 16.05.17.png)

可以通过命令 **docker command --help** 更深入的了解指定的 Docker 命令使用方法。

例如我们要查看 **docker stats** 指令的具体使用方法：

```shell
docker stats --help
```

![截屏2023-09-29 16.06.24](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 16.06.24.png)

### 2.容器使用

#### 2.1获取镜像

如果我们本地没有 ubuntu 镜像，我们可以使用 docker pull 命令来载入 ubuntu 镜像：

```shell
docker pull ubuntu
```

![截屏2023-09-29 16.11.21](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 16.11.21.png)

#### 2.2启动容器

以下命令使用 ubuntu 镜像启动一个容器，参数为以命令行模式进入该容器：

```shell
docker run -it ubuntu /bin/bash
```

![截屏2023-09-29 16.12.01](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 16.12.01.png)

参数说明：

- **-i**: 交互式操作。
- **-t**: 终端。
- **ubuntu**: ubuntu 镜像。
- **/bin/bash**：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。

要退出终端，直接输入 **exit**:

![截屏2023-09-29 16.12.32](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 16.12.32.png)

#### 2.3启动已停止运行的容器

查看所有的容器命令如下：

```shell
docker ps -a
```

![截屏2023-09-29 16.13.43](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 16.13.43.png)

使用 docker start 启动一个已停止的容器：

```shell
docker start 571aebea3b32
```

#### 2.4后台运行

在大部分的场景下，我们希望 docker 的服务是在后台运行的，我们可以过 **-d** 指定容器的运行模式。

```shell
docker run -itd --name ubuntu-test ubuntu /bin/bash
```

![截屏2023-09-29 16.16.29](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 16.16.29.png)

![截屏2023-09-29 16.20.39](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 16.20.39.png)

**注：**加了 **-d** 参数默认不会进入容器，想要进入容器需要使用指令 **docker exec**（下面会介绍到）。

#### 2.5停止一个容器

停止容器的命令如下：

```shell
docker stop <容器 ID>
```

停止的容器可以通过 docker restart 重启：

```shell
docker restart <容器 ID>
```

#### 2.6进入容器

在使用 **-d** 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：

- **docker attach**
- **docker exec**：推荐大家使用 docker exec 命令，因为此命令会退出容器终端，但不会导致容器的停止。

**attach 命令**

下面演示了使用 docker attach 命令。

```shell
docker attach 1e560fca3906 
```

![img](https://www.runoob.com/wp-content/uploads/2016/05/docker-attach.png)

**注意：** 如果从这个容器退出，会导致容器的停止。

**exec 命令**

下面演示了使用 docker exec 命令。

```shell
docker exec -it 243c32535da7 /bin/bash
```

[![img](https://www.runoob.com/wp-content/uploads/2016/05/docker-exec.png)](https://www.runoob.com/wp-content/uploads/2016/05/docker-exec.png)

**注意：** 如果从这个容器退出，容器不会停止，这就是为什么推荐大家使用 **docker exec** 的原因。

更多参数说明请使用 **docker exec --help** 命令查看。

#### 2.7导入和导出容器

如果要导出本地某个容器，可以使用 **docker export** 命令。

```shell
docker export 1e560fca3906 > ubuntu.tar
```

导出容器 1e560fca3906 快照到本地文件 ubuntu.tar。

[![img](https://www.runoob.com/wp-content/uploads/2016/05/docker-export.png)](https://www.runoob.com/wp-content/uploads/2016/05/docker-export.png)

这样将导出容器快照到本地文件。

**导入容器快照**

可以使用 docker import 从容器快照文件中再导入为镜像，以下实例将快照文件 ubuntu.tar 导入到镜像 test/ubuntu:v1:

```shell
cat docker/ubuntu.tar | docker import - test/ubuntu:v1
```

[![img](https://www.runoob.com/wp-content/uploads/2016/05/docker-import.png)](https://www.runoob.com/wp-content/uploads/2016/05/docker-import.png)

此外，也可以通过指定 URL 或者某个目录来导入，例如：

```shell
docker import http://example.com/exampleimage.tgz example/imagerepo
```

#### 2.8删除容器

删除容器使用 **docker rm** 命令，如：

```shell
docker rm -f 1e560fca3906
```

或者输入如下命令，清理掉所有处于终止状态的容器。

```shell
docker container prune
```

![截屏2023-09-29 19.52.22](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 19.52.22.png)

### 3.运行一个web应用

前面我们运行的容器并没有一些什么特别的用处。

接下来让我们尝试使用 docker 构建一个 web 应用程序。

我们将在docker容器中运行一个 Python Flask 应用来运行一个web应用。

```bash
docker pull training/webapp  # 载入镜像
docker run -d -P training/webapp python app.py
```

![截屏2023-09-29 19.54.33](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 19.54.33.png)

![截屏2023-09-29 20.05.52](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 20.05.52.png)

参数说明:

- **-d:**让容器在后台运行。
- **-P:**将容器内部使用的网络端口随机映射到我们使用的主机上。

注：由于training/webapp并不支持arm64架构，所以需要安装QEMU模拟运行（安装过程见报错四）

![截屏2023-09-29 20.34.28](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 20.34.28.png)

#### 3.1查看 WEB 应用容器

使用 docker ps 来查看我们正在运行的容器：

![截屏2023-09-30 11.30.39](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-30 11.30.39.png)

可以看到多出了PORTS一栏，即端口信息

```bash
PORTS
0.0.0.0:32768->5000/tcp
```

意思是Docker 开放了 5000 端口（默认 Python Flask 端口）映射到主机端口 327698上。这时我们就可以通过浏览器来访问WEB应用

![截屏2023-09-30 11.38.06](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-30 11.38.06.png)

我们也可以通过 -p 参数来设置不一样的端口：

```bash
docker run -d -p 5000:5000 training/webapp python app.py
```

![截屏2023-09-30 11.41.09](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-30 11.41.09.png)

**docker ps**查看正在运行的容器，可以看到容器内部的 5000 端口映射到我们本地主机的 5000 端口上。

![截屏2023-09-30 11.41.57](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-30 11.41.57.png)

#### 3.2网络端口的快捷方式

通过 **docker ps** 命令可以查看到容器的端口映射，**docker** 还提供了另一个快捷方式 **docker port**，使用 **docker port** 可以查看指定 （ID 或者名字）容器的某个确定端口映射到宿主机的端口号。

上面我们创建的 web 应用容器 ID 为 **6a42987f8ad8** 名字为 **epic_pasteur**。

我可以使用 **docker port 6a42987f8ad8** 或 **docker port epic_pasteur** 来查看容器端口的映射情况：

```bash
docker port 6a42987f8ad8
docker port epic_pasteur
```

![截屏2023-09-30 16.18.11](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-30 16.18.11.png)

#### 3.3查看 WEB 应用程序日志

docker logs [ID或者名字] 可以查看容器内部的标准输出,以笔者创建的id为例：

```bash
docker logs -f 6a42987f8ad8
```

![截屏2023-09-30 16.30.30](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-30 16.30.30.png)

**-f:** 让 **docker logs** 像使用 **tail -f** 一样来输出容器内部的标准输出。

从上面，我们可以看到应用程序使用的是 5000 端口并且能够查看到应用程序的访问日志。

#### 3.4查看WEB应用程序容器的进程

我们还可以使用 docker top 来查看容器内部运行的进程:

```bash
docker top 6a42987f8ad8
```

![截屏2023-09-30 16.32.50](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-30 16.32.50.png)

#### 3.5检查 WEB 应用程序

使用 **docker inspect** 来查看 Docker 的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息：

```bash
docker inspect 6a42987f8ad8
```

![截屏2023-09-30 16.34.26](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-30 16.34.26.png)

#### 3.6停止、重启与移除WEB容器

还是以前面创建的epic_pasteur为例，停止、重启与移除web容器的队应命令如下：

```bash
# 停止WEB应用容器
docker stop epic_pasteur
# 重启WEB应用容器
docker start epic_pasteur
# 查询最后一次创建的容器
docker ps -l
# 重启正在运行的容器
docker restart epic_pasteur
# 移除WEB应用容器
docker rm epic_pasteur
```

注：删除容器时，该容器必须是停止状态，否则会报下面的错误：

```bash
Error response from daemon: You cannot remove a running container bf08b7f2cd897b5964943134aa6d373e355c286db9b9885b1f60b6e8f82b2b85. Stop the container before attempting removal or force remove
```

![截屏2023-09-30 16.42.43](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-30 16.42.43.png)

## （七）Docker镜像使用

当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。

------



### 1.列出镜像列表

我们可以使用 **docker images** 来列出本地主机上的镜像：

![截屏2023-09-29 20.55.10](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 20.55.10.png)

各个选项说明:

- **REPOSITORY：**表示镜像的仓库源
- **TAG：**镜像的标签
- **IMAGE ID：**镜像ID
- **CREATED：**镜像创建时间
- **SIZE：**镜像大小

同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。

所以，我们如果要使用版本为22.04的ubuntu系统镜像来运行容器时，命令如下：

```bash
docker run -t -i ubuntu:22.04 /bin/bash
```

参数说明：

- **-i**: 交互式操作。
- **-t**: 终端。
- **ubuntu:22.04**: 这是指用 ubuntu 22.04 版本镜像为基础来启动容器。
- **/bin/bash**：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。

如果要使用版本为 15.10 的 ubuntu 系统镜像来运行容器时，命令如下：

```bash
docker run -t -i ubuntu:15.10 /bin/bash 
```

如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像。

### 2.获取一个新的镜像

当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。

下载完成后，我们可以直接使用这个镜像来运行容器。例如：

```bash
docker pull ubuntu:13.10
```

### 3.查找镜像

我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： **https://hub.docker.com/**

我们也可以使用 docker search 命令来搜索镜像。比如我们需要一个 httpd 的镜像来作为我们的 web 服务。我们可以通过 docker search 命令搜索 httpd 来寻找适合我们的镜像。

```bash
docker search httpd
```

![截屏2023-09-29 21.19.55](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 21.19.55.png)

相关参数的解释如下：

**NAME:** 镜像仓库源的名称

**DESCRIPTION:** 镜像的描述

**OFFICIAL:** 是否 docker 官方发布

**stars:** 类似 Github 里面的 star，表示点赞、喜欢的意思。

**AUTOMATED:** 自动构建。

### 4.拖取镜像

我们决定使用上图中的 httpd 官方版本的镜像，使用命令 docker pull 来下载镜像

```bash
docker pull hpptd
```

下载完成后，我们就可以使用这个镜像了

```bash
docker run hpptd
```

### 5.删除镜像

镜像删除使用 **docker rmi** 命令，比如我们删除 hello-world 镜像：

```bash
docker rmi hello-world
```

![截屏2023-09-29 21.47.10](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 21.47.10.png)

### 6.创建镜像

当我们从 docker 镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改。

- 1、从已经创建的容器中更新镜像，并且提交这个镜像
- 2、使用 Dockerfile 指令来创建一个新的镜像

（docker镜像仓库中下载的镜像暂时都能满足，暂时不用创建镜像）

### 7.更新镜像

更新镜像之前，我们需要使用镜像来创建一个容器：

```bash
docker run -t -i ubuntu:22.04 /bin/bash
```

在运行的容器内使用 **apt-get update** 命令进行更新。

![截屏2023-09-29 22.00.54](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 22.00.54.png)

在完成操作之后，输入 exit 命令来退出这个容器。

此时 ID 为4f555e0ad70a的容器，是按我们的需求更改的容器。我们可以通过命令 docker commit 来提交容器副本：

```bash
docker commit -m="has update" -a="cr" 4f555e0ad70a cr/ubuntu:v2
```

各个参数说明：

- **-m:** 提交的描述信息
- **-a:** 指定镜像作者
- **4f555e0ad70a：**容器 ID
- **cr/ubuntu:v2:** 指定要创建的目标镜像名

![截屏2023-09-29 22.03.53](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 22.03.53.png)

我们可以使用 **docker images** 命令来查看我们的新镜像 **cr/ubuntu:v2**：

![截屏2023-09-29 22.05.02](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 22.05.02.png)

同样的，输入类似的命令，使用我们的新镜像 **cr/ubuntu** 来启动一个容器:

```bash
docker run -t -i cr/ubuntu:v2 /bin/bash
```

![截屏2023-09-29 22.07.07](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 22.07.07.png)

### 8.构建镜像

我们使用命令 **docker build** ， 从零开始来创建一个新的镜像。为此，我们需要创建一个 Dockerfile 文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像。

```bash
runoob@runoob:~$ cat Dockerfile 
FROM    centos:6.7
MAINTAINER      Fisher "fisher@sudops.com"

RUN     /bin/echo 'root:123456' |chpasswd
RUN     useradd runoob
RUN     /bin/echo 'runoob:123456' |chpasswd
RUN     /bin/echo -e "LANG=\"en_US.UTF-8\"" >/etc/default/local
EXPOSE  22
EXPOSE  80
CMD     /usr/sbin/sshd -D
```

每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。

第一条FROM，指定使用哪个镜像源

RUN 指令告诉docker 在镜像内执行命令，安装了什么。。。

然后，我们使用 Dockerfile 文件，通过 docker build 命令来构建一个镜像。

```bash
runoob@runoob:~$ docker build -t runoob/centos:6.7 .
Sending build context to Docker daemon 17.92 kB
Step 1 : FROM centos:6.7
 ---&gt; d95b5ca17cc3
Step 2 : MAINTAINER Fisher "fisher@sudops.com"
 ---&gt; Using cache
 ---&gt; 0c92299c6f03
Step 3 : RUN /bin/echo 'root:123456' |chpasswd
 ---&gt; Using cache
 ---&gt; 0397ce2fbd0a
Step 4 : RUN useradd runoob
......
```

参数说明：

- **-t** ：指定要创建的目标镜像名
- **.** ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径

创建完毕后，可以头通过docker images查看已经存在的镜像

![截屏2023-09-30 11.05.17](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-30 11.05.17.png)

### 9.设置镜像标签

可以使用 docker tag 命令，为镜像添加一个新的标签。

```bash
docker tag 860c279d2fec runoob/centos:dev
```

格式说明如下：

docker tag  镜像ID（这里是 860c279d2fec） 镜像源名(repository name)：新的标签名(tag)。

## （八）Docker 容器连接

前面我们实现了通过网络端口来访问运行在 docker 容器内的服务。

容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 **-P** 或 **-p** 参数来指定端口映射。

下面我们来实现通过端口连接到一个 docker 容器。

------

### 1.网络端口映射

首先，输入如下命令创建一个python应用容器：

```bash
docker run -d -P training/webapp python app.py
```

我们使用 **-P** 绑定端口号，使用 **docker ps** 可以看到容器端口 5000 绑定主机端口 32768。

另外，我们可以指定容器绑定的网络地址，比如绑定 127.0.0.1。

![截屏2023-09-30 17.01.26](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-30 17.01.26.png)

我们也可以使用 **-p** 标识来指定容器端口绑定到主机端口。

两种方式的区别是:

- **-P :**是容器内部端口**随机**映射到主机的端口。
- **-p :** 是容器内部端口绑定到**指定**的主机端口。

```bash
docker run -d -p 5000:5000 training/webapp python app.py
docker ps
```

![截屏2023-09-30 17.03.10](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-30 17.03.10.png)

另外，我们可以指定容器绑定的网络地址，在笔者的虚拟机网络配置中，ip地址为10.211.55.8，因此可以通过如下命令绑定该ip：

```bash
docker run -d -p 10.211.55.8:5001:5000 training/webapp python app.py
docker ps
```

![截屏2023-09-30 17.06.46](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-30 17.06.46.png)

这样我们就可以通过访问 10.211.55.8:5001 来访问容器的 5000 端口:

![截屏2023-09-30 17.07.54](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-30 17.07.54.png)

上面的例子中，默认都是绑定 tcp 端口，如果要绑定 UDP 端口，可以在端口后面加上 **/udp**:

```bash
docker run -d -p 10.211.55.8:5000:5000/udp training/webapp python app.py
docker ps
```

![截屏2023-09-30 17.10.29](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-30 17.10.29.png)

**docker port** 命令可以让我们快捷地查看端口的绑定情况：

```bash
docker port vigilant_wright #这个是上面我们绑定了ip地址的容器
```

![截屏2023-09-30 17.13.10](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-30 17.13.10.png)

### 2.Docker 容器互联

端口映射并不是唯一把 docker 连接到另一个容器的方法。

docker 有一个连接系统允许将多个容器连接在一起，共享连接信息。

docker 连接会创建一个父子关系，其中父容器可以看到子容器的信息。

------

#### 2.1容器命名

当我们创建一个容器的时候，docker 会自动对它进行命名。另外，我们也可以使用 **--name** 标识来命名容器，例如：

```bash
docker run -d -P --name cr training/webapp python app.py
```

创建完成之后，使用docker ps -l查看最近创建的容器：

![截屏2023-09-30 17.16.19](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-30 17.16.19.png)

#### 2.2新建容器

首先创建一个新的Docker网络，并输入docker network ls查看：

```bash
docker network create -d bridge test-net
```

![截屏2023-09-30 17.20.29](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-30 17.20.29.png)

可以看到test-net已经被成功创建

参数说明：

**-d**：参数指定 Docker 网络类型，有 bridge、overlay。

其中 overlay 网络类型用于 Swarm mode，在本小节中可以忽略它。

#### 2.3连接容器

运行一个容器并连接到新建的 test-net 网络:

```bash
docker run -itd --name test1 --network test-net ubuntu /bin/bash
```

打开新的终端，再运行一个容器并加入到 test-net 网络:

```bash
docker run -itd --name test2 --network test-net ubuntu /bin/bash
```

输入docker ps查看新建情况：

![截屏2023-09-30 17.26.07](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-30 17.26.07.png)

下面通过 ping 来证明 test1 容器和 test2 容器建立了互联关系。如果 test1、test2 容器内中无 ping 命令，则在容器内执行以下命令安装 ping（即学即用：可以在一个容器里安装好，提交容器到镜像，在以新的镜像重新运行以上俩个容器）

```bash
apt-get update
apt install iputils-ping
```

在test1 test2容器中输入分别如下命令：

```bash
docker exec -it test1 /bin/bash
root@8eb9c575388a:/#ping test2

docker exec -it test2 /bin/bash
root@9e982e78c920:/#ping test1
```

![截屏2023-09-30 17.33.01](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-30 17.33.01.png)

![截屏2023-09-30 17.35.21](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-30 17.35.21.png)

这样，test1 容器和 test2 容器建立了互联关系。

如果有多个容器之间需要互相连接，推荐使用 Docker Compose。

------

#### 2.4配置 DNS

我们可以在宿主机的 /etc/docker/daemon.json 文件中增加以下内容来设置全部容器的 DNS：

```bash
cd /etc/docker
sudo vim daemon.json
```

增加内容如下：

```bash
{
  "dns" : [
    "114.114.114.114",
    "8.8.8.8"
  ]
}
```

设置后，启动容器的 DNS 会自动配置为 114.114.114.114 和 8.8.8.8。

配置完，需要重启 docker 才能生效。

```bash
sudo systemctl daemon-reload
sudo systemctl restart docker
```

查看容器的 DNS 是否生效可以使用以下命令，它会输出容器的 DNS 信息：

```
$ docker run -it --rm  ubuntu  cat etc/resolv.conf
```

![截屏2023-09-30 21.29.28](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-30 21.29.28.png)

**手动指定容器的配置**

如果只想在指定的容器设置 DNS，则可以使用以下命令：

```bash
docker run -it --rm -h host_ubuntu  --dns=114.114.114.114 --dns-search=test.com ubuntu
```

参数说明：

**--rm**：容器退出时自动清理容器内部的文件系统。

**-h HOSTNAME 或者 --hostname=HOSTNAME**： 设定容器的主机名，它会被写到容器内的 /etc/hostname 和 /etc/hosts。

**--dns=IP_ADDRESS**： 添加 DNS 服务器到容器的 /etc/resolv.conf 中，让容器用这个服务器来解析所有不在 /etc/hosts 中的主机名。

**--dns-search=DOMAIN**： 设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 host.example.com。

![截屏2023-09-30 21.37.43](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-30 21.37.43.png)

如果在容器启动时没有指定 **--dns** 和 **--dns-search**，Docker 会默认用宿主主机上的 /etc/resolv.conf 来配置容器的 DNS。

## （九）Docker 仓库管理

仓库（Repository）是集中存放镜像的地方。以下介绍一下 [Docker Hub](https://hub.docker.com/)。当然不止 docker hub，只是远程的服务商不一样，操作都是一样的。

### 1.DockerHub

目前 Docker 官方维护了一个公共仓库 [Docker Hub](https://hub.docker.com/)。

大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。

#### 1.1注册

在 [https://hub.docker.com](https://hub.docker.com/) 免费注册一个 Docker 账号。

------



#### 1.2登录和退出

登录需要输入用户名和密码，登录成功后，我们就可以从 docker hub 上拉取自己账号下的全部镜像。

```
$ docker login
```

退出 docker hub 可以使用以下命令：

```
$ docker logout
```

**拉取镜像**

你可以通过 docker search 命令来查找官方仓库中的镜像，并利用 docker pull 命令来将它下载到本地。

以 ubuntu 为关键词进行搜索：

```
$ docker search ubuntu
```

使用 docker pull 将官方 ubuntu 镜像下载到本地：

```
$ docker pull ubuntu 
```

#### 推送镜像

用户登录后，可以通过 docker push 命令将自己的镜像推送到 Docker Hub。

以下命令中的 username 请替换为你的 Docker 账号用户名。

```
$ docker tag ubuntu:18.04 username/ubuntu:18.04
$ docker image ls

REPOSITORY      TAG        IMAGE ID            CREATED           ...  
ubuntu          18.04      275d79972a86        6 days ago        ...  
username/ubuntu 18.04      275d79972a86        6 days ago        ...  
$ docker push username/ubuntu:18.04
$ docker search username/ubuntu

NAME             DESCRIPTION       STARS         OFFICIAL    AUTOMATED
username/ubuntu
```

------

## （十）Dockerfile

Dockerfile是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需要的指令和说明

### 1.使用Dockerfile定制镜像

这里仅讲解如何运行 Dockerfile 文件来定制一个镜像，即只要了解一下镜像的构建流程即可，具体Dockerfile文件内的指令详解将在下一节介绍。

#### 1.1定制镜像

**e.g：定制一个 nginx 镜像（构建好的镜像内会有一个 /usr/share/nginx/html/index.html 文件）**

首先在一个空目录下，新建一个名为 Dockerfile 文件：

```bash
# 在docker目录下新建Dockerfile文件
cd /etc/docker
sudo mkdir Dockerfile 
# 接下来使用vim命令编辑Dockerfile
sudo vim Dokerfile
```

在文件中添加如下内容：

```bash
FROM nginx
RUN echo '这是一个本地构建的nginx镜像' > /usr/share/nginx/html/index.html
```

#### 1.2FROM 和 RUN 指令的作用

**FROM**：定制的镜像都是基于 FROM 的镜像，这里的 nginx 就是定制需要的基础镜像。后续的操作都是基于 nginx。

**RUN**：用于执行后面跟着的命令行命令。有以下俩种格式：

shell 格式：

```bash
RUN <命令行命令>
# <命令行命令> 等同于，在终端操作的 shell 命令。
```

exec 格式：

```bash
RUN ["可执行文件", "参数1", "参数2"]
# 例如：
# RUN ["./test.php", "dev", "offline"] 等价于 RUN ./test.php dev offline
```

**注意**：Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大。例如：

FROM centos
RUN **yum** -y **install** **wget**
RUN **wget** -O redis.tar.gz "http://download.redis.io/releases/redis-5.0.3.tar.gz"
RUN **tar** -xvf redis.tar.gz

以上执行会创建 3 层镜像。可简化为以下格式：

FROM centos
RUN **yum** -y **install** **wget** \
  **&&** **wget** -O redis.tar.gz "http://download.redis.io/releases/redis-5.0.3.tar.gz" \
  **&&** **tar** -xvf redis.tar.gz

如上，以 **&&** 符号连接命令，这样执行后，只会创建 1 层镜像。

#### 1.3开始构建镜像

在 Dockerfile 文件的存放目录下，执行构建动作。

以下示例，通过目录下的 Dockerfile 构建一个 nginx:v3（镜像名称:镜像标签）。

```shell
docker build -t nginx:v3 .
```

**注**：最后的 **.** 代表本次执行的上下文路径

若出现如下显示，则说明镜像已经构建成功



------

#### 1.4上下文路径

以1.3中构建镜像的代码为例：

```bash
docker build -t nginx:v3 .
```

**上下文路径：**指的是docker在构建镜像时，有时候会用到本机的文件（如复制），docker build命令得知这个路径之后，会将该路径下的所有内容打包。

**解析：**由于docker的运行模式是C/S(本机为C，docker引擎为S)。实际的构建过程实在docker引擎下完成的，这个时候无法用到我们本机的文件。这就需要我们将本机指定目录下的文件一起打包给docker引擎使用。

**注：**由于上下文路径下的所有文件都会被一起打包发送给docker引擎，因此不要在上下文路径下放置无用的文件，以免造成过程缓慢。

------

#### 1.5指令详解

##### COPY

复制指令，从上下文目录中复制文件或者目录到容器里指定路径。

格式：

```
COPY [--chown=<user>:<group>] <源路径1>...  <目标路径>
COPY [--chown=<user>:<group>] ["<源路径1>",...  "<目标路径>"]
```

**[--chown=<user>:<group>]**：可选参数，用户改变复制到容器内文件的拥有者和属组。

**<源路径>**：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则。例如：

```
COPY hom* /mydir/
COPY hom?.txt /mydir/
```

**<目标路径>**：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。

##### ADD

ADD 指令和 COPY 的使用格类似（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下：

- ADD 的优点：在执行 <源文件> 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 <目标路径>。
- ADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。

##### CMD

类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:

- CMD 在docker run 时运行。
- RUN 是在 docker build。

**作用**：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。

**注意**：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。

格式：

```
CMD <shell 命令> 
CMD ["<可执行文件或命令>","<param1>","<param2>",...] 
CMD ["<param1>","<param2>",...]  # 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数
```

推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是 sh。

##### ENTRYPOINT

类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。

但是, 如果运行 docker run 时使用了 --entrypoint 选项，将覆盖 ENTRYPOINT 指令指定的程序。

**优点**：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。

**注意**：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。

格式：

```
ENTRYPOINT ["<executeable>","<param1>","<param2>",...]
```

可以搭配 CMD 命令使用：一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参，以下示例会提到。

示例：

假设已通过 Dockerfile 构建了 nginx:test 镜像：

```
FROM nginx

ENTRYPOINT ["nginx", "-c"] # 定参
CMD ["/etc/nginx/nginx.conf"] # 变参 
```

1、不传参运行

```
$ docker run  nginx:test
```

容器内会默认运行以下命令，启动主进程。

```
nginx -c /etc/nginx/nginx.conf
```

2、传参运行

```
$ docker run  nginx:test -c /etc/nginx/new.conf
```

容器内会默认运行以下命令，启动主进程(/etc/nginx/new.conf:假设容器内已有此文件)

```
nginx -c /etc/nginx/new.conf
```

##### ENV

设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。

格式：

```
ENV <key> <value>
ENV <key1>=<value1> <key2>=<value2>...
```

以下示例设置 NODE_VERSION = 7.2.0 ， 在后续的指令中可以通过 $NODE_VERSION 引用：

```
ENV NODE_VERSION 7.2.0

RUN curl -SLO "https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz" \
  && curl -SLO "https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc"
```

##### ARG

构建参数，与 ENV 作用一致。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。

构建命令 docker build 中可以用 --build-arg <参数名>=<值> 来覆盖。

格式：

```
ARG <参数名>[=<默认值>]
```

##### VOLUME

定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。

作用：

- 避免重要的数据，因容器重启而丢失，这是非常致命的。
- 避免容器不断变大。

格式：

```
VOLUME ["<路径1>", "<路径2>"...]
VOLUME <路径>
```

在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点。

##### EXPOSE

仅仅只是声明端口。

作用：

- 帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。
- 在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。

格式：

```
EXPOSE <端口1> [<端口2>...]
```

##### WORKDIR

指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。（WORKDIR 指定的工作目录，必须是提前创建好的）。

docker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。

格式：

```
WORKDIR <工作目录路径>
```

##### USER

用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）。

格式：

```
USER <用户名>[:<用户组>]
```

##### HEALTHCHECK

用于指定某个程序或者指令来监控 docker 容器服务的运行状态。

格式：

```
HEALTHCHECK [选项] CMD <命令>：设置检查容器健康状况的命令
HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令

HEALTHCHECK [选项] CMD <命令> : 这边 CMD 后面跟随的命令使用，可以参考 CMD 的用法。
```

##### ONBUILD

用于延迟构建命令的执行。简单的说，就是 Dockerfile 里用 ONBUILD 指定的命令，在本次构建镜像的过程中不会执行（假设镜像为 test-build）。当有新的 Dockerfile 使用了之前构建的镜像 FROM test-build ，这时执行新镜像的 Dockerfile 构建时候，会执行 test-build 的 Dockerfile 里的 ONBUILD 指定的命令。

格式：

```
ONBUILD <其它指令>
```

##### LABEL

LABEL 指令用来给镜像添加一些元数据（metadata），以键值对的形式，语法格式如下：

```
LABEL <key>=<value> <key>=<value> <key>=<value> ...
```

比如我们可以添加镜像的作者：

```
LABEL org.opencontainers.image.authors="runoob"
```

## （十一）Docker Compose

### 1.Compose 简介

Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。

如果你还不了解 YML 文件配置，可以先阅读 [YAML 入门教程](https://www.runoob.com/w3cnote/yaml-intro.html)。

Compose 使用的三个步骤：

- 使用 Dockerfile 定义应用程序的环境。
- 使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。
- 最后，执行 docker-compose up 命令来启动并运行整个应用程序。

docker-compose.yml 的配置案例如下（配置参数参考下文）：

**实例：**

```bash
\# yaml 配置实例
version**:** '3'
services:
 web:
  build**:** .
  ports**:

**  - "5000:5000"
  volumes**:

**  - .:/code
  \- logvolume01:/var/log
  links**:

**  - redis
 redis:
  image**:** redis
volumes:
 logvolume01**:** {}
```

### 2.Compose安装

由于笔者实在Linux系统上进行实验，因此在此仅记录在Linux（Ubuntu）上的安装方法

运行以下命令以下载 Docker Compose 的当前稳定版本：

```bash
sudo curl -L "https://github.com/docker/compose/releases/download/v2.2.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
```

要安装其他版本的 Compose，请替换 v2.2.2。

> Docker Compose 存放在 GitHub，不太稳定。
>
> 你可以也通过执行下面的命令，高速安装 Docker Compose。
>
> ```bash
> curl -L https://get.daocloud.io/docker/compose/releases/download/v2.4.1/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose
> ```

![截屏2023-10-02 21.55.30](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-02 21.55.30.png)

**注：**如出现Permission denied的报错，先输入sudo su，之后再输入上述代码即可

将可执行权限应用于二进制文件：

```bash
sudo chmod +x /usr/local/bin/docker-compose
```

![截屏2023-10-02 21.57.56](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-02 21.57.56.png)

创建软链：

```bash
sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose
```

![截屏2023-10-02 21.59.49](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-02 21.59.49.png)

输入以下命令测试是否安装成功：

```bash
docker-compose version
```

![截屏2023-10-02 22.25.07](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-02 22.25.07.png)

**注意**： 对于 alpine，需要以下依赖包： py-pip，python-dev，libffi-dev，openssl-dev，gcc，libc-dev，和 make。

### 3.Compose使用

#### 3.1准备工作

首先创建一个测试目录：

```bash
mkdir composetest
cd composetest
```

![截屏2023-10-02 22.29.27](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-02 22.29.27.png)

在测试目录中创建一个名为 app.py 的文件，并复制粘贴以下内容：

```python
import time
import redis
from flask import Flask

app = Flask(__name__)
cache = redis.Redis(host='redis', port=6379)


def get_hit_count():
  retries = 5
  while True:
    try:
      return cache.incr('hits')
    except redis.exceptions.ConnectionError **as** exc:
      if retries == 0:
        raise exc
      retries -= 1
      time.sleep(0.5)


@app.route('/')
def hello():
  count = get_hit_count()
  return 'Hello World! I have been seen {} times.**\n**'.format(count)
```

![截屏2023-10-02 22.30.49](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-02 22.30.49.png)

在此示例中，redis 是应用程序网络上的 redis 容器的主机名，该主机使用的端口为 6379。

在 composetest 目录中创建另一个名为 **requirements.txt** 的文件，内容如下：

```bash
flask
redis
```

![截屏2023-10-02 22.32.38](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-02 22.32.38.png)

#### 3.2创建 Dockerfile 文件

在 composetest 目录中，创建一个名为 **Dockerfile** 的文件，内容如下：

```bash
FROM python:3.7-alpine
WORKDIR /code
ENV FLASK_APP app.py
ENV FLASK_RUN_HOST 0.0.0.0
RUN apk add --no-cache gcc musl-dev linux-headers
COPY requirements.txt requirements.txt
RUN pip install -r requirements.txt
COPY . .
CMD ["flask", "run"]
```

![截屏2023-10-02 22.41.47](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-02 22.41.47.png)

#### 3.3创建 docker-compose.yml

在测试目录中创建一个名为 docker-compose.yml 的文件，然后粘贴以下内容:

```bash
\# yaml 配置
version: '3'
services:
 web:
  build: .
  ports:
   - "5000:5000"
 redis:
  image: "redis:alpine"
```

该 Compose 文件定义了两个服务：web 和 redis。

- **web**：该 web 服务使用从 Dockerfile 当前目录中构建的镜像。然后，它将容器和主机绑定到暴露的端口 5000。此示例服务使用 Flask Web 服务器的默认端口 5000 。
- **redis**：该 redis 服务使用 Docker Hub 的公共 Redis 映像

![截屏2023-10-02 22.47.18](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-02 22.47.18.png)

#### 4.使用 Compose 命令构建和运行您的应用

在测试目录中，执行以下命令来启动应用程序：

```
docker-compose up
```

![截屏2023-10-02 22.48.14](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-02 22.48.14.png)

![截屏2023-10-02 22.50.41](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-02 22.50.41.png)

如果你想在后台执行该服务可以加上 **-d** 参数，在此笔者就不做演示

```
docker-compose up -d
```

## （十二）Docker命令大全

详见：[Docker命令大全](https://www.runoob.com/docker/docker-command-manual.html)

# 二、Go Gin WEB（后端）学习

相关知识链接：

[Gin Web Framework (gin-gonic.com)](https://gin-gonic.com/)

[Documentation | Gin Web Framework (gin-gonic.com)](https://gin-gonic.com/docs/)

[示例 | Gin Web Framework (gin-gonic.com)](https://gin-gonic.com/zh-cn/docs/examples/)

[Go语言简介 (biancheng.net)](http://c.biancheng.net/golang/intro/)

[Go语言标准库文档中文版 | Go语言中文网 | Golang中文社区 | Golang中国 (studygolang.com)](https://studygolang.com/pkgdoc)

[前景 · Go语言中文文档 (topgoer.com)](https://www.topgoer.com/)

[Directory src - The Go Programming Language (google.cn)](https://golang.google.cn/pkg/)

[Go by Example](https://gobyexample.com/)

## （一）Gin Web简介

### 1.Gin 介绍

- Gin是一个golang的微框架，封装比较优雅，API友好，源码注释比较明确，具有快速灵活，容错方便等特点
- 对于golang而言，web框架的依赖要远比Python，Java之类的要小。自身的`net/http`足够简单，性能也非常不错
- 借助框架开发，不仅可以省去很多常用的封装带来的时间，也有助于团队的编码风格和形成规范

### 2.Gin安装教程

要安装Gin软件包，您需要安装Go并首先设置Go工作区，并按照如下步骤进行操作：

1.首先需要安装Go（需要1.10+版本），然后可以使用下面的Go命令安装Gin。笔者在MacOS系统下进行安装：

首先修改env配置

```bash
go env -w GO111MODULE=auto 
go env -w GOPROXY=https://goproxy.cn,direct
```

![截屏2023-10-06 15.22.09](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-06 15.22.09.png)

输入如下命令下载gin：

```bash
go get -u github.com/gin-gonic/gin
```

![截屏2023-10-06 15.23.52](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-06 15.23.52.png)

之后下载相关库依赖，以防启动项目报错：

```bash
git clone https://github.com/protocolbuffers/protobuf-go.git
git clone https://github.com/golang/tools.git
git clone https://github.com/golang/crypto.git
git clone https://github.com/go-playground/locales.git
git clone https://github.com/golang/net.git
git clone https://github.com/golang/text.git
git clone https://github.com/leodido/go-urn.git
git clone https://github.com/pelletier/go-toml.git
```

![截屏2023-10-06 15.30.39](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-06 15.30.39.png)

2.将其导入您的代码中：

> ```go
> import "github.com/gin-gonic/gin"
> ```

3.（可选）导入net/http。例如，如果使用常量，则需要这样做http.StatusOK。

> ```go
> import "net/http"
> ```

### 3.示例代码：HelloWorld

```go
package main

import (
    "net/http"

    "github.com/gin-gonic/gin"
)

func main() {
    // 1.创建路由
   r := gin.Default()
   // 2.绑定路由规则，执行的函数
   // gin.Context，封装了request和response
   r.GET("/", func(c *gin.Context) {
      c.String(http.StatusOK, "hello World!")
   })
   // 3.监听端口，默认在8080
   // Run("里面不指定端口号默认为8080") 
   r.Run(":8000")
}
```

![截屏2023-10-06 20.33.35](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-06 20.33.35.png)

注：根据运行结果可知，我们需要进入的端口为8000，即输入localhost:8000查看结果：

![截屏2023-10-06 20.35.12](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-06 20.35.12.png)

## （二）Gin路由

### 1.基本路由

- gin 框架中采用的路由库是基于httprouter做的
- 地址为：https://github.com/julienschmidt/httprouter

```go
package main

import (
    "net/http"

    "github.com/gin-gonic/gin"
)

func main() {
    r := gin.Default()
    r.GET("/", func(c *gin.Context) {
        c.String(http.StatusOK, "hello word")
    })
    
    r.POST("/xxxpost",getting)
    
    r.PUT("/xxxput")
    
    //监听端口默认为8080，因此端口不设置为8080
    r.Run(":3000")
}
```

### 2.API参数

- 可以通过Context的Param方法来获取API参数
- localhost:8000/xxx/zhangsan

```go
package main

import (
    "net/http"
    "strings"

    "github.com/gin-gonic/gin"
)

func main() {
    r := gin.Default()
    r.GET("/user/:name/*action", func(c *gin.Context) {
        name := c.Param("name")
        action := c.Param("action")
        //截取/
        action = strings.Trim(action, "/")
        c.String(http.StatusOK, name+" is "+action)
    })
    //默认为监听8080端口
    r.Run(":3000")
}
```

输入：http://localhost:3000/user/cr/daddy，输出结果如下：

![截屏2023-10-06 20.42.17](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-06 20.42.17.png)



### 3.URL参数

- URL参数可以通过DefaultQuery()或Query()方法获取
- DefaultQuery()若参数不存在，返回默认值，Query()若不存在，返回空串
- API ? name=zs

```go
package main

import (
    "fmt"
    "net/http"

    "github.com/gin-gonic/gin"
)

func main() {
    r := gin.Default()
    r.GET("/user", func(c *gin.Context) {
        //指定默认值
        //http://localhost:8080/user 才会打印出来默认的值
        name := c.DefaultQuery("name", "枯藤")
        c.String(http.StatusOK, fmt.Sprintf("hello %s", name))
    })
    r.Run()
}
```

不传递参数(http://localhost:8080/user)，输出的结果为：

![截屏2023-10-06 21.17.46](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-06 21.17.46.png)

传递参数(http://localhost:8080/user?name=crrr)输出的结果为：



### 4.表单参数

- 表单传输为post请求，http常见的传输格式为四种：
  - application/json
  - application/x-www-form-urlencoded
  - application/xml
  - multipart/form-data
- 表单参数可以通过PostForm()方法获取，该方法默认解析的是x-www-form-urlencoded或from-data格式的参数

```go
# 首先编写一个html文件
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <form action="http://localhost:8080/form" method="post" action="application/x-www-form-urlencoded">
        用户名：<input type="text" name="username" placeholder="请输入你的用户名">  <br>
        密&nbsp;&nbsp;&nbsp;码：<input type="password" name="userpassword" placeholder="请输入你的密码">  <br>
        <input type="submit" value="提交">
    </form>
</body>
</html>



package main

import (
    "fmt"
    "net/http"

    "github.com/gin-gonic/gin"
)

func main() {
    r := gin.Default()
    r.POST("/form", func(c *gin.Context) {
        types := c.DefaultPostForm("type", "post")
        username := c.PostForm("username")
        password := c.PostForm("userpassword")
        // c.String(http.StatusOK, fmt.Sprintf("username:%s,password:%s,type:%s", username, password, types))
        c.String(http.StatusOK, fmt.Sprintf("username:%s,password:%s,type:%s", username, password, types))
    })
    r.Run()
}
```

代码编写与输出结果如下：

![截屏2023-10-06 21.28.48](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-06 21.28.48.png)

![截屏2023-10-06 21.34.46](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-06 21.34.46.png)

![截屏2023-10-06 21.37.22](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-06 21.37.22.png)

![截屏2023-10-06 21.36.51](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-06 21.36.51.png)

### 5.上传单个文件

- multipart/form-data格式用于文件上传
- gin文件上传与原生的net/http方法类似，不同在于gin把原生的request封装到c.Request中

```go
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <form action="http://localhost:8080/upload" method="post" enctype="multipart/form-data">
          上传文件:<input type="file" name="file" >
          <input type="submit" value="提交">
    </form>
</body>
</html>



package main

import (
    "github.com/gin-gonic/gin"
)

func main() {
    r := gin.Default()
    //限制上传最大尺寸
    r.MaxMultipartMemory = 8 << 20
    r.POST("/upload", func(c *gin.Context) {
        file, err := c.FormFile("file")
        if err != nil {
            c.String(500, "上传图片出错")
        }
        // c.JSON(200, gin.H{"message": file.Header.Context})
        c.SaveUploadedFile(file, file.Filename)
        c.String(http.StatusOK, file.Filename)
    })
    r.Run()
}
```

运行效果如下所示：

![截屏2023-10-06 22.13.33](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-06 22.13.33.png)

![截屏2023-10-06 22.13.58](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-06 22.13.58.png)

### 6.上传特定文件

有的用户上传文件需要限制上传文件的类型以及上传文件的大小，但是gin框架暂时没有这些函数(也有可能是我没找到)，因此基于原生的函数写法自己写了一个可以限制大小以及文件类型的上传函数

```go
package main

import (
    "fmt"
    "log"
    "net/http"

    "github.com/gin-gonic/gin"
)

func main() {
    r := gin.Default()
    r.POST("/upload", func(c *gin.Context) {
        _, headers, err := c.Request.FormFile("file")
        if err != nil {
            log.Printf("Error when try to get file: %v", err)
        }
        //headers.Size 获取文件大小
        if headers.Size > 1024*1024*2 {
            fmt.Println("文件太大了")
            return
        }
        //headers.Header.Get("Content-Type")获取上传文件的类型
        if headers.Header.Get("Content-Type") != "image/png" {
            fmt.Println("只允许上传png图片")
            return
        }
        c.SaveUploadedFile(headers, "./video/"+headers.Filename)
        c.String(http.StatusOK, headers.Filename)
    })
    r.Run()
}
```

### 7.上传多个文件

相关代码如下：

```go
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <form action="http://localhost:8000/upload" method="post" enctype="multipart/form-data">
          上传文件:<input type="file" name="files" multiple>
          <input type="submit" value="提交">
    </form>
</body>
</html>


package main

import (
   "github.com/gin-gonic/gin"
   "net/http"
   "fmt"
)

// gin的helloWorld

func main() {
   // 1.创建路由
   // 默认使用了2个中间件Logger(), Recovery()
   r := gin.Default()
   // 限制表单上传大小 8MB，默认为32MB
   r.MaxMultipartMemory = 8 << 20
   r.POST("/upload", func(c *gin.Context) {
      form, err := c.MultipartForm()
      if err != nil {
         c.String(http.StatusBadRequest, fmt.Sprintf("get err %s", err.Error()))
      }
      // 获取所有图片
      files := form.File["files"]
      // 遍历所有图片
      for _, file := range files {
         // 逐个存
         if err := c.SaveUploadedFile(file, file.Filename); err != nil {
            c.String(http.StatusBadRequest, fmt.Sprintf("upload err %s", err.Error()))
            return
         }
      }
      c.String(200, fmt.Sprintf("upload ok %d files", len(files)))
   })
   //默认端口号是8080
   r.Run(":8000")
}
```

运行效果演示如下：

![截屏2023-10-06 22.38.06](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-06 22.38.06.png)

![截屏2023-10-06 22.38.17](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-06 22.38.17.png)

### 8.routes group

routes group是为了管理一些相同的URL,示例代码如下：

```go
package main

import (
   "github.com/gin-gonic/gin"
   "fmt"
)

// gin的helloWorld

func main() {
   // 1.创建路由
   // 默认使用了2个中间件Logger(), Recovery()
   r := gin.Default()
   // 路由组1 ，处理GET请求
   v1 := r.Group("/v1")
   // {} 是书写规范
   {
      v1.GET("/login", login)
      v1.GET("submit", submit)
   }
   v2 := r.Group("/v2")
   {
      v2.POST("/login", login)
      v2.POST("/submit", submit)
   }
   r.Run(":8000")
}

func login(c *gin.Context) {
   name := c.DefaultQuery("name", "jack")
   c.String(200, fmt.Sprintf("hello %s\n", name))
}

func submit(c *gin.Context) {
   name := c.DefaultQuery("name", "lily")
   c.String(200, fmt.Sprintf("hello %s\n", name))
}
```

运行效果如下：

![截屏2023-10-06 22.40.07](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-06 22.40.07.png)

### 9.路由原理

- httproter会将所有路由规则构造一颗前缀树
- 例如有 root and as at cn com

![img](https://www.topgoer.com/static/gin/1.1/12.png)

## （三）gin 数据解析和绑定

### 1.Json 数据解析和绑定

- 客户端传参，后端接收并解析到结构体

```go
package main

import (
   "github.com/gin-gonic/gin"
   "net/http"
)

// 定义接收数据的结构体
type Login struct {
   // binding:"required"修饰的字段，若接收为空值，则报错，是必须字段
   User    string `form:"username" json:"user" uri:"user" xml:"user" binding:"required"`
   Pssword string `form:"password" json:"password" uri:"password" xml:"password" binding:"required"`
}

func main() {
   // 1.创建路由
   // 默认使用了2个中间件Logger(), Recovery()
   r := gin.Default()
   // JSON绑定
   r.POST("loginJSON", func(c *gin.Context) {
      // 声明接收的变量
      var json Login
      // 将request的body中的数据，自动按照json格式解析到结构体
      if err := c.ShouldBindJSON(&json); err != nil {
         // 返回错误信息
         // gin.H封装了生成json数据的工具
         c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
         return
      }
      // 判断用户名密码是否正确
      if json.User != "root" || json.Pssword != "admin" {
         c.JSON(http.StatusBadRequest, gin.H{"status": "304"})
         return
      }
      c.JSON(http.StatusOK, gin.H{"status": "200"})
   })
   r.Run(":8000")
}
```

效果演示：

![截屏2023-10-06 22.56.02](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-06 22.56.02.png)

### 2.表单数据解析和绑定

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <form action="http://localhost:8000/loginForm" method="post" enctype="application/x-www-form-urlencoded">
        用户名<input type="text" name="username"><br>
        密码<input type="password" name="password">
        <input type="submit" value="提交">
    </form>
</body>
</html>


package main

import (
    "net/http"

    "github.com/gin-gonic/gin"
)

// 定义接收数据的结构体
type Login struct {
    // binding:"required"修饰的字段，若接收为空值，则报错，是必须字段
    User    string `form:"username" json:"user" uri:"user" xml:"user" binding:"required"`
    Pssword string `form:"password" json:"password" uri:"password" xml:"password" binding:"required"`
}

func main() {
    // 1.创建路由
    // 默认使用了2个中间件Logger(), Recovery()
    r := gin.Default()
    // JSON绑定
    r.POST("/loginForm", func(c *gin.Context) {
        // 声明接收的变量
        var form Login
        // Bind()默认解析并绑定form格式
        // 根据请求头中content-type自动推断
        if err := c.Bind(&form); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }
        // 判断用户名密码是否正确
        if form.User != "root" || form.Pssword != "admin" {
            c.JSON(http.StatusBadRequest, gin.H{"status": "304"})
            return
        }
        c.JSON(http.StatusOK, gin.H{"status": "200"})
    })
    r.Run(":8000")
}
```

效果展示：

![截屏2023-10-06 23.01.01](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-06 23.01.01.png)

### 3.URI数据解析和绑定

```go
package main

import (
    "net/http"

    "github.com/gin-gonic/gin"
)

// 定义接收数据的结构体
type Login struct {
    // binding:"required"修饰的字段，若接收为空值，则报错，是必须字段
    User    string `form:"username" json:"user" uri:"user" xml:"user" binding:"required"`
    Pssword string `form:"password" json:"password" uri:"password" xml:"password" binding:"required"`
}

func main() {
    // 1.创建路由
    // 默认使用了2个中间件Logger(), Recovery()
    r := gin.Default()
    // JSON绑定
    r.GET("/:user/:password", func(c *gin.Context) {
        // 声明接收的变量
        var login Login
        // Bind()默认解析并绑定form格式
        // 根据请求头中content-type自动推断
        if err := c.ShouldBindUri(&login); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }
        // 判断用户名密码是否正确
        if login.User != "root" || login.Pssword != "admin" {
            c.JSON(http.StatusBadRequest, gin.H{"status": "304"})
            return
        }
        c.JSON(http.StatusOK, gin.H{"status": "200"})
    })
    r.Run(":8000")
}
```

效果演示：

![截屏2023-10-07 08.35.35](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 08.35.35.png)

## （四）gin渲染

### 1.各种格式的响应

- json、结构体、XML、YAML类似于java的properties、ProtoBuf

```go
package main

import (
    "github.com/gin-gonic/gin"
    "github.com/gin-gonic/gin/testdata/protoexample"
)

// 多种响应方式
func main() {
    // 1.创建路由
    // 默认使用了2个中间件Logger(), Recovery()
    r := gin.Default()
    // 1.json
    r.GET("/someJSON", func(c *gin.Context) {
        c.JSON(200, gin.H{"message": "someJSON", "status": 200})
    })
    // 2. 结构体响应
    r.GET("/someStruct", func(c *gin.Context) {
        var msg struct {
            Name    string
            Message string
            Number  int
        }
        msg.Name = "root"
        msg.Message = "message"
        msg.Number = 123
        c.JSON(200, msg)
    })
    // 3.XML
    r.GET("/someXML", func(c *gin.Context) {
        c.XML(200, gin.H{"message": "abc"})
    })
    // 4.YAML响应
    r.GET("/someYAML", func(c *gin.Context) {
        c.YAML(200, gin.H{"name": "zhangsan"})
    })
    // 5.protobuf格式,谷歌开发的高效存储读取的工具
    // 数组？切片？如果自己构建一个传输格式，应该是什么格式？
    r.GET("/someProtoBuf", func(c *gin.Context) {
        reps := []int64{int64(1), int64(2)}
        // 定义数据
        label := "label"
        // 传protobuf格式数据
        data := &protoexample.Test{
            Label: &label,
            Reps:  reps,
        }
        c.ProtoBuf(200, data)
    })

    r.Run(":8000")
}
```

### 2.HTML模板渲染

- gin支持加载HTML模板, 然后根据模板参数进行配置并返回相应的数据，本质上就是字符串替换
- LoadHTMLGlob()方法可以加载模板文件

```go
package main

import (
    "net/http"

    "github.com/gin-gonic/gin"
)

func main() {
    r := gin.Default()
    r.LoadHTMLGlob("tem/*")
    r.GET("/index", func(c *gin.Context) {
        c.HTML(http.StatusOK, "index.html", gin.H{"title": "我是测试", "ce": "123456"})
    })
    r.Run()
}



<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>{{.title}}</title>
</head>
    <body>
        fgkjdskjdsh{{.ce}}
    </body>
</html>
```

目录结构:

![img](https://www.topgoer.com/static/gin/3.1/1.png)

- 如果你的目录结构是下面的情况

![img](https://www.topgoer.com/static/gin/3.1/2.png)

代码如下：

```go
package main

import (
    "net/http"

    "github.com/gin-gonic/gin"
)

func main() {
    r := gin.Default()
    r.LoadHTMLGlob("tem/**/*")
    r.GET("/index", func(c *gin.Context) {
        c.HTML(http.StatusOK, "user/index.html", gin.H{"title": "我是测试", "address": "www.5lmh.com"})
    })
    r.Run()
}
{{ define "user/index.html" }}



<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>{{.title}}</title>
</head>
    <body>
        fgkjdskjdsh{{.address}}
    </body>
</html>
{{ end }}
```

- 如果你想进行头尾分离就是下面这种写法了：

![img](https://www.topgoer.com/static/gin/3.1/3.png)

```go
package main

import (
    "net/http"

    "github.com/gin-gonic/gin"
)

func main() {
    r := gin.Default()
    r.LoadHTMLGlob("tem/**/*")
    r.GET("/index", func(c *gin.Context) {
        c.HTML(http.StatusOK, "user/index.html", gin.H{"title": "我是测试", "address": "www.5lmh.com"})
    })
    r.Run()
}
```

`user/index.html`文件代码：

```html
{{ define "user/index.html" }}
{{template "public/header" .}}
        fgkjdskjdsh{{.address}}
{{template "public/footer" .}}
{{ end }}
```

`public/header.html`文件代码：

```html
{{define "public/header"}}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>{{.title}}</title>
</head>
    <body>

{{end}}
```

`public/footer.html`文件代码：

```html
{{define "public/footer"}}
</body>
</html>
{{ end }}
```

- 如果你需要引入静态文件需要定义一个静态文件目录

```
    r.Static("/assets", "./assets")
```

### 3.重定向

```go
package main

import (
    "net/http"

    "github.com/gin-gonic/gin"
)

func main() {
    r := gin.Default()
    r.GET("/index", func(c *gin.Context) {
        c.Redirect(http.StatusMovedPermanently, "http://www.5lmh.com")
    })
    r.Run()
}
```

###  4.同步异步

- goroutine机制可以方便地实现异步处理
- 另外，在启动新的goroutine时，不应该使用原始上下文，必须使用它的只读副本

```go
package main

import (
    "log"
    "time"

    "github.com/gin-gonic/gin"
)

func main() {
    // 1.创建路由
    // 默认使用了2个中间件Logger(), Recovery()
    r := gin.Default()
    // 1.异步
    r.GET("/long_async", func(c *gin.Context) {
        // 需要搞一个副本
        copyContext := c.Copy()
        // 异步处理
        go func() {
            time.Sleep(3 * time.Second)
            log.Println("异步执行：" + copyContext.Request.URL.Path)
        }()
    })
    // 2.同步
    r.GET("/long_sync", func(c *gin.Context) {
        time.Sleep(3 * time.Second)
        log.Println("同步执行：" + c.Request.URL.Path)
    })

    r.Run(":8000")
}
```

## （五）gin中间件

### 1.全局中间件

- 所有请求都经过此中间件

```go
package main

import (
    "fmt"
    "time"

    "github.com/gin-gonic/gin"
)

// 定义中间
func MiddleWare() gin.HandlerFunc {
    return func(c *gin.Context) {
        t := time.Now()
        fmt.Println("中间件开始执行了")
        // 设置变量到Context的key中，可以通过Get()取
        c.Set("request", "中间件")
        status := c.Writer.Status()
        fmt.Println("中间件执行完毕", status)
        t2 := time.Since(t)
        fmt.Println("time:", t2)
    }
}

func main() {
    // 1.创建路由
    // 默认使用了2个中间件Logger(), Recovery()
    r := gin.Default()
    // 注册中间件
    r.Use(MiddleWare())
    // {}为了代码规范
    {
        r.GET("/ce", func(c *gin.Context) {
            // 取值
            req, _ := c.Get("request")
            fmt.Println("request:", req)
            // 页面接收
            c.JSON(200, gin.H{"request": req})
        })

    }
    r.Run()
}
```

输出结果：

![截屏2023-10-07 08.44.18](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 08.44.18.png)

![截屏2023-10-07 08.43.24](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 08.43.24.png)

### 2.Next方法

```go
package main

import (
    "fmt"
    "time"

    "github.com/gin-gonic/gin"
)

// 定义中间
func MiddleWare() gin.HandlerFunc {
    return func(c *gin.Context) {
        t := time.Now()
        fmt.Println("中间件开始执行了")
        // 设置变量到Context的key中，可以通过Get()取
        c.Set("request", "中间件")
        // 执行函数
        c.Next()
        // 中间件执行完后续的一些事情
        status := c.Writer.Status()
        fmt.Println("中间件执行完毕", status)
        t2 := time.Since(t)
        fmt.Println("time:", t2)
    }
}

func main() {
    // 1.创建路由
    // 默认使用了2个中间件Logger(), Recovery()
    r := gin.Default()
    // 注册中间件
    r.Use(MiddleWare())
    // {}为了代码规范
    {
        r.GET("/ce", func(c *gin.Context) {
            // 取值
            req, _ := c.Get("request")
            fmt.Println("request:", req)
            // 页面接收
            c.JSON(200, gin.H{"request": req})
        })

    }
    r.Run()
}
```

输出结果：

![截屏2023-10-07 08.44.18](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 08.44.18.png)

![截屏2023-10-07 08.43.24](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 08.43.24.png)

### 3.局部中间件

```go
package main

import (
    "fmt"
    "time"

    "github.com/gin-gonic/gin"
)

// 定义中间
func MiddleWare() gin.HandlerFunc {
    return func(c *gin.Context) {
        t := time.Now()
        fmt.Println("中间件开始执行了")
        // 设置变量到Context的key中，可以通过Get()取
        c.Set("request", "中间件")
        // 执行函数
        c.Next()
        // 中间件执行完后续的一些事情
        status := c.Writer.Status()
        fmt.Println("中间件执行完毕", status)
        t2 := time.Since(t)
        fmt.Println("time:", t2)
    }
}

func main() {
    // 1.创建路由
    // 默认使用了2个中间件Logger(), Recovery()
    r := gin.Default()
    //局部中间键使用
    r.GET("/ce", MiddleWare(), func(c *gin.Context) {
        // 取值
        req, _ := c.Get("request")
        fmt.Println("request:", req)
        // 页面接收
        c.JSON(200, gin.H{"request": req})
    })
    r.Run()
}
```

效果演示：

![截屏2023-10-07 08.44.18](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 08.44.18.png)

![截屏2023-10-07 08.43.24](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 08.43.24.png)

## （六）会话控制

### 1.Cookie介绍

- HTTP是无状态协议，服务器不能记录浏览器的访问状态，也就是说服务器不能区分两次请求是否由同一个客户端发出
- Cookie就是解决HTTP协议无状态的方案之一，中文是小甜饼的意思
- Cookie实际上就是服务器保存在浏览器上的一段信息。浏览器有了Cookie之后，每次向服务器发送请求时都会同时将该信息发送给服务器，服务器收到请求后，就可以根据该信息处理请求
- Cookie由服务器创建，并发送给浏览器，最终由浏览器保存
- 但需要注意的是，Cookie也有不安全、增加带宽消耗、可以被禁用、有上限等缺点

#### 6.1Cookie的用途

- 测试服务端发送cookie给客户端，客户端请求时携带cookie

### 2.Cookie实例

- 测试服务端发送cookie给客户端，客户端请求时携带cookie

```go
package main

import (
   "github.com/gin-gonic/gin"
   "net/http"
)

func AuthMiddleWare() gin.HandlerFunc {
   return func(c *gin.Context) {
      // 获取客户端cookie并校验
      if cookie, err := c.Cookie("abc"); err == nil {
         if cookie == "123" {
            c.Next()
            return
         }
      }
      // 返回错误
      c.JSON(http.StatusUnauthorized, gin.H{"error": "err"})
      // 若验证不通过，不再调用后续的函数处理
      c.Abort()
      return
   }
}

func main() {
   // 1.创建路由
   r := gin.Default()
   r.GET("/login", func(c *gin.Context) {
      // 设置cookie
      c.SetCookie("abc", "123", 60, "/",
         "localhost", false, true)
      // 返回信息
      c.String(200, "Login success!")
   })
   r.GET("/home", AuthMiddleWare(), func(c *gin.Context) {
      c.JSON(200, gin.H{"data": "home"})
   })
   r.Run(":8000")
}
```

输入http://localhost:8000/login

![截屏2023-10-07 08.49.55](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 08.49.55.png)

再访问http://localhost:8000/home

![截屏2023-10-07 08.50.40](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 08.50.40.png)

### 3.Sessions

gorilla/sessions为自定义session后端提供cookie和文件系统session以及基础结构。

主要功能是：

- 简单的API：将其用作设置签名（以及可选的加密）cookie的简便方法。
- 内置的后端可将session存储在cookie或文件系统中。
- Flash消息：一直持续读取的session值。
- 切换session持久性（又称“记住我”）和设置其他属性的便捷方法。
- 旋转身份验证和加密密钥的机制。
- 每个请求有多个session，即使使用不同的后端也是如此。
- 自定义session后端的接口和基础结构：可以使用通用API检索并批量保存来自不同商店的session。

代码：

```go
package main

import (
    "fmt"
    "net/http"

    "github.com/gorilla/sessions"
)

// 初始化一个cookie存储对象
// something-very-secret应该是一个你自己的密匙，只要不被别人知道就行
var store = sessions.NewCookieStore([]byte("something-very-secret"))

func main() {
    http.HandleFunc("/save", SaveSession)
    http.HandleFunc("/get", GetSession)
    err := http.ListenAndServe(":8080", nil)
    if err != nil {
        fmt.Println("HTTP server failed,err:", err)
        return
    }
}

func SaveSession(w http.ResponseWriter, r *http.Request) {
    // Get a session. We're ignoring the error resulted from decoding an
    // existing session: Get() always returns a session, even if empty.

    //　获取一个session对象，session-name是session的名字
    session, err := store.Get(r, "session-name")
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }

    // 在session中存储值
    session.Values["foo"] = "bar"
    session.Values[42] = 43
    // 保存更改
    session.Save(r, w)
}
func GetSession(w http.ResponseWriter, r *http.Request) {
    session, err := store.Get(r, "session-name")
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    foo := session.Values["foo"]
    fmt.Println(foo)
}
```

删除session的值：

```
    // 删除
    // 将session的最大存储时间设置为小于零的数即为删除
    session.Options.MaxAge = -1
    session.Save(r, w)
```

官网地址：http://www.gorillatoolkit.org/pkg/sessions



## （七）参数验证

### 1.结构体认证

用gin框架的数据验证，可以不用解析数据，减少if else，会简洁许多。

```go
package main

import (
    "fmt"
    "time"

    "github.com/gin-gonic/gin"
)

//Person ..
type Person struct {
    //不能为空并且大于10
    Age      int       `form:"age" binding:"required,gt=10"`
    Name     string    `form:"name" binding:"required"`
    Birthday time.Time `form:"birthday" time_format:"2006-01-02" time_utc:"1"`
}

func main() {
    r := gin.Default()
    r.GET("/5lmh", func(c *gin.Context) {
        var person Person
        if err := c.ShouldBind(&person); err != nil {
            c.String(500, fmt.Sprint(err))
            return
        }
        c.String(200, fmt.Sprintf("%#v", person))
    })
    r.Run()
}
```

演示地址：

http://localhost:8080/5lmh?age=11&name=枯藤&birthday=2006-01-02

### 2.自定义验证

都在代码里自己看吧

```go
package main

import (
    "net/http"
    "reflect"
    "github.com/gin-gonic/gin"
    "github.com/gin-gonic/gin/binding"
    "gopkg.in/go-playground/validator.v8"
)

/*
    对绑定解析到结构体上的参数，自定义验证功能
    比如我们要对 name 字段做校验，要不能为空，并且不等于 admin ，类似这种需求，就无法 binding 现成的方法
    需要我们自己验证方法才能实现 官网示例（https://godoc.org/gopkg.in/go-playground/validator.v8#hdr-Custom_Functions）
    这里需要下载引入下 gopkg.in/go-playground/validator.v8
*/
type Person struct {
    Age int `form:"age" binding:"required,gt=10"`
    // 2、在参数 binding 上使用自定义的校验方法函数注册时候的名称
    Name    string `form:"name" binding:"NotNullAndAdmin"`
    Address string `form:"address" binding:"required"`
}

// 1、自定义的校验方法
func nameNotNullAndAdmin(v *validator.Validate, topStruct reflect.Value, currentStructOrField reflect.Value, field reflect.Value, fieldType reflect.Type, fieldKind reflect.Kind, param string) bool {

    if value, ok := field.Interface().(string); ok {
        // 字段不能为空，并且不等于  admin
        return value != "" && !("5lmh" == value)
    }

    return true
}

func main() {
    r := gin.Default()

    // 3、将我们自定义的校验方法注册到 validator中
    if v, ok := binding.Validator.Engine().(*validator.Validate); ok {
        // 这里的 key 和 fn 可以不一样最终在 struct 使用的是 key
        v.RegisterValidation("NotNullAndAdmin", nameNotNullAndAdmin)
    }

    /*
        curl -X GET "http://127.0.0.1:8080/testing?name=&age=12&address=beijing"
        curl -X GET "http://127.0.0.1:8080/testing?name=lmh&age=12&address=beijing"
        curl -X GET "http://127.0.0.1:8080/testing?name=adz&age=12&address=beijing"
    */
    r.GET("/5lmh", func(c *gin.Context) {
        var person Person
        if e := c.ShouldBind(&person); e == nil {
            c.String(http.StatusOK, "%v", person)
        } else {
            c.String(http.StatusOK, "person bind err:%v", e.Error())
        }
    })
    r.Run()
}
```

示例2：

```go
package main

import (
    "net/http"
    "reflect"
    "time"

    "github.com/gin-gonic/gin"
    "github.com/gin-gonic/gin/binding"
    "gopkg.in/go-playground/validator.v8"
)

// Booking contains binded and validated data.
type Booking struct {
    //定义一个预约的时间大于今天的时间
    CheckIn time.Time `form:"check_in" binding:"required,bookabledate" time_format:"2006-01-02"`
    //gtfield=CheckIn退出的时间大于预约的时间
    CheckOut time.Time `form:"check_out" binding:"required,gtfield=CheckIn" time_format:"2006-01-02"`
}

func bookableDate(
    v *validator.Validate, topStruct reflect.Value, currentStructOrField reflect.Value,
    field reflect.Value, fieldType reflect.Type, fieldKind reflect.Kind, param string,
) bool {
    //field.Interface().(time.Time)获取参数值并且转换为时间格式
    if date, ok := field.Interface().(time.Time); ok {
        today := time.Now()
        if today.Unix() > date.Unix() {
            return false
        }
    }
    return true
}

func main() {
    route := gin.Default()
    //注册验证
    if v, ok := binding.Validator.Engine().(*validator.Validate); ok {
        //绑定第一个参数是验证的函数第二个参数是自定义的验证函数
        v.RegisterValidation("bookabledate", bookableDate)
    }

    route.GET("/5lmh", getBookable)
    route.Run()
}

func getBookable(c *gin.Context) {
    var b Booking
    if err := c.ShouldBindWith(&b, binding.Query); err == nil {
        c.JSON(http.StatusOK, gin.H{"message": "Booking dates are valid!"})
    } else {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
    }
}

// curl -X GET "http://localhost:8080/5lmh?check_in=2019-11-07&check_out=2019-11-20"
// curl -X GET "http://localhost:8080/5lmh?check_in=2019-09-07&check_out=2019-11-20"
// curl -X GET "http://localhost:8080/5lmh?check_in=2019-11-07&check_out=2019-11-01"
```



### 3.多语言翻译验证

当业务系统对验证信息有特殊需求时，例如：返回信息需要自定义，手机端返回的信息需要是中文而pc端发挥返回的信息需要时英文，如何做到请求一个接口满足上述三种情况。

```go
package main

import (
    "fmt"

    "github.com/gin-gonic/gin"
    "github.com/go-playground/locales/en"
    "github.com/go-playground/locales/zh"
    "github.com/go-playground/locales/zh_Hant_TW"
    ut "github.com/go-playground/universal-translator"
    "gopkg.in/go-playground/validator.v9"
    en_translations "gopkg.in/go-playground/validator.v9/translations/en"
    zh_translations "gopkg.in/go-playground/validator.v9/translations/zh"
    zh_tw_translations "gopkg.in/go-playground/validator.v9/translations/zh_tw"
)

var (
    Uni      *ut.UniversalTranslator
    Validate *validator.Validate
)

type User struct {
    Username string `form:"user_name" validate:"required"`
    Tagline  string `form:"tag_line" validate:"required,lt=10"`
    Tagline2 string `form:"tag_line2" validate:"required,gt=1"`
}

func main() {
    en := en.New()
    zh := zh.New()
    zh_tw := zh_Hant_TW.New()
    Uni = ut.New(en, zh, zh_tw)
    Validate = validator.New()

    route := gin.Default()
    route.GET("/5lmh", startPage)
    route.POST("/5lmh", startPage)
    route.Run(":8080")
}

func startPage(c *gin.Context) {
    //这部分应放到中间件中
    locale := c.DefaultQuery("locale", "zh")
    trans, _ := Uni.GetTranslator(locale)
    switch locale {
    case "zh":
        zh_translations.RegisterDefaultTranslations(Validate, trans)
        break
    case "en":
        en_translations.RegisterDefaultTranslations(Validate, trans)
        break
    case "zh_tw":
        zh_tw_translations.RegisterDefaultTranslations(Validate, trans)
        break
    default:
        zh_translations.RegisterDefaultTranslations(Validate, trans)
        break
    }

    //自定义错误内容
    Validate.RegisterTranslation("required", trans, func(ut ut.Translator) error {
        return ut.Add("required", "{0} must have a value!", true) // see universal-translator for details
    }, func(ut ut.Translator, fe validator.FieldError) string {
        t, _ := ut.T("required", fe.Field())
        return t
    })

    //这块应该放到公共验证方法中
    user := User{}
    c.ShouldBind(&user)
    fmt.Println(user)
    err := Validate.Struct(user)
    if err != nil {
        errs := err.(validator.ValidationErrors)
        sliceErrs := []string{}
        for _, e := range errs {
            sliceErrs = append(sliceErrs, e.Translate(trans))
        }
        c.String(200, fmt.Sprintf("%#v", sliceErrs))
    }
    c.String(200, fmt.Sprintf("%#v", "user"))
}
```

正确的链接：http://localhost:8080/testing?user_name=枯藤&tag_line=9&tag_line2=33&locale=zh

http://localhost:8080/testing?user_name=枯藤&tag_line=9&tag_line2=3&locale=en 返回英文的验证信息

http://localhost:8080/testing?user_name=枯藤&tag_line=9&tag_line2=3&locale=zh 返回中文的验证信息

查看更多的功能可以查看官网 gopkg.in/go-playground/validator.v9

## （八）日志文件

```go
package main

import (
    "io"
    "os"

    "github.com/gin-gonic/gin"
)

func main() {
    gin.DisableConsoleColor()

    // Logging to a file.
    f, _ := os.Create("gin.log")
    gin.DefaultWriter = io.MultiWriter(f)

    // 如果需要同时将日志写入文件和控制台，请使用以下代码。
    // gin.DefaultWriter = io.MultiWriter(f, os.Stdout)
    r := gin.Default()
    r.GET("/ping", func(c *gin.Context) {
        c.String(200, "pong")
    })
    r.Run()
}
```

效果演示：

![img](https://www.topgoer.com/static/gin/qita/1.png)

## （九）Air实时加载

本章我们要介绍一个神器——Air能够实时监听项目的代码文件，在代码发生变更之后自动重新编译并执行，大大提高gin框架项目的开发效率。

### 1.为什么需要实时加载？

之前使用Python编写Web项目的时候，常见的Flask或Django框架都是支持实时加载的，你修改了项目代码之后，程序能够自动重新加载并执行（live-reload），这在日常的开发阶段是十分方便的。

在使用Go语言的gin框架在本地做开发调试的时候，经常需要在变更代码之后频繁的按下Ctrl+C停止程序并重新编译再执行，这样就不是很方便。

### 2.Air介绍

怎样才能在基于gin框架开发时实现实时加载功能呢？像这种烦恼肯定不会只是你一个人的烦恼，所以我报着肯定有现成轮子的心态开始了全网大搜索。果不其然就在Github上找到了一个工具：Air[1]。它支持以下特性：

- 彩色日志输出
- 自定义构建或二进制命令
- 支持忽略子目录
- 启动后支持监听新目录
- 更好的构建过程

### 3.安装Air

#### Go

这也是最经典的安装方式：

```
    go get -u github.com/cosmtrek/air
```

#### MacOS

```
    curl -fLo air https://git.io/darwin_air
```

#### Linux

```
    curl -fLo air https://git.io/linux_air
```

#### Windows

```
    curl -fLo air.exe https://git.io/windows_air
```

#### Dcoker

```
docker run -it --rm \
    -w "<PROJECT>" \
    -e "air_wd=<PROJECT>" \
    -v $(pwd):<PROJECT> \
    -p <PORT>:<APP SERVER PORT> \
    cosmtrek/air
    -c <CONF>
```

然后按照下面的方式在docker中运行你的项目：

```
docker run -it --rm \
    -w "/go/src/github.com/cosmtrek/hub" \
    -v $(pwd):/go/src/github.com/cosmtrek/hub \
    -p 9090:9090 \
    cosmtrek/air
```

### 4.使用Air

为了敲命令更简单更方便，你应该把`alias air='~/.air'`加到你的`.bashrc`或`.zshrc`中。

首先进入你的项目目录：

```
cd /path/to/your_project
```

最简单的用法就是直接执行下面的命令：

```
# 首先在当前目录下查找 `.air.conf`配置文件，如果找不到就使用默认的
air -c .air.conf
```

推荐的使用方法是：

```
# 1. 在当前目录创建一个新的配置文件.air.conf
touch .air.conf

# 2. 复制 `air.conf.example` 中的内容到这个文件，然后根据你的需要去修改它

# 3. 使用你的配置运行 air, 如果文件名是 `.air.conf`，只需要执行 `air`。
air
```

### 5.air_example.conf示例

完整的air_example.conf示例配置如下，可以根据自己的需要修改。

```
# [Air](https://github.com/cosmtrek/air) TOML 格式的配置文件

# 工作目录
# 使用 . 或绝对路径，请注意 `tmp_dir` 目录必须在 `root` 目录下
root = "."
tmp_dir = "tmp"

[build]
# 只需要写你平常编译使用的shell命令。你也可以使用 `make`
cmd = "go build -o ./tmp/main ."
# 由`cmd`命令得到的二进制文件名
bin = "tmp/main"
# 自定义的二进制，可以添加额外的编译标识例如添加 GIN_MODE=release
full_bin = "APP_ENV=dev APP_USER=air ./tmp/main"
# 监听以下文件扩展名的文件.
include_ext = ["go", "tpl", "tmpl", "html"]
# 忽略这些文件扩展名或目录
exclude_dir = ["assets", "tmp", "vendor", "frontend/node_modules"]
# 监听以下指定目录的文件
include_dir = []
# 排除以下文件
exclude_file = []
# 如果文件更改过于频繁，则没有必要在每次更改时都触发构建。可以设置触发构建的延迟时间
delay = 1000 # ms
# 发生构建错误时，停止运行旧的二进制文件。
stop_on_error = true
# air的日志文件名，该日志文件放置在你的`tmp_dir`中
log = "air_errors.log"

[log]
# 显示日志时间
time = true

[color]
# 自定义每个部分显示的颜色。如果找不到颜色，使用原始的应用程序日志。
main = "magenta"
watcher = "cyan"
build = "yellow"
runner = "green"

[misc]
# 退出时删除tmp目录
clean_on_exit = true
```

## （十）gin验证码

在开发的过程中，我们有些接口为了防止被恶意调用，我们会采用加验证码的方式，例如：发送短信的接口，为了防止短信接口被频繁调用造成损失；注册的接口，为了防止恶意注册。在这里为大家推荐一个验证码的类库，方便大家学习使用。

```
github.com/dchest/captcha
```

web端是怎么实现验证码的功能呢？

- 提供一个路由，先在session里写入键值对（k->v），把值写在图片上，然后生成图片，显示在浏览器上面
- 前端将图片中的内容发送给后后端，后端根据session中的k取得v，比对校验。如果通过继续下一步的逻辑，失败给出错误提示

API接口验证码实现方式类似，可以把键值对存储在起来，验证的时候把键值对传输过来一起校验。这里我只给出了web端的方法，爱动手的小伙伴可以自己尝试一下。

### 1.后端

```go
package main

import (
    "bytes"
    "github.com/dchest/captcha"
    "github.com/gin-contrib/sessions"
    "github.com/gin-contrib/sessions/cookie"
    "github.com/gin-gonic/gin"
    "net/http"
    "time"
)

// 中间件，处理session
func Session(keyPairs string) gin.HandlerFunc {
    store := SessionConfig()
    return sessions.Sessions(keyPairs, store)
}
func SessionConfig() sessions.Store {
    sessionMaxAge := 3600
    sessionSecret := "topgoer"
    var store sessions.Store
    store = cookie.NewStore([]byte(sessionSecret))
    store.Options(sessions.Options{
        MaxAge: sessionMaxAge, //seconds
        Path:   "/",
    })
    return store
}

func Captcha(c *gin.Context, length ...int) {
    l := captcha.DefaultLen
    w, h := 107, 36
    if len(length) == 1 {
        l = length[0]
    }
    if len(length) == 2 {
        w = length[1]
    }
    if len(length) == 3 {
        h = length[2]
    }
    captchaId := captcha.NewLen(l)
    session := sessions.Default(c)
    session.Set("captcha", captchaId)
    _ = session.Save()
    _ = Serve(c.Writer, c.Request, captchaId, ".png", "zh", false, w, h)
}
func CaptchaVerify(c *gin.Context, code string) bool {
    session := sessions.Default(c)
    if captchaId := session.Get("captcha"); captchaId != nil {
        session.Delete("captcha")
        _ = session.Save()
        if captcha.VerifyString(captchaId.(string), code) {
            return true
        } else {
            return false
        }
    } else {
        return false
    }
}
func Serve(w http.ResponseWriter, r *http.Request, id, ext, lang string, download bool, width, height int) error {
    w.Header().Set("Cache-Control", "no-cache, no-store, must-revalidate")
    w.Header().Set("Pragma", "no-cache")
    w.Header().Set("Expires", "0")

    var content bytes.Buffer
    switch ext {
    case ".png":
        w.Header().Set("Content-Type", "image/png")
        _ = captcha.WriteImage(&content, id, width, height)
    case ".wav":
        w.Header().Set("Content-Type", "audio/x-wav")
        _ = captcha.WriteAudio(&content, id, lang)
    default:
        return captcha.ErrNotFound
    }

    if download {
        w.Header().Set("Content-Type", "application/octet-stream")
    }
    http.ServeContent(w, r, id+ext, time.Time{}, bytes.NewReader(content.Bytes()))
    return nil
}

func main() {
    router := gin.Default()
    router.LoadHTMLGlob("./*.html")
    router.Use(Session("topgoer"))
    router.GET("/captcha", func(c *gin.Context) {
        Captcha(c, 4)
    })
    router.GET("/", func(c *gin.Context) {
        c.HTML(http.StatusOK, "index.html", nil)
    })
    router.GET("/captcha/verify/:value", func(c *gin.Context) {
        value := c.Param("value")
        if CaptchaVerify(c, value) {
            c.JSON(http.StatusOK, gin.H{"status": 0, "msg": "success"})
        } else {
            c.JSON(http.StatusOK, gin.H{"status": 1, "msg": "failed"})
        }
    })
    router.Run(":8080")
}
```

### 2.前端页面

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>www.topgoer.com验证码</title>
</head>
<body>
<img src="/captcha" onclick="this.src='/captcha?v='+Math.random()">
</body>
</html>
```

浏览器访问[http://127.0.0.1:8080](http://127.0.0.1:8080/)

访问http://127.0.0.1:8080/captcha/verify/5721 进行验证

```
    {
        "msg": "failed",
        "status": 1
    }
```

# 三、React18+typescript hooks（前端）函数式写法学习

前置条件：nodejs 

视频学习参考地址：[React18+hooks之useState的使用方法_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1924y1e7ba/?spm_id_from=333.999.0.0&vd_source=1eecda9234223595880a3a83e762d22e)

## （一）nodejs下载及配置

### 1.官网下载与安装

访问nodejs官网，链接: https://nodejs.org/zh-cn/，选择红色选框内的点击安装。
LTS是稳定版。
Current是最新版本，最新的功能特性都在这里面。

![截屏2023-10-07 07.54.42](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 07.54.42.png)

点击 在 Finder 中显示，双击刚下载的文件，按步骤默认安装就行：

![截屏2023-10-07 08.03.08](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 08.03.08.png)

安装完成后，打开终端，输入 npm -v 和 node -v两个命令,如下图出现版本信息，说明安装成功：

![截屏2023-10-07 08.03.43](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 08.03.43.png)

### 2.npm配置淘宝镜像源(永久使用)

终端输入：

```terminal
npm config set registry https://registry.npm.taobao.org
```

验证配置是否成功：

```terminal
npm config get registry
```

![截屏2023-10-07 08.05.34](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 08.05.34.png)

若出现上述显示，则说明配置成功，现在你就可以使用npm install 下载东西了

### 3.配置cnpm

终端输入：

```terminal
sudo npm install -g cnpm --registry=https://registry.npm.taobao.org
```

![截屏2023-10-07 08.10.18](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 08.10.18.png)

![截屏2023-10-07 08.10.59](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 08.10.59.png)

查看安装是否成功输入 cnpm -v即可：

![截屏2023-10-07 08.11.27](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 08.11.27.png)

### 4.配置yarn

mac如果没安装过homeBrew先运行这个命令：

```terminal
/usr/bin/ruby -e "$(curl -fsSL http://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install)"
```

![截屏2023-10-07 08.16.20](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 08.16.20.png)

安装完 关闭窗口重新打开 检查版本yarn --version 检查是否安装成功(出现版本号证明成功安装)

### 5.npm使用[nrm](https://so.csdn.net/so/search?q=nrm&spm=1001.2101.3001.7020)切换镜像源

使用npm命令进行全局安装：

```terminal
udo npm install nrm -g --registry=https://registry.npm.taobao.org
```

使用命令 nrm ls 显示所有源:

![截屏2023-10-07 08.31.55](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 08.31.55.png)

其他相关操作见[mac 安装node.js](https://blog.csdn.net/weixin_46426412/article/details/127807670)

## （二）useState方法

useState是用来修改

### 1.前置配置

新建文件夹react_hooks_pro，并在终端输入如下命令新建脚手架：

```terminal
npm init vite@latest
```

按照提示进行新建，将project name命名为my_react_hooks,framework选择react语言

![截屏2023-10-07 08.59.41](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 08.59.41.png)

![截屏2023-10-07 09.02.37](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 09.02.37.png)

选择TypeScript + SWC

![截屏2023-10-07 09.03.17](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 09.03.17.png)

出现如下界面，则代表脚手架新建完毕：

![截屏2023-10-07 09.04.29](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 09.04.29.png)

接着我们进入文件目录，使用npm -i安装相关依赖：

![截屏2023-10-07 09.56.15](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 09.56.15.png)

安装完成后，(在my_react_hooks路径下)输入npm run dev启动：

![截屏2023-10-07 10.02.19](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 10.02.19.png)

输入local中的地址就可以查看我们创建的项目：

![截屏2023-10-07 10.05.33](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 10.05.33.png)在vscode中打开my_react_hooks，找到app.tsx,修改其中的内容如下图所示,方便我们进行后续的学习：

```react
import { useState } from 'react'
import reactLogo from './assets/react.svg'
import './App.css'

function App() {


  return (
    <div className='App'>
 
    </div>
  )
}

export default App
```

![截屏2023-10-07 10.17.23](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 10.17.23.png)

### 2.useState

代码示例如下：

```react
import { useState } from 'react'
import reactLogo from './assets/react.svg'
import './App.css'

function App() {

/* useState是用来修改react中的值的
*/
/* myname是变量，初始值是Cr 
如果响应式修改变量的值就要在前面加上set */
let [myname,setMyname] = useState('Cr'); 
  return (
    <div className='App'>
      <h1>{myname}</h1>
    </div>
  )
}

export default App
```

修改后查看我们的local地址，变成了：

![截屏2023-10-07 10.28.10](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 10.28.10.png)

可以使用<buttom></buttom>在底下加一个按钮

```react
import { useState } from 'react'
import reactLogo from './assets/react.svg'
import './App.css'

function App() {

/* useState是用来修改react中的值的
*/
/* myname是变量，初始值是Cr 
如果响应式修改变量的值就要在前面加上set */
let [myname,setMyname] = useState('Cr'); 

  return (
    <div className='App'>
      {/* onClick里面要写一个没有执行的函数*/}
      <button onClick={() => setMyname("DaddyCr")}>Change your name</button>
      <h1>{myname}</h1>
    </div>
  )
}

export default App
```

效果如下：

![截屏2023-10-07 10.37.10](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 10.37.10.png)

![截屏2023-10-07 10.37.22](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 10.37.22.png)

进一步，添加一点小功能，比如写一个函数实现让用户自己输入名字来修改姓名：

```react
import { useState } from 'react'
import reactLogo from './assets/react.svg'
import './App.css'

function App() {

/* useState是用来修改react中的值的
*/
/* myname是变量，初始值是Cr 
如果响应式修改变量的值就要在前面加上set */
let [myname,setMyname] = useState('Cr'); 

function updateyourName() {
  let _name: any = prompt('Plz input your name😋');
  setMyname(_name)
}
  return (
    <div className='App'>
      {/* onClick里面要写一个没有执行的函数*/}
      <button onClick={updateyourName}>Change your name</button>
      <h1>{myname}</h1>
    </div>
  )
}

export default App

```

![截屏2023-10-07 10.48.12](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 10.48.12.png)

![截屏2023-10-07 10.48.26](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 10.48.26.png)

## （三）useEffect方法

**注：**记得先在终端输入npm run dev启动项目

useEffect简称副作用，可以模拟dom已挂载的状态和监听值的实时变化

```react
import { useState,useEffect} from 'react'
import reactLogo from './assets/react.svg'
import './App.css'

function App() {

/* useState是用来修改react中的值的
*/
/* myname是变量，初始值是Cr 
如果响应式修改变量的值就要在前面加上set */
let [myname,setMyname] = useState('Cr'); 

function updateyourName() {
  let _name: any = prompt('Plz input your name😋');
  setMyname(_name)
}

/* useEffect副作用
第一个作用 模拟dom已挂载的状态
  第一个参数是箭头函数，第二个函数是空数组*/
// useEffect(() => {
//   console.log(document.getElementsByTagName('h1')[0])
// }, [])

/* 第二个作用，是监听值的实时变化 */
/* 当页面第一次渲染或者值当值发生变化的时候会触发
  第一个参数是箭头函数，第二个参数是一个数组，数组里面是监听的变量 */ 
// useEffect(() => {
//   console.log('myname has been changed')
// }, [myname])
return (
  <div className='App'>
    {/* onClick里面要写一个没有执行的函数*/}
    <button onClick={updateyourName}>Change your name</button>
    <h1>{myname}</h1>
  </div>
)
}

export default App
```

作用一演示：

![截屏2023-10-07 11.14.38](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 11.14.38.png)

作用二演示：

![截屏2023-10-07 11.22.24](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 11.22.24.png)

## （四）useEffect实现组建卸载和性能优化

### 1.组件卸载

为了演示useEffect的这个功能，我们需要首先在src下创建一个新文件夹，命名为components，并在其中新建CompA.tsx：

![截屏2023-10-07 11.33.37](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 11.33.37.png)

在CompA.tsx中输入如下代码：

```tsx
function CompA() {
    return (
        <div>
            <h1>I am Comp A</h1>
        </div>
    )
}

export default CompA;
```

在app.tsx中输入import CompA from"./components/CompA",并在return部分做出如下修改：

```react
return (
  <div className='App'>
    {/* onClick里面要写一个没有执行的函数*/}
    <button onClick={updateyourName}>Change your name</button>
    <h1>{myname}</h1>
    <CompA></CompA>
  </div>
)
```

返回主界面，就会发现现在多了“I am Comp A”的字样：

![截屏2023-10-07 13.54.13](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 13.54.13.png)

接下来回到CompA.tsx,编写如下代码：

```tsx
import { useEffect } from "react";
function CompA() {

    /* 使用useEffect实现在组件卸载的时候触发 类似于vue中的销毁*/
    useEffect(() => {
        return () => {
            console.log('Component has been deleted')
        }
    },[])
    return (
        <div>
            <h1>I am Comp A</h1>
        </div>
    )
}

export default CompA;
```

在app.tsx中修改代码如下：

```react
import { useState,useEffect} from 'react'
import reactLogo from './assets/react.svg'
import './App.css'
import CompA from"./components/CompA"

function App() {

/* useState是用来修改react中的值的
*/
/* myname是变量，初始值是Cr 
如果响应式修改变量的值就要在前面加上set */
let [myname, setMyname] = useState<string>('Cr');
let [flag, setFlag] = useState<boolean>(true);

function updateyourName() {
  let _name: any = prompt('Plz input your name😋');
  setMyname(_name)
}

/* useEffect副作用
第一个作用 模拟dom已挂载的状态
  第一个参数是箭头函数，第二个函数是空数组*/
// useEffect(() => {
//   console.log(document.getElementsByTagName('h1')[0])
// }, [])

/* 第二个作用，是监听值的实时变化 */
/* 当页面第一次渲染或者值当值发生变化的时候会触发
  第一个参数是箭头函数，第二个参数是一个数组，数组里面是监听的变量 */ 
// useEffect(() => {
//   console.log('myname has been changed')
// }, [myname])

/* 使用useEffect实现在组件卸载的时候触发 类似于vue中的销毁*/

return (
  <div className='App'>
    {/* onClick里面要写一个没有执行的函数*/}
    <button onClick={updateyourName}>Change your name</button>
    <h1>{myname}</h1>
    {/* 当组件不触发渲染时，就触发了卸载 */}
    <button onClick={() => setFlag(!flag)}>渲染/卸载</button>
    { flag ? <CompA></CompA>:""}
  </div>
)
}

export default App
```

效果演示：

![截屏2023-10-07 14.53.27](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 14.53.27.png)

### 2.性能优化

代码如下：

```tsx
import { useEffect } from "react";
function CompA() {

    /* 使用useEffect实现在组件卸载的时候触发 类似于vue中的销毁*/
    useEffect(() => {
        return () => {
            clearInterval(timer);
            console.log('Component has been deleted')
        }
    },[])

    /* 场景1:一进入页面就需要一个定时器*/ 
    let timer:any = null;
    useEffect(() => {
        timer = setInterval(() => {
            console.log(1)
        },500)
    },[])
    return (
        <div>
            <h1>I am Comp A</h1>
        </div>
    )
}

export default CompA;
```

效果演示：上述代码实现了一个定时器，且在我们点击渲染/卸载后停止计时，实现了前端的性能优化，减少了不必要的性能消耗

![截屏2023-10-07 15.04.31](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 15.04.31.png)

![截屏2023-10-07 15.08.46](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 15.08.46.png)

## （五）memo

作为一个缓存函数，我们可以通过memo方法使得上述的CompA被缓存起来，减少useState的性能消耗：

```tsx
// CompA.tsx
import { useEffect,memo } from "react";
const CompA = memo(() => {

    /* 使用useEffect实现在组件卸载的时候触发 类似于vue中的销毁*/
    useEffect(() => {
        return () => {
            clearInterval(timer);
            console.log('Component has been deleted')
        }
    },[])

    /* 场景1:一进入页面就需要一个定时器*/ 
    let timer:any = null;
    useEffect(() => {
        // timer = setInterval(() => {
            // console.log(1)
        // },500)
    },[])

    console.log('CompA已执行')

    return (
        <div>
            <h1>I am Comp A</h1>
        </div>
    )
})

export default CompA;
```

进入local界面后，只有一开始会出现“CompA已执行”，之后进行修改名字的操作后控制台不会再出现该语句

![截屏2023-10-07 22.11.10](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 22.11.10.png)

## （六）useCallback&useMemo

**给定场景：**子组件CompA想要修改父组件中num的值，即点一下按钮实现num+1

**思路：**父传子一个修改num的方法，子组件使用props接收并调用

```tsx
//CompA.tsx
import { memo } from "react";
interface propsObject {
    addNum:any
}
const CompA = memo((props:propsObject) => {
    console.log('CompA init...');

    return (
        <div>
            <h1>I am Comp A</h1>
            <button onClick={() => props.addNum()}>num+1</button>
        </div>
    )
})

export default CompA;

//App.tsx
import { useState} from 'react'
import './App.css'
import CompA from"./components/CompA"
function App() {
  let [num,setNum] = useState<number>(1);

/* 场景 子组件CompA想要修改父组件中num的值 */
/* 父传子一个修改num的方法，子组件使用props接收并调用 */

  function addNum(){
    setNum(num+1);
  }

  return (
    <div className='App'>
      <CompA addNum={addNum}></CompA>
      <h1>num:{num}</h1>
    </div>
  )
}

export default App
```

![截屏2023-10-07 22.37.16](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 22.37.16.png)

![截屏2023-10-07 22.37.29](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 22.37.29.png)

**代码优化：**使用useCallback进行缓存，解决子组件重复渲染的问题

```tsx
//App.tsx
import { useCallback,useState,useMemo} from 'react'
import './App.css'
import CompA from"./components/CompA"
function App() {
  let [num,setNum] = useState<number>(1);

/* 场景 子组件CompA想要修改父组件中num的值 */
/* 父传子一个修改num的方法，子组件使用props接收并调用 */

  const addNum = useCallback(() => {
    setNum(num=>num+1);
  },[])


  return (
    <div className='App'>
      <CompA addNum={addNum}></CompA>
      <h1>num:{num}</h1>
    </div>
  )
}

export default App
```

![截屏2023-10-07 22.51.38](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 22.51.38.png)

或者使用useMemo，其本质是一样的都是缓存，只是用法不同:

```tsx
import { useState,useMemo} from 'react'
import './App.css'
import CompA from"./components/CompA"
function App() {
  let [num,setNum] = useState<number>(1);

/* 场景 子组件CompA想要修改父组件中num的值 */
/* 父传子一个修改num的方法，子组件使用props接收并调用 */

  const addNum = useMemo(() => {
    return ()=> setNum(num=>num+1);
  },[])


  return (
    <div className='App'>
      <CompA addNum={addNum}></CompA>
      <h1>num:{num}</h1>
    </div>
  )
}

export default App
```

## （七）useContext

useContext用于给跨级组件进行通信

```tsx
import { useState} from 'react'
import './App.css'

interface props_obj{
  num:number,
  updateN: any
}
/* 孙组件 */
function Sun(props:props_obj) {
  return(
    <fieldset>
      <legend>孙组件</legend>
      <h2>Sun</h2>
      <button onClick={props.updateN}>加1</button>
      <h1>{props.num}</h1>
    </fieldset>
  )
}

/* 子组件 */
function Child(props:props_obj) {
  return(
    <fieldset>
      <legend>子组件</legend>
      <h2>Child</h2>
      <Sun num={props.num} updateN={props.updateN}></Sun> 
    </fieldset>
  )
}
/* 父组件 */
function App() {
  let [num, setNum] = useState(0);
  function updateN() {
    setNum(num => num + 1)
  }


  return (
    <div className='App'>
      <fieldset>
        <legend>父组件</legend>
        <h2>App</h2>
        <Child num={num} updateN={updateN}></Child>
      </fieldset>  
    </div>
  )
}

export default App
```

上述代码实现了“数字加一”在父、子、孙三代间的传递，但显然很麻烦，层级一多便不好处理。

所以我们使用useContext解决这个问题：

```tsx
import { useState, createContext, useContext} from 'react'
import './App.css'

let NumContext = createContext(0) //调用createContext方法并定义初始值

/* 孙组件 */
function Sun() {
  let {num, updateN} = useContext(NumContext);
  return(
    <fieldset>
      <legend>孙组件</legend>
      <h2>Sun</h2>
      <button onClick={updateN}>加1</button>
      <h1>{num}</h1>
    </fieldset>
  )
}

/* 子组件 */
function Child() {
  return(
    <fieldset>
      <legend>子组件</legend>
      <h2>Child</h2>
      <Sun></Sun> 
    </fieldset>
  )
}
/* 父组件 */
function App() {
  let [num, setNum] = useState(0);
  function updateN() {
    setNum(num => num + 1)
  }


  return (
    <div className='App'>
      <NumContext.Provider value={{num, updateN}}>
        <fieldset>
          <legend>父组件</legend>
          <h2>App</h2>
          <Child></Child>
        </fieldset>  
      </NumContext.Provider>
    </div>
  )
}

export default App
```

![截屏2023-10-08 08.43.00](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-08 08.43.00.png)

![截屏2023-10-08 08.45.40](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-08 08.45.40.png)

## （八）受控组件&useRef非受控组件

### 1.受控组件

```tsx
// App.tsx
import './App.css'
import { useState } from 'react';

/* 父组件 */
function App() {
  let [val,setVal] = useState<string>("");


  return (
    <div className='App'>
      <fieldset>
        <legend>受控组件</legend>
        <input type='text' value={val} onChange={(e)=>setVal(e.target.value)}/>
        <button onClick={()=>console.log(val)}>获取值</button>
      </fieldset>
    </div>
  )
}

export default App;
```

![截屏2023-10-09 08.25.44](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-09 08.25.44.png)

### 2.非受控组件

```tsx
import './App.css'
import { useState,useRef } from 'react';

/* 父组件 */
function App() {
  let [val,setVal] = useState<string>("");
  let element:any = useRef(null);

  return (
    <div className='App'>
      <fieldset>
        <legend>受控组件</legend>
        <input type='text' value={val} onChange={(e)=>setVal(e.target.value)}/>
        <button onClick={()=>console.log(val)}>获取值</button>
      </fieldset>
      <fieldset>
        <legend>非受控组件</legend>
        <input type="text" ref = {element}/>
        <button onClick={()=>console.log(element.current.value)}>获取值</button>
      </fieldset>
    </div>
  )
}

export default App;
```

![截屏2023-10-09 08.31.32](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-09 08.31.32.png)

## （九）React-Redux状态管理器的极简使用

### 1.安装

在终端输入如下指令安装React-Redux:

```bash
npm i redux react-redux --save
```

![截屏2023-10-08 22.42.27](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-08 22.42.27.png)

若安装成功，可以在package.json下找到他们：

![截屏2023-10-08 22.46.01](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-08 22.46.01.png)

### 2.创建仓库

src下新建新文件夹store，里面新建reducer.js用来定义默认数据和导出函数;新建index.js用来创建仓库和引用reducer：

```js
// reducer.js
// 定义默认数据
const defultState = {
    str:"666"
}

//导出函数
export default (state=defultState,action) => {
    return state;
}
```

```js
// index.js
//用来创建仓库(createStore)，引用reducer并导出store
import reducer from './reducer';
import { createStore } from 'redux';

export const store = createStore(reducer)
```

### 3.提供器和连接器

使用提供器和连接器实现全局组件的状态共享。

```tsx
//main.tsx中使用提供器
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import './index.css'
import { store } from './store'
// 提供器
import { Provider } from 'react-redux'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <Provider store={store}>
      <App />
    </Provider>

  </React.StrictMode>,
)
```

```tsx
//App.tsx中使用连接器
import './App.css'
import { connect } from 'react-redux';
/* 
  React Redux 针对React所设计的状态管理工具
  1.安装
  2.仓库的创建
  3.提供器和链接器
  4.事件
*/
/*  */
function App(props:any) {




  return (
    <div className='App'>
      <h1>{ props.str }</h1>
    </div>
  )
}
const mapStateToProps = (state:any) => {
  return {
    str: state.str
  }
}
export default connect(mapStateToProps)(App);
```

运行效果:

![截屏2023-10-08 23.05.49](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-08 23.05.49.png)

## （十）React-Redux中全局状态值的修改

React-Redux的事件，就是修改state中状态的值

我们需要在reducer.js中去定义，并在组件中写映射：

```js
//reducer.js
// 定义默认数据
const defultState = {
    str:"Cr666"
}

//导出函数
export default (state=defultState,action) => {
    let newState = JSON.parse(JSON.stringify(state));
    switch(action.type){
        case "changeStr":
            newState.str = action.value;
            break;
        default:
            break;
    }
    return newState;
}
```

```tsx
//App.tsx
import './App.css'
import { connect } from 'react-redux';
/* 
  React Redux 针对React所设计的状态管理工具
  1.安装
  2.仓库的创建
  3.提供器和链接器
  4.事件
*/
/*  */
function App(props:any) {




  return (
    <div className='App'>
      <h1 onClick={props.changeFn}>{ props.str }</h1>
    </div>
  )
}
const mapStateToProps = (state:any) => {
  return {
    str: state.str
  }
}
const mapDispatchToProps = (dispatch:any) => {
  return{
    changeFn:function(){
      let action = {type:'changeStr',value:'今天起滴有点找🤔，闲着没事我做个憨包😋🍔！'}
      dispatch(action);
    }
  }
}
export default connect(mapStateToProps,mapDispatchToProps)(App);
```



# 四、实验报错及解决方案

**（一）Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it?**

下载镜像相关依赖包时出错：

![截屏2023-09-29 08.11.19](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 08.11.19.png)

**解决方案：**这里是因为apt-get 被锁住了，解决方法为在终端输入如下代码：

```shell
sudo rm /var/lib/dpkg/lock-frontend
sudo rm /var/lib/dpkg/lock
```

之后就可以正常使用apt-get install了：

![截屏2023-09-29 08.24.17](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 08.24.17.png)

------

**（二）gpg: no valid OpenPGP data found.**

添加 Docker 的官方 GPG 密钥时，报错如下：

![截屏2023-09-29 08.27.16](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 08.27.16.png)

**解决方案：**输入如下命令

```shell
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
```

![截屏2023-09-29 08.28.43](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 08.28.43.png)

------

**（三）ERROR: Got permission denied while trying to connect to the Docker daemon socket**

在运行docker命令，如docker version或docker info时，docker报错：

```shell
ERROR: Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: 
Get http://%2Fvar%2Frun%2Fdocker.sock/v1.24/info: dial unix /var/run/docker.sock: connect: permission denied
```

**解决方案：**从上面的报错信息上我们知道，这句话的大致意思就是在我门试图通过socket去连接docker时权限不被允许。这是应为socket需要root用户才能访问，当前用户的权限不够，所以被禁止了。所以添加docker的用户组，把当前用户加入组中，就可以解决问题了

```shell
sudo groupadd docker               #添加用户组
sudo gpasswd -a username docker    #将当前用户添加至用户组
newgrp docker                      #更新用户组
```

![截屏2023-09-29 09.31.35](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 09.31.35.png)

------

**（四）WARNING: The requested image's platform (linux/amd64) does not match the detected host platform (linux/arm64/v8) and no specific platform was requested**

在尝试运行web应用时报错：

![截屏2023-09-29 20.05.52](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 20.05.52.png)

**解决方案：**这个警告信息是因为我正在尝试在非amd64架构的机器上运行一个为amd64架构构建的Docker镜像，可以尝试**使用QEMU进行模拟**

首先，需要安装QEMU

```bash
sudo apt update  
sudo apt install qemu-user-static
```

![截屏2023-09-30 11.13.32](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-30 11.13.32.png)

使用QEMU模拟运行你的Docker镜像首先，你需要找到你的Docker镜像的文件名，通常是`.tar`文件然后，你可以使用以下命令来使用QEMU模拟运行你的Docker镜像：

```bash
qemu-aarch64 -machine type=q35,accel=tcg docker load -i your_image.tar
```

```bash
qemu-aarch64 -machine type=q35,accel=tcg docker run -i your_image_name
```

其中`your_image_name`是你的Docker镜像的名字。

安装完毕后，输入如下命令启动training/webapp：

```bash
docker run --rm -t training/webapp
```

------

**（五）Error response from daemon: pull access denied for hpptd, repository does not exist or may require 'docker login': denied: requested access to the resource is denied**

使用pull命令下载hpptd镜像时，报错如下：

![截屏2023-09-29 21.27.54](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-29 21.27.54.png)

**解决方案：**使用**docker restart**指令重新启动容器就OK了

**（六）Job for docker.service failed because the control process exited with error code**

配置DNS时，报错![截屏2023-09-30 21.10.55](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-09-30 21.10.55.png)

**解决方案：**初步判断可能又是因为我的架构不同，导致老师给的DNS配置用不了，所以首先是要找到本机的DNS:

```bash
cat /etc/resolv.conf | grep 'nameserver'
nameserver 127.0.0.53
```

然后还是不对，解决不了，算了😋

**（七）unable to access https://github.com/xxx/xxx: HTTP/2 stream 1 was not closed cleanly before**

安装gin过程中，下载相关库依赖时出现如下报错：

![截屏2023-10-06 15.33.47](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-06 15.33.47.png)

**解决方案：**git默认使用http/2.0协议，而github还是http/1.1 ，因此我们输入如下指令即可：

```bash
git config --global http.version HTTP/1.1
```

**（八）../gin-gonic/main.go:6:2: no required module provides package github.com/gin-gonic/gin: go.mod file not found in current directory or any parent directory; see 'go help modules'**

创建路由时，报错：

![截屏2023-10-06 19.59.57](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-06 19.59.57.png)

**解决方案：**使用go mod tidy 命令管理导入模块即可

**（九）go: pattern all: open /Users/yangchaoran/Library/Suggestions: operation not permitted**

使用go mod tidy命令时出现上述报错：

![截屏2023-10-06 20.12.45](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-06 20.12.45.png)

**解决方案：**笔者当时已经在vs code打开了项目文件，将运行的代码关闭后就可以执行上述命令了

**（十）npm ERR!**

新建脚手架时报错：

![截屏2023-10-07 08.55.35](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 08.55.35.png)

**解决方案：**

```terminal
sudo chown -R 501:20 "/Users/yangchaoran/.npm"
```

![截屏2023-10-07 08.59.08](/Users/yangchaoran/Library/Application Support/typora-user-images/截屏2023-10-07 08.59.08.png)

# 五、心得体会

国庆之后几天才把这个报告写完，毕竟放假了还是想着好好休息一下，去了趟内蒙古，现在只能说做起来有点赶。

本次实验的学习内容非常充实，涉及了Docker、前端和后端，在这个充实而富有挑战（因为国庆快结束了才开始做实验）的一周里，我沉浸在Docker、go gin web和React18+typescript hooks（前端）函数式写法的世界中，尽管学习过程略显疲惫，但那种探求知识的满足感和解决问题的喜悦让我倍感充实。随着国庆假期的结束，我知道我必须将这份宝贵的经历记录下来，以此纪念这段难忘的学习旅程。

首先，我想谈谈Docker。Docker让我明白了容器化技术的重要性和它如何改变我们开发和部署应用程序的方式。通过Docker，我们可以轻松地创建、部署和运行应用程序，而无需担心基础设施的问题。在学习过程中，我尝试构建了自己的Docker镜像，并成功将一个简单的Web应用部署到了Docker容器中。这让我深感Docker的强大和实用性。

接下来是go gin web。Gin是一个轻量级的Go语言Web框架，它让我重新认识了Web开发的面貌。通过学习Gin，我了解到了如何使用Go语言的特性来构建高效、可扩展的Web应用。函数式编程在Gin中得到了充分体现，无论是路由还是中间件，都可以通过函数来实现，这大大简化了Web应用的开发过程。我也因此得以在短时间内掌握了一种新的Web开发方法。

最后，我深入研究了React18+typescript hooks（前端）函数式写法。React是一个流行的前端框架，而函数式编程在前端领域的应用越来越广泛。通过学习React和TypeScript的函数式编程，我了解到如何使用这些工具来提高前端的可维护性和可读性。函数式编程强调不变性和纯函数，这使得代码更易于理解和测试，也降低了代码的复杂性。

然而，我深感自己在学习过程中的不足。尽管我在理论上掌握了许多新的知识和技能，但在实际应用中，我还需要更多的实践来提高我的熟练度和解决问题的能力。此外，我也需要在这个过程中加深对各项技术更深层次的理解，以便在日后的工作中更好地应用这些知识。

随着国庆假期的结束，我意识到学习和成长的过程从未结束。每一次的经历都是一次宝贵的财富，每一次的挑战都是一次成长的机会。我将把这次学习的经历作为一段美好的回忆，同时也将以更加坚定的步伐继续前进，不断追求新的知识和技能。

回顾这周的学习历程，我深感其乐无穷。尽管有困难和挑战，但每一次的成功都让我感到无比的喜悦。这让我更加期待未来的学习旅程，我坚信，只要我持之以恒，我就能在知识的海洋中不断前行，实现自己的目标。

在未来的学习和工作中，我将更加注重实践和应用。只有通过实践，我才能更好地理解和掌握所学的知识，并将其转化为实际的解决问题的能力。此外，我也将把函数式编程的理念应用到我的代码中，以提高代码的可读性和可维护性。同时，我也会继续研究Docker和Go Gin Web，让这些技术在我们的项目中发挥更大的作用。

最后，我想说，尽管国庆假期已经结束，但我们的学习永远不会停止。让我们把握每一天的时光，不断学习、成长和进步，为实现我们的梦想而努力！
